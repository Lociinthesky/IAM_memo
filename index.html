<html>
<head>
		<meta charset="UTF-8">
<link rel="preload" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="stylesheet" href="https://cdnjs.cloudflare.com/ajax/libs/twitter-bootstrap/3.3.7/css/bootstrap.min.css">
<link rel="preload" type="text/css" href="styles.css">
<link rel="stylesheet" type="text/css" href="styles.css">
<link href="https://fonts.googleapis.com/css?family=News+Cycle:400,700" rel="preload" type="text/css">
<link href="https://fonts.googleapis.com/css?family=News+Cycle:400,700" rel="stylesheet" type="text/css">

<link href="https://fonts.googleapis.com/css?family=Convergence" rel="preload" type="text/css">
<link href="https://fonts.googleapis.com/css?family=Convergence" rel="stylesheet" type="text/css">

<link href="https://fonts.googleapis.com/css?family=Reenie+Beanie" rel="preload">
<link href="https://fonts.googleapis.com/css?family=Reenie+Beanie" rel="stylesheet">
<!--<link href="https://fonts.googleapis.com/css?family=Rock+Salt" rel="stylesheet">-->

<link href="https://fonts.googleapis.com/css?family=Roboto" rel="preload">
<link href="https://fonts.googleapis.com/css?family=Roboto" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Kalam" rel="preload">
<link href="https://fonts.googleapis.com/css?family=Kalam" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=Orbitron" rel="preload">
<link href="https://fonts.googleapis.com/css?family=Orbitron" rel="stylesheet">

<link href="https://fonts.googleapis.com/css?family=GFS+Neohellenic|Shadows+Into+Light" rel="preload">
<link href="https://fonts.googleapis.com/css?family=GFS+Neohellenic|Shadows+Into+Light" rel="stylesheet">
<!--<script src="https://ajax.googleapis.com/ ajax/libs/jquery/3.2.1/jquery.min.js"></script>-->
<!--
Use the following CSS rules to specify these families:
font-family: 'Permanent Marker', cursive;
font-family: 'La Belle Aurore', cursive;
font-family: 'Averia Libre', cursive;
font-family: 'GFS Neohellenic', sans-serif;
font-family: 'Shadows Into Light', cursive;
font-family: 'Nothing You Could Do', cursive; -->

<style type="text/css">


</style>


<script src="https://ajax.googleapis.com/ajax/libs/jquery/1.11.3/jquery.min.js"></script>
<script>
//For production:
//	countdownseconds should be 60
//	Enter to finish should be disabled
//  competitionMode should be true (this should show Preload button to preload competition data for the file-based events)
	const competitionMode = true;


	var red = "rgba(255,128,128,0.57)";
	var orange = "rgba(255,163,102,0.57)";
	var yellow = "rgba(255,255,128,0.87)";
	var green = "rgba(179,255,102,0.57)";
	var sky = "rgba(128,191,255,0.57)";
	var purple = "rgba(223,159,191,0.87)";

	var mainImagesLoaded = 0;
	var preloading = false;
	var resuming = false;
	var myTimer;
	var markArray = [];

	var preloaded = false;

	const events = [
		{
			"ref": "5N",
			"label": "5-minute Numbers",
			"amount": 720, //WR 568, need 681 -> 720
			"memoTime": 300,
			"recallTime": 900
		},

		{
			"ref": "15N",
			"label": "15-minute Numbers",
			"amount": 1320, //WR 1100, need 1320
			"memoTime": 900,
			"recallTime": 1800
		},

		{
			"ref": "30N",
			"label": "30-Minute Numbers",
			"amount": 2320, //WR 1933, need 2319 -> 2320
			"memoTime": 1800,
			"recallTime": 3600
		},
		{
			"ref": "60N",
			"label": "Hour Numbers",
			"amount": 3920, //WR 3238, need 3886 -> 3920
			"memoTime": 3600,
			"recallTime": 7200
		},
		{
			"ref": "5F",
			"label": "5-Minute Names & Faces",
			"amount": 126, //WR 105, need 126
			"memoTime": 300,
			"recallTime": 900
		},
		{
			"ref": "15F",
			"label": "15-Minute Names & Faces",
			"amount": 254, //WR 212, need 254
			"memoTime": 900,
			"recallTime": 1800
		},
		{
			"ref": "5W",
			"label": "5-Minute Words",
			"amount": 180, //WR 140, need 168 -> 180
			"memoTime": 300,
			"recallTime": 900
		},
		{
			"ref": "15W",
			"label": "15-Minute Words",
			"amount": 400, //WR 318, need 381 -> 400
			"memoTime": 900,
			"recallTime": 1800
		},
		{
			"ref": "S",
			"label": "Spoken Numbers",
			"amount": 700,
			"recallTime": 1200
		},
		{
			"ref": "D",
			"label": "5-Minute Dates",
			"amount": 160, //WR 133, need 160
			"memoTime": 300,
			"recallTime": 900
		},
		{
			"ref": "SC",
			"label": "Speed Cards",
			"amount": 1,
			"memoTime": 300,
			"recallTime": 300
		},
		{
			"ref": "10C",
			"label": "10-Minute Cards",
			"amount": 12,	//WR 493 cards, need 11.37 decks, rounded up to 12
			"memoTime": 600,
			"recallTime": 1200
		},
		{
			"ref": "30C",
			"label": "30-Minute Cards",
			"amount": 26, //WR 1092 cards, need 25.2 decks, rounded up to 26
			"memoTime": 1800,
			"recallTime": 3600
		},
		{
			"ref": "60C",
			"label": "Hour Cards",
			"amount": 41, //WR 1776 cards, need 40.98 decks, rounded up to 41
			"memoTime": 3600,
			"recallTime": 7200
		},
		{
			"ref": "5I",
			"label": "5-Minute Images",
			"amount": 435, //WR 360, need 432
			"memoTime": 300,
			"recallTime": 900
		},
		{
			"ref": "5B",
			"label": "5-Minute Binary",
			"amount": 1410,	//WR 1170, need 1404 -> 1410
			"memoTime": 300,
			"recallTime": 900
		},
		{
			"ref": "30B",
			"label": "30-Minute Binary",
			"amount": 7530, //WR 6270, need 7524 -> 7530
			"memoTime": 1800,
			"recallTime": 3600
		}
	];

	//const nationalEvents = ["5N","15N","5F","5W","D","SC","10C","5I","S","5B"];
	const nationalEvents = ["5N", "15N", "5F", "5W", "D", "SC", "10C", "5I", "5B"];

	//const internationalEvents = ["5N","30N","15F","15W","D","SC","30C","5I","S","30B"];
	const internationalEvents = ["5N", "30N", "15F","15W", "D", "SC", "30C", "5I", "30B"];

	//const worldEvents = ["5N","60N","15F","15W","D","SC","60C","5I","S","30B"];
	const worldEvents = ["5N", "60N", "15F","15W", "D", "SC", "60C", "5I", "30B"];


	const suitInitialList = new Array("s", "c", "h", "d");
	const faceList = new Array("J", "Q", "K");
	const nonfaceList = new Array("A", "2", "3", "4", "5", "6", "7", "8", "9", "10");

	const numbersPerPage = 480;
	const binaryPerPage = 360;
	const numbersPerRow = 40;
	const binaryPerRow = 30;
	const imagesPerPage = 25;
	const wordColumnsPerPage = 5;
	const wordsPerColumn = 20;
	var wordsPerPage;

	const nameRowsPerPage = 3;
	const namesPerRow = 3;
	var namesPerPage;

	//Change to 60 for real
	const countdownSeconds = 5;

	//const cardOffset = 48;
	const cardOffset = 9;
	//const cardOffsetBig = 124;
	const cardOffsetBig = 22;

	const numberOfJpgs = 466;
	const numberOfPngs = 5894;







	var skin = "";

	var currentDiscipline = "";
	var memoTime = "";
	var recallTime = "";
	var amount = 0;
	var grouping;
	var groupingH;
	var groupingW;
	var miniGroupings = [];
	var miniGroupStarts = [];
	var locusStarts = [];
	var imgsPerLocus = 1;
	var separations = [];
	var hiColour;

	var countSeconds;
	var cint;

	var numberOfPages;
	var numberList;
	var binaryList;
	var binLevels;
	var curPos;
	var curMiniGroup;
	var curLocus;
	var curPage;
	var memoTimeTaken;
	var recallTimeTaken;
	var chosenAnswers = [];
	var cardList;
	var boneyardArray = [];
	var displayed;

	var cardSet;

	var imageArray = new Array();
	var actualImageArray = new Array();
	var actualImages = new Array();
	var answerArray = [];
	var usedImageNums = [];
	var blnImageSkip;
	var imagesLoaded;

	var fontNow = '';
	var fontSizeNow = 0;
	var fontReenieBeanie = ['Reenie Beanie', 38, 42];
	var fontShadowsIntoLight = ['Shadows Into Light', 24, 26];
	//var fontRockSalt = ['Rock Salt', 19, 21];

	var datesLanguage;

	//Words
	//XML variables
	var fobWordsDoc;

	var wordList;
	//word ratios
	const percOfCNs = 80;
	const percOfANs = 10;
	const percOfVs = 10;

	var wordsLanguage;
	var wordsLanguagesPreloaded = false;

	//Dates
	var fobDatesDoc;
	var dateList;
	var shuffledDateList;
	const datesPerPage = 20;
	var datesLanguagesPreloaded = false;

	//Names
	var fobNamesDoc;

	//const longMales = 3;
	//const longFemales = 3;
	//const longSurnames = 6;
	const longNameChars = 8;
	var femaleImageArray = new Array();
	var maleImageArray = new Array();
	var genders;
	var curPos = 0;
	var curPage = 0;

	var namesCharset;
	var namesCharsetsPreloaded = false;
	var names = [];
	var newNames = [];
	var currentSurnames;
	var accentMap = { 
		'á': 'a', 'à': 'a', 'ä': 'a', 'ā': 'a','â':'a','ã':'a','å':'a','æ':'ae', 
		'ç': 'c', 'č':'c','ć':'c',
		'é': 'e', 'è': 'e', 'ë': 'e', 'ê':'e','ě':'e',
		'í': 'i', 'ı': 'i','ï':'i','î':'i',
		'ł':'l',
		'ñ':'n','ń':'n','ň':'n',
		'ó': 'o', 'ō': 'o', 'ö': 'o', 'ô':'o','õ':'o','ø':'o','œ':'oe','ő':'o',
		'ŕ':'r',
		'ş': 's','š':'s', 'ś':'s',
		'ú': 'u','ù':'u','ü':'u','ū':'u','û':'u', 'ű':'u',
		'ý':'y',
		'ž': 'z','ż':'z','ź':'z' };
	var nameList = [];
	var facesAmount;

	var shuffledNameList = [];

	var ended;

	function changeDisciplines() {
		//remove all options from the box
		$("#selDiscipline option").remove();

		//get format
		var thisFormat = document.getElementById("selFormat").options[document.getElementById("selFormat").selectedIndex].value;
		var thisArray;
		switch (thisFormat) {
			case "N":
				thisArray = nationalEvents;

				break;

			case "I":

				thisArray = internationalEvents;
				break;

			default:

				thisArray = worldEvents;
		}

		//add all events in that format to the box
		for (j = 0; j < events.length; j++) {
			if (thisArray.indexOf(events[j].ref) > -1) {

				$("#selDiscipline").append("<option value='" + events[j].ref + "'>" + events[j].label + "</option>");

			}
		}

	}

	function preloadData() {

		//If competition mode, this is called when the user clicks Preload data button
		//If in training mode, this is called when the user clicks Start

		//For dates or words, get the chosen language		
		if (currentDiscipline.indexOf("D") > -1 && competitionMode) {
			datesLanguage = document.getElementById("selDatesLanguage").options[document.getElementById("selDatesLanguage").selectedIndex].value;
		}
		if (currentDiscipline.indexOf("W") > -1 && competitionMode) {
			wordsLanguage = document.getElementById("selWordsLanguage").options[document.getElementById("selWordsLanguage").selectedIndex].value;
		}

		//For names, get the chosen charset
		if (currentDiscipline.indexOf("F") > -1 && competitionMode) {
			namesCharset = document.getElementById("selNamesCharset").options[document.getElementById("selNamesCharset").selectedIndex].value;
		}

		//preload other stuff
		switch (currentDiscipline) {

			case "10C":
			case "30C":
			case "60C":
			case "SC":
				//For all cards disciplines, preload the card images
				preloadCardImages();
				break;
			case "D":
				if (competitionMode) {
					readDatesFile(datesLanguage);
				} else {
					startMemoCountdown();
				}
				break;
			case "5F":
			case "15F":
				if (competitionMode) {
					readNamesFile(namesCharset);
				} else {
					startMemoCountdown();
				}
				break;
			case "5W":
			case "15W":
				if (competitionMode) {
					readWordsFile(wordsLanguage);
				} else {
					startMemoCountdown();
				}
				break;
			case "5I":
				preloadImages(false);
				break;
			default:
				startMemoCountdown();
		}


	}

	function goToSelection() {
		preloaded = false;

		//reset any timers that are running
		if (myTimer) clearTimeout(myTimer);

		//check if user's browser has localStorage facilities
		if (typeof (Storage) == "undefined") {
			// No localStorage support
			alert("Sorry, your browser does not meet the technical specifications. It is recommended that you use the latest version of Chrome or Firefox.")
		}

		//PRELOAD IMAGES SECTION

		//Change the text of the Go button to a loading text
		document.getElementById("btnGo").innerText = "Loading images... Please wait";

		//Reset the number of images loaded - we need to load all the backgrounds before we go to the settings page
		mainImagesLoaded = 0;
		//**PAPER**
		var mainImageURLs = ['hugeWoodMatchPlanks2.png', 'IAMarble2.jpg', 'Green.jpg', 'hugeWoodPaperAMatch.jpg'];

		//Do the preloading if we 
		if (mainImagesLoaded == 0) {
			mainImageURLs.forEach(function (el) {
				var bg = new Image();
				bg.src = el;
				bg.onload = function () {
					console.log(++mainImagesLoaded);
					if (mainImagesLoaded == mainImageURLs.length) {

						document.getElementById("btnGo").removeAttribute("disabled");
						if (localStorage.getItem("phase")) document.getElementById("btnResume").style.visibility = "visible";
						document.getElementById("btnGo").innerText = "Go";

					}
				};
			})
		}

		preloading = false;

		if (!datesLanguagesPreloaded && competitionMode) {
			preloadDatesLanguages();
		}
		if (!namesCharsetsPreloaded && competitionMode) {
			preloadNamesCharsets();
		}

		if (!wordsLanguagesPreloaded && competitionMode) {
			preloadWordsLanguages();
		}
		document.body.className = "selectionSkin";
		document.getElementById("selectionRow").style = "display:block";
		document.getElementById("logoRow").style = "display:block";

		document.getElementById("topMargin").style = "display:none";
		document.getElementById("settingsRow0").style = "display:none";
		document.getElementById("countdownRow").style = "display:none";
		document.getElementById("countdownText").innerHTML = "";
		document.getElementById("countdownTime").innerHTML = "";
		document.getElementById("memoRow").style = "display:none";
		document.getElementById("memoBox").classList.remove(skin + "memoHeightDates");
		document.getElementById("memoBox").classList.add(skin + "memoHeight");
		document.getElementById("recallBox").classList.remove(skin + "memoHeightDates");
		document.getElementById("recallBox").classList.add(skin + "memoHeight");
		document.getElementById("scoreBox").classList.remove(skin + "memoHeightDates");
		document.getElementById("scoreBox").classList.add(skin + "memoHeight");
		document.getElementById("recallRow").style = "display:none";
		//document.getElementById("spanShift").style="display:block";
		document.getElementById("cardsMemoTime").innerText = "";
		document.getElementById("cardsMemoTimeScore").innerText = "";
		document.getElementById("scoreRow").style = "display:none";
		document.getElementById("btnBackToSelection").style = "display:none";
		document.getElementById("memoContentDiv").innerHTML = "";
		//document.getElementById("recallContentDiv").innerHTML = "";
		//document.getElementById("scoreContentDiv").innerHTML = "";


		changeDisciplines();
		clearInterval(cint);
		ended = true;
		currentDiscipline = "";
		miniGroupings = [];
		chosenAnswers = [];

		//changeSkin();

		//reset so no card table background appears
		if (skin.indexOf("analogue") > -1) {
			$("#memoBox").removeClass("cardTable");
			$("#recallBox").removeClass("cardTable");
			$("#scoreBox").removeClass("cardTable");
			//$("#spanShift").removeClass("cardTable");
			//$("#spanShift").addClass("textNonCards");
			$("#spanSpace").removeClass("cardTable");
			$("#spanSpace").addClass("textNonCards");
			$("#spanOuterScore").removeClass("cardTable");
			$("#spanScore").removeClass("cardTable");
			$("#spanCorrect").removeClass("cardTable");
			$(".disciplineTitleMemo").removeClass("textCardTable");
			$(".disciplineTitleMemo").addClass("textNonCards");
			$(".digital1RecallTimeOuter").removeClass("textCardTable");
			$(".digital1RecallTimeOuter").addClass("textNonCards");


			$(".bottom-right-timer").removeClass("textCardTable");
		}

	}

	function getSkin() {
		// skin = document.getElementById("selSkin").options[document.getElementById("selSkin").selectedIndex].value;
		var skinOptions = document.getElementsByName('selSkin');
		if (skinOptions[0].checked) {
			return skinOptions[0].value;
		} else {
			return skinOptions[1].value;
		}

	}

	function goToSettings() {
		resuming = false;
		document.getElementById("btnStartMemoCountdown").innerText = "Start";
        document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
		//Reset mark array
		markArray = [];

		//Get and change skin
		skin = getSkin();
		changeSkin();

		//remove logo row if skin is analogue
	
		if (skin.indexOf("analogue") > -1) {
			document.getElementById("logoRow").style = "display:none";
			document.getElementById("topMargin").style = "display:block";
			document.getElementById("btnBackToSelection2").style = "display:block";
		}

		// clear content from test page if exists
		document.getElementById("memoContentDiv").innerHTML = "";

		//Get discipline
		currentDiscipline = document.getElementById("selDiscipline").options[document.getElementById("selDiscipline").selectedIndex].value;
		localStorage.setItem("discipline", currentDiscipline);

		//Display correct elements
		document.getElementById("selectionRow").style = "display:none";
		document.getElementById("settingsRow0").style = "display:block";
		document.getElementById("countdownRow").style = "display:none";
		document.getElementById("countdownText").innerHTML = "";
		document.getElementById("countdownTime").innerHTML = "";
		document.getElementById("memoRow").style = "display:none";
		document.getElementById("recallRow").style = "display:none";
		document.getElementById("scoreRow").style = "display:none";
		document.getElementById("btnBackToSelection").style = "display:block";

		var titleElements = document.getElementsByClassName("disciplineTitle");
		var title = lookupProperty(currentDiscipline, "label");
		for (var i = 0; i < titleElements.length; i++) {
			titleElements[i].innerHTML = title;
		}

		titleElements = document.getElementsByClassName("disciplineTitleMemo");
		title = lookupProperty(currentDiscipline, "label");
		for (var i = 0; i < titleElements.length; i++) {
			titleElements[i].innerHTML = title;
		}

		//Show Grouping dropdown if necessary
		if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1) {
			document.getElementById("divGrouping").style = "display:block";
		//	if (currentDiscipline.indexOf("C") > -1) {
	//			document.getElementById('selGrouping').selectedIndex = 1;
	//		}
		}
		else {
			document.getElementById("divGrouping").style = "display:none";
		}

		//Show complex grouping dropdown if necessary; get and apply separations
		if (currentDiscipline.indexOf("N") > -1) {
			document.getElementById("divComplexGrouping").style = "display:block";

			if (localStorage.getItem("separations") != "" && localStorage.getItem("separations") != null) {			
				arr = JSON.parse(localStorage.getItem("separations"));
			} else {
				arr = [];
			}
			
			if (arr.length && arr[0] != null) {
			document.getElementById("inpSeparation").value = arr.reduce((acc, val, idx) => {
				if (idx === 0) {
				acc = val.toString() + '-';
				} 
				if (idx <= arr.length - 2 ) {
				return acc + (Math.abs(val - arr[idx + 1])).toString() + '-';    
				} else {
				return acc.slice(0, acc.length-1);
				}
			}, '');
			} else {
				document.getElementById("inpSeparation").value = "";
			}
			if (document.getElementById("inpSeparation").value == "0") document.getElementById("inpSeparation").value = "";
			applySeparation();
		}
		else {
			document.getElementById("divComplexGrouping").style = "display:none";
		}

		//Show Binary Grouping dropdown if necessary; get and apply separations
		if (currentDiscipline.indexOf("B") > -1) {
			document.getElementById("divBinGrouping").style = "display:block";
		
			if (localStorage.getItem("separationsBin") != "" && localStorage.getItem("separationsBin") != null) {			
				arr = JSON.parse(localStorage.getItem("separationsBin"));
			} else {
				arr = [];
			}

			if (arr.length && arr[0] != null) {
			document.getElementById("inpSeparationBin").value = arr.reduce((acc, val, idx) => {
				if (idx === 0) {
				acc = val.toString() + '-';
				} 
				if (idx <= arr.length - 2 ) {
				return acc + (Math.abs(val - arr[idx + 1])).toString() + '-';    
				} else {
				return acc.slice(0, acc.length-1);
				}
			}, '');
			} else {
				document.getElementById("inpSeparationBin").value = "";
			}
			if (document.getElementById("inpSeparationBin").value == "0") document.getElementById("inpSeparationBin").value = "";
			/*
			.reduce(function(acc,val,idx,array) {
				if (val) {
					sepStr = (idx == array.length-1) ? "" : "-";		
					arr = acc.split("-").filter(el=>el!="");	
					console.log(acc);
						if (arr.length) {return acc + (val-arr.reduce((acc,val) => acc+val)) + sepStr;}
					
				} else {return "";}
			},"");
			/*
			
			reduce(function(acc,val,idx,array) {
				if (val) {
					sepStr = (idx == array.length-1) ? "" : "-";					
					
						return acc + (val-acc.split("-").reduce((acc,val) => acc+val)) + sepStr;
					
				} else {return "";}
			},"");*/

			applySeparationBin();
		}
		else {
			document.getElementById("divBinGrouping").style = "display:none";
		}

		//Show Colour dropdown if necessary
		if (currentDiscipline.indexOf("C") > -1) {
			document.getElementById("divHighlightColour").style = "display:none";
		}
		else {
			document.getElementById("divHighlightColour").style = "display:block";
		}

		//Show Languages dropdown if necessary
		if (currentDiscipline.indexOf("D") > -1 && competitionMode) {
			document.getElementById("divDatesLanguages").style = "display:block";
		}
		else {
			document.getElementById("divDatesLanguages").style = "display:none";
		}


		if (currentDiscipline.indexOf("W") > -1 && competitionMode) {
			document.getElementById("divWordsLanguages").style = "display:block";
		}
		else {
			document.getElementById("divWordsLanguages").style = "display:none";
		}


		if (currentDiscipline.indexOf("F") > -1 && competitionMode) {
			document.getElementById("divNamesCharsets").style = "display:block";
		}
		else {
			document.getElementById("divNamesCharsets").style = "display:none";
		}

		//Show preview if necessary
		if (currentDiscipline.indexOf("I") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("F") > -1 || currentDiscipline.indexOf("D") > -1) {
			document.getElementById("divPreview").style = "display:none";
			if (currentDiscipline.indexOf("W") > -1) {
				document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
			} else {
				document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
			}
		} else {
			document.getElementById("divPreview").style = "display:block";
			if (currentDiscipline.indexOf("C") > -1) {
				if (currentDiscipline.indexOf("SC") > -1) {
					//document.getElementById("divInstructions").innerHTML = "<h4>During memorisation:</h4>Spacebar...........return to start<br /><br />"
					document.getElementById("divInstructions").innerHTML = "<div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&larr; &rarr;</td><td>navigate</td></tr><tr><td>spacebar / &uarr;</td><td>return to start of deck</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>Backspace</td><td>delete card in previous cell</td></tr></table></div><div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>Del</td><td>delete card in current cell</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr><tr><td>Enter</td><td>end memorisation</td></tr></table><br />"
				} else {
					document.getElementById("divInstructions").innerHTML = "<div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&larr; &rarr;</td><td>navigate</td></tr><tr><td>spacebar</td><td>return to start of first deck</td></tr><tr><td>&uarr;</td><td>return to start of deck</td></tr><tr><td>, / .</td><td>previous/next deck</td></tr></table></div><div class='flexChild'><table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>Backspace</td><td>delete card in previous cell</td></tr><tr><td>Del</td><td>delete card in current cell</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"
				}
			} else {
				//document.getElementById("divInstructions").innerHTML = "<h3>During memorisation:</h3>Spacebar...........return to start<br />Comma/period..........previous/next page<br /><br />"
				document.getElementById("divInstructions").innerHTML = "<table class='instructionsTable'><tr><th>Key</th><th>Action</th></tr><tr><td>&uarr; &darr; &larr; &rarr;</td><td>navigate</td></tr><tr><td>shift-tab / tab</td><td>previous/next cell</td></tr><tr><td>spacebar</td><td>return to start</td></tr><tr><td>, / .</td><td>previous/next page</td></tr><tr><td>+ / -</td><td>shift recall</td></tr><tr><td>double-click</td><td>mark (recall only)</td></tr></table><br />"

			}
		}
		//resetSeparations();
		
		updatePreview();

		//changeSkin();
		changeSelHColour();


		//Show highlighter colour if necessary ***

		//Show Decks input if necessary
		if (currentDiscipline.indexOf("C") > -1) {
			if (currentDiscipline != "SC") {
				document.getElementById("divDecks").style = "display:inline-block";
				document.getElementById("inpDecks").value = lookupProperty(currentDiscipline, "amount");
			} else {

				document.getElementById("divDecks").style = "display:none";

			}

			document.getElementById("divCardSet").style = "display:flex";


		}
		else {
			document.getElementById("divDecks").style = "display:none";
			document.getElementById("divCardSet").style = "display:none";			
		}



		//Show Skip box if necessary
		if (currentDiscipline == "5I") {
			document.getElementById("divSkip").style = "display:block";
		} else {
			document.getElementById("divSkip").style = "display:none";
		}

		//Show Preload button if necessary
		if (competitionMode && (currentDiscipline.indexOf("I") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1 || currentDiscipline.indexOf("D") > -1 || currentDiscipline.indexOf("F") > -1)) {
			document.getElementById("btnPreload").style = "display:inline";
			if (preloaded) {
				document.getElementById('btnStartMemoCountdown').removeAttribute('disabled');
           		document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
				//restore saved data
				if (currentDiscipline == "5I") {
					actualImageArray = JSON.parse(localStorage.getItem("preloadedData")).map(el => { return { src: "IAM Images/" + el } });
				} else if (currentDiscipline.indexOf("W") > -1) {
					wordList = JSON.parse(localStorage.getItem("preloadedData"));
				} else if (currentDiscipline.indexOf("D") > -1) {
					dateList = JSON.parse(localStorage.getItem("preloadedData"));
				} else {
					nameList = JSON.parse(localStorage.getItem("preloadedData"));
				}
			} else {

				document.getElementById("btnPreload").removeAttribute("disabled");
				document.getElementById("btnStartMemoCountdown").setAttribute("disabled", "");
            	document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
			}

		} else {
			document.getElementById("btnPreload").style = "display:none";
			document.getElementById('btnStartMemoCountdown').removeAttribute('disabled');
            document.getElementById("btnStartMemoCountdown").classList.add("glowButton");

		}
	}

	function startMemoCountdown(test = false) {
		document.getElementById("logoRow").style = "display:none";
		document.getElementById("topMargin").style = "display:block";
		document.getElementById("btnBackToSelection2").style = "display:none";

		//delete previous set of recall data, delete recall and score content div
		localStorage.setItem("chosen", "[]");
		document.getElementById("scoreContentDiv").innerHTML = "";
		document.getElementById("recallContentDiv").innerHTML = "";

		//get amount
		if (currentDiscipline == "10C" || currentDiscipline == "60C" || currentDiscipline == "30C") {
			amount = resuming ? localStorage.getItem("amount") : document.getElementById("inpDecks").value;
			if (isNaN(Number(amount))) amount = 1;
			localStorage.setItem("amount", amount);
		}
		else {
			amount = resuming ? localStorage.getItem("amount") : lookupProperty(currentDiscipline, "amount");
			localStorage.setItem("amount", amount);
		}

		//Get grouping
		if (currentDiscipline.indexOf("N") > -1 || currentDiscipline.indexOf("W") > -1 || currentDiscipline.indexOf("C") > -1) {
			grouping = resuming ? Number(localStorage.getItem("grouping")) : Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
		}

		//Get grouping
		if (currentDiscipline.indexOf("B") > -1) {
			groupingH = resuming ? Number(localStorage.getItem("groupingH")) : Number(document.getElementById("selBinGroupingH").options[document.getElementById("selBinGroupingH").selectedIndex].value);
			groupingW = resuming ? Number(localStorage.getItem("groupingW")) : Number(document.getElementById("selBinGroupingW").options[document.getElementById("selBinGroupingW").selectedIndex].value);
		}

		//Get highlighter colour
		if (currentDiscipline.indexOf("B") > -1 || currentDiscipline.indexOf("N") > -1) {
			hiColour = resuming ? localStorage.getItem("hiColour") : document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;

			//change css variable
			document.body.style.setProperty("--highlightColor", this[hiColour]);
		}



		//Display countdown section only
		document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to countdown
		document.getElementById("settingsRow0").style.display = 'none';
		document.getElementById("countdownTable").style.display = 'inline';
		document.getElementById("countdownRecallTable").style.display = 'none';
		document.getElementById("countdownText").innerHTML = "";
		document.getElementById("countdownTime").innerHTML = "";
		document.getElementById("countdownRow").style.display = "block";
		// document.getElementsByClassName("countdownDisciplineTitle").innerHTML = lookupProperty(currentDiscipline,"label");

		var titleElements = document.getElementsByClassName("countdownDisciplineTitle");
		var title = lookupProperty(currentDiscipline, "label");
		for (var i = 0; i < titleElements.length; i++) {
			titleElements[i].innerHTML = title;
		}

		//Get memo and recall times
		memoTime = lookupProperty(currentDiscipline, "memoTime");



		//Get the data to be memorised
		//NUMBERS
		if (currentDiscipline.indexOf("N") > -1) {
			numberList = [];
			if (resuming) {
				//restore number list
				numberList = JSON.parse(localStorage.getItem("correctAnswers"));
			} else {
				//new random numbers
				for (i = 0; i < amount; i++) {
					numberList.push(Math.floor(Math.random() * 10));
				}
				//save number list in storage
				if (!test) 	localStorage.setItem("correctAnswers", JSON.stringify(numberList));
			}
		}

		//BINARY
		if (currentDiscipline.indexOf("B") > -1) {
			binaryList = [];
			if (resuming) {
				//restore binary digit list
				binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
			} else {
				//new random binary digits
				for (i = 0; i < amount; i++) {
					binaryList.push(Math.floor(Math.random() * 2));
				}
				//save binary list in storage
				if (!test) localStorage.setItem("correctAnswers", JSON.stringify(binaryList));

			}
		}

		//CARDS
		if (currentDiscipline.indexOf("C") > -1) {
			cardList = [];
			if (resuming) {
				//restore card list
				cardList = JSON.parse(localStorage.getItem("correctAnswers"));
			} else {
				//for each deck
				for (var d = 0; d < amount; d++) {
					//generate a standard deck
					var deck = getStandardDeck();

					shuffle(deck);

					cardList.push(deck);

					//save card list
					if (!test) localStorage.setItem("correctAnswers", JSON.stringify(cardList));
				}
			}
		}

		if (currentDiscipline.indexOf("I") > -1) {
			//preloadImages();

		}


		if (currentDiscipline.indexOf("W") > -1) {

			if (!competitionMode || test) {
				
				openWordsFile();
				
				generateWordList();
				//save word list in storage
				if (!test) localStorage.setItem("correctAnswers", JSON.stringify(wordList));
			}
		}
		

		if (currentDiscipline.indexOf("F") > -1) {

			if (!competitionMode || test) {

				openNamesFile();

				generateNamesandFaces();
			}
		}

		if (currentDiscipline.indexOf("D") > -1) {

			if (!competitionMode || test) {

				openDatesFile();

				generateDatesList();
				//save dates list in storage				
				localStorage.setItem("correctAnswers", JSON.stringify(dateList));
			}
		}

		//Display countdown clock
		countSeconds = test ? -2 : countdownSeconds;		
		cint = setInterval(showSeconds, 1000);
	}

	function resetMiniGroupings() {
		miniGroupings = [];
		document.getElementById("inpMiniGroupings").value = "";
		localStorage.setItem("miniGroupings", "");
	}


	function resetSeparations() {
		separations = [];
		if (currentDiscipline.indexOf("N") > -1) {
			document.getElementById("inpSeparation").value = "";
			localStorage.setItem("separations", []);

		} else {
			document.getElementById("inpSeparationBin").value = "";
			localStorage.setItem("separationsBin", "[]");
		}
	}

	function updatePreview() {

		var previewString = "";
		if (currentDiscipline.indexOf("N") > -1) {
			previewString = "<table align='center' class='centred'><tr>";

			//get locus size
			if (miniGroupings.length > 0) {
				locusSize = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
			} else {
				grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
				localStorage.setItem("grouping", grouping);
				locusSize = grouping * imgsPerLocus;
			}


			//add the locus before the selected one	
			for (i = 1; i <= locusSize; i++) {
				if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
					previewString += "<td id='preview" + i + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
				} else {
					previewString += "<td id='preview" + i + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
				}
			}

			//add selected one
			if (miniGroupings.length > 0) {
				//Show the selected group, with minigroupings
				var counter = 1;
				miniGroupings.forEach((el, i) => {
					for (j = 1; j <= el; j++) {
						//if first minigrouping then counts as normal selected
						if (i == 0) {

							if (separations.length > 0 && (separations.indexOf(counter) > -1 || counter == locusSize)) {
								previewString += "<td id='previewSel" + counter + "' class='separation " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
							} else {
								previewString += "<td id='previewSel" + counter + "' class='" + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
							}
						} else {
							//else use numbersInLocus class
							if (separations.length > 0 && (separations.indexOf(counter) > -1 || counter == locusSize)) {
								previewString += "<td id='preview" + counter + "' class='separation " + skin + "numbersInLocus " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
							} else {
								previewString += "<td id='preview" + counter + "' class='" + skin + "numbersInLocus " + skin + "numbersMemo'>" + (counter++) % 10 + "</td>";
							}
						}
					}

				});
			} else {
				//Show the selected group
				for (i = 1; i <= locusSize; i++) {
					if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
						previewString += "<td id='previewSel" + i + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
					} else {
						previewString += "<td id='previewSel" + i + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
					}
				}
			}

			for (i = 1; i <= locusSize; i++) {
				if (separations.length > 0 && (separations.indexOf(i) > -1 || i == locusSize)) {
					previewString += "<td id='preview" + (i + locusSize) + "' class='separation " + skin + "numbersMemo'>" + i % 10 + "</td>";
				} else {
					previewString += "<td id='preview" + (i + locusSize) + "' class='" + skin + "numbersMemo'>" + i % 10 + "</td>";
				}

			}
			previewString += "</tr></table>";

			document.getElementById("preview").innerHTML = previewString;

			//change preview skin

			for (i = 1; i <= locusSize * 2; i++) {
				document.getElementById("preview" + i).classList.remove(skin + "numbersSelected");
			}
			if (miniGroupings.length > 0) {
				for (i = 1; i <= miniGroupings[0]; i++) {
					document.getElementById("previewSel" + i).classList.add(skin + "numbersSelected");
				}
				for (i = locusSize + miniGroupings[0]; i <= locusSize; i++) {
					document.getElementById("preview" + i).classList.remove(skin + "numbersInLocus");
				}
			} else {
				//select whole locus
				for (i = 1; i <= locusSize; i++) {
					document.getElementById("previewSel" + i).classList.add(skin + "numbersSelected");
				}
			}
			//change preview highlight
			//var selNums = document.getElementsByClassName(skin + "numbersSelected");
			//for (let el of selNums) {
			//  el.style.background = this[hiColour];
			// }
		}

		if (currentDiscipline.indexOf("B") > -1) {
			previewString = "<table align='center' class='centred'>";

			if (miniGroupings.length > 0) {
				var groupingH = 1;
				var groupingW = miniGroupings.reduce((acc, val) => Number(acc) + Number(val));
			} else {

				var groupingH = Number(document.getElementById("selBinGroupingH").options[document.getElementById("selBinGroupingH").selectedIndex].value);
				var groupingW = Number(document.getElementById("selBinGroupingW").options[document.getElementById("selBinGroupingW").selectedIndex].value);
			}

			localStorage.setItem("groupingH", groupingH);
			localStorage.setItem("groupingW", groupingW);

			for (h = 1; h <= groupingH; h++) {
				previewString += "<tr>";
				for (w = 1; w <= groupingW; w++) {
					if (separations.length > 0 && (separations.indexOf(w) > -1 || w == groupingW)) {
						previewString += "<td id='preview" + ((h - 1) * groupingW + w) + "' style='border-right:solid 1px black'>0</td>";
					} else {
						previewString += "<td id='preview" + ((h - 1) * groupingW + w) + "'>0</td>";
					}
				}


				if (miniGroupings.length > 0) {
					//Show the selected group, with minigroupings
					var counter = 1;
					miniGroupings.forEach((el, i) => {
						for (j = 1; j <= el; j++) {
							//if first minigrouping then counts as normal selected
							if (i == 0) {
								previewString += "<td id='previewSel" + (counter++) + "'>" + 1 + "</td>";
							} else {
								//else use numbersInLocus class
								previewString += "<td class='" + skin + "numbersInLocus " + skin + "numbersMemo'>" + 1 + "</td>";
							}
						}

					});
				} else {
					//Show the selected group
					for (w = 1; w <= groupingW; w++) {
						if (separations.length > 0 && (separations.indexOf(w) > -1 || w == groupingW)) {
							previewString += "<td id='previewSel" + ((h - 1) * groupingW + w) + "' style='border-right:solid 1px black'>1</td>";
						} else {
							previewString += "<td id='previewSel" + ((h - 1) * groupingW + w) + "'>1</td>";
						}
					}
				}

				for (w = 1; w <= groupingW; w++) {
					if (separations.length > 0 && (separations.indexOf(w) > -1 || w == groupingW)) {
						previewString += "<td id='preview" + ((h - 1) * groupingW + w + groupingW * groupingH) + "' style='border-right:solid 1px black'>0</td>";
					} else {
						previewString += "<td id='preview" + ((h - 1) * groupingW + w + groupingW * groupingH) + "'>0</td>";
					}
				}
				previewString += "</tr>";
			}
			previewString += "</table>";

			document.getElementById("preview").innerHTML = previewString;

			//change preview skin

			for (i = 1; i <= groupingH * groupingW * 2; i++) {

				document.getElementById("preview" + i).className = skin + "binaryMemo";

			}
			for (i = 1; i <= groupingH * groupingW; i++) {
				document.getElementById("previewSel" + i).className = skin + "binaryMemo " + skin + "binarySelected";
			}

			//change preview highlight
			var selNums = document.getElementsByClassName(skin + "binarySelected");
			//for (let el of selNums) {
			//    el.style.background = this[hiColour];
			//}
		}

		if (currentDiscipline.indexOf("C") > -1) {
			grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
			localStorage.setItem("grouping", grouping);
			var classString = skin + "cardOneMemo";
			var classString2 = skin + "cardOtherMemo";

			/*
				//  var offset = document.getElementById("selGrouping").offsetLeft;
				var offset=400;
			
				//  previewString += "<div class='row centred'><div class='col-md-12' style='height:220px;position:relative;left:-" + (114.37+(grouping-1)*22)/2 +  "'><img src='Card images/c01.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig' style='left:" + offset + "px'>";
				//  previewString += "<div class='row centred'><div class='col-md-12' style='height:220px;position:relative;'><img src='Card images/c01.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig' style='left:" + offset + "px'>";
				previewString += "<div class='row centred text-center'><div class='col-md-12' style='height:220px;'><img id='cardOne' src='Card images/c01.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig' style='left:" + offset + "px'>";
			
			
					for (var i = 1; i < grouping; i++) {
						 offset += cardOffsetBig;
						previewString += "<img src='Card images/c0" + (i+1) + ".png' class='" + skin + "cardOtherMemo " + skin + "cardImgBig' style='left:" + offset + "px'>";
			
					}
					previewString += "</div></div>";
						document.getElementById("preview").innerHTML = previewString;
				}
				*/

			/*
			//This code makes the cards centered but they move apart if you zoom the screen
			//because the offset is based on the left position of the first card
			previewString += "<div id='cardsPreview' style='height:220px'><img id='cardOne' src='Card images/c01.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig'></div>";
			
			
					document.getElementById("preview").innerHTML = previewString;
					var offset = document.getElementById("cardOne").offsetLeft;
			
					previewString = "<img id='cardOne' src='Card images/c01.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig'  style='left:" + offset + "px'>";
					for (var i = 1; i < grouping; i++) {
						 offset += cardOffsetBig;
						previewString += "<img src='Card images/c0" + (i+1) + ".png' class='" + skin + "cardOtherMemo " + skin + "cardImgBig' style='left:" + offset + "px'>";
			
					}
			document.getElementById("cardsPreview").innerHTML = previewString;
			 }
			*/

			cardSet = Number(document.getElementById("selCardSet").options[document.getElementById("selCardSet").selectedIndex].value);
			localStorage.setItem("cardSet", cardSet);
			previewString = "<div style='height:220px;position:relative;left:-" + (114.37 + (grouping - 1) * 22) / 2 + "'><img id='cardOne' src='Card images " + cardSet + "/c13.png' class='" + skin + "cardOneMemo " + skin + "cardImgBig'  style='left:50%;margin:0 0 0 " + 0 + "px'>";
			for (var i = 1; i < grouping; i++) {
				offset = i * cardOffsetBig;
				previewString += "<img src='Card images " + cardSet + "/c" + (i > 3 ? "0" : "") + (13 - i) + ".png' class='" + skin + "cardOtherMemo " + skin + "cardImgBig' style='left:50%;margin:0 0 0 " + offset + "px'>";

			}
			previewString += "</div>";
			document.getElementById("preview").innerHTML = previewString;
		}


		if (currentDiscipline.indexOf("W") > -1) {
			grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
			localStorage.setItem("grouping", grouping);
		}
	}

	function getStandardDeck() {
		var deck = new Array();
		//get a deck of 52 cards (non-faces)
		for (i = 0; i < nonfaceList.length; i++) {
			for (j = 0; j < suitInitialList.length; j++) {
				deck.push({
					cv: nonfaceList[i],
					cs: suitInitialList[j]
				});
			}

		}


		//get the face cards into the deck
		for (i = 0; i < faceList.length; i++) {
			for (j = 0; j < suitInitialList.length; j++) {
				deck.push({
					cv: faceList[i],
					cs: suitInitialList[j]
				});
			}
		}


		return deck;

	}

	function sortBoneyard(boneyard) {
		const suitSortList = new Array("s", "h", "c", "d");
		const valueSortList = nonfaceList.concat(faceList);

		boneyard.sort(function (a, b) {
			if (suitSortList.indexOf(a.cs) < suitSortList.indexOf(b.cs)) {
				//a has a suit that appears earlier
				return -1;
			} else if (suitSortList.indexOf(a.cs) == suitSortList.indexOf(b.cs)) {
				//suits are same, check value
				if (valueSortList.indexOf(a.cv) < valueSortList.indexOf(b.cv)) {
					return -1;
				} else {
					return 1;
				}
			} else {
				return 1;
			}

		});
		return boneyard;
	}

	function shuffle(array) {
		var currentIndex = array.length, temporaryValue, randomIndex;

		// While there remain elements to shuffle...
		while (0 !== currentIndex) {

			// Pick a remaining element...
			randomIndex = Math.floor(Math.random() * currentIndex);
			currentIndex -= 1;

			// And swap it with the current element.
			temporaryValue = array[currentIndex];
			array[currentIndex] = array[randomIndex];
			array[randomIndex] = temporaryValue;
		}

		return array;
	}

	function showSeconds() {
		localStorage.setItem("phase", "memo");

		document.getElementById("countdownText").innerHTML = "Memorisation starts in: ";
		document.getElementById("countdownTime").innerHTML = countSeconds;
		countSeconds--;
		if (countSeconds <= -1) {
			clearInterval(cint);			
			startMemo(countSeconds == -3);
		}
	}

	function testPage() {

		//if we are doing images or cards, need to load images
		if (currentDiscipline.indexOf("I") > -1) {
			preloadImages(true);
		}
		if (currentDiscipline.indexOf("C") > -1) {
			preloadCardImages();
		}
		startMemoCountdown(true);
	}

	/*
	function preloadAllImages() {
		 var ext, imageURL;
		 var allImages = [];
		 ext = "png";
	for (i = 1; i < numberOfPngs;i++) {
		
		imageURL = "Image (" + i + ")." + ext;
	 allImages.push(imageURL);
		
	}
	ext = "jpg";
	for (i = 1; i < numberOfJpgs;i++) {
		imageURL = "Image (" + i + ")." + ext;
	allImages.push(imageURL);
	
	}
	
	
	//preload images
	imagesLoaded =0 ;
	var allImageLoads = [];
	for (let im = 0; im < allImages.length; im++) {
		allImageLoads[im] = new Image();
		allImageLoads[im].src = 'IAM Images/' + allImages[im];
		allImageLoads[im].onload = function() {imagesLoaded++};
	}
	
	
	}
	
	*/

	/*
	function preloadCompetitionData() {
		preloadCardImages();
		preloadImages();
		//get format
	 var thisFormat = document.getElementById("selFormat").options[document.getElementById("selFormat").selectedIndex].value;
	 //"N"
		preloadNameImages();
	}*/

	function preloadImages(test = false) {		
		document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
        document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
		preloading = true;
		amount = lookupProperty("5I", "amount");
		imageArray = [];
		actualImageArray = [];
		//get the images
		var imageURL;
		var num;
		var ext;
		if (!test && competitionMode) {

			var rawFile = new XMLHttpRequest();
			rawFile.open("GET", "Data/Images_lkjfsldkjf/images.txt", false);
			rawFile.onreadystatechange = function () {
				if (rawFile.readyState === 4) {
					if (rawFile.status === 200 || rawFile.status == 0) {
						var imagesText = rawFile.responseText;
						imagesText.trim();
						var txtArray = imagesText.split('\n');

						for (var i = 0; i < amount; i++) {
							if (txtArray[i] !== "") {
								imageArray.push(txtArray[i]);
							}
						}

						localStorage.setItem("imageArray", JSON.stringify(imageArray));

						//preload images
						var imagesLoaded = 0;
						for (let im = 0; im < amount; im++) {
							actualImageArray[im] = new Image();
							actualImageArray[im].src = 'IAM Images/' + imageArray[im];
							actualImageArray[im].onload = function () {
								console.log(++imagesLoaded);
								if (imagesLoaded == amount) {
									document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
									document.getElementById("btnStartMemoCountdown").innerText = "Start";
                                    document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
									localStorage.setItem("preloadedData",JSON.stringify(imageArray));
									preloaded = true;
								}
							};
						}
					}
				}
			}
			rawFile.send(null);

			//**** ? 2018-10-12
			/*
					for (i = 0; i < amount; i++) {	
			
					imageArray.push("Image (" + i + ").png");
						
			
					}	*/

		} else {
			for (i = 0; i < amount; i++) {
				//uncoment these lines if duplicates are allowed on different rows
				//		if (i % 5 == 0) {
				//			usedImageNums = [];
				//		}	
				num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
				while (usedImageNums.indexOf(num) > -1) {
					num = Math.floor(Math.random() * (numberOfPngs + numberOfJpgs)) + 1;
				}
				usedImageNums.push(num);
				if (num > numberOfPngs) {
					ext = "jpg";
					num -= numberOfPngs;
				} else {
					ext = "png";
				}
				imageURL = "Image (" + num + ")." + ext;
				imageArray.push(imageURL);
			}

			//shuffle the images
			shuffle(imageArray);

			localStorage.setItem("imageArray", JSON.stringify(imageArray));

			//preload images
			var imagesLoaded = 0;
			for (let im = 0; im < amount; im++) {
				actualImageArray[im] = new Image();
				actualImageArray[im].src = 'IAM Images/' + imageArray[im];
				actualImageArray[im].onload = function () {
					console.log(++imagesLoaded)
					if (imagesLoaded == amount && preloading && !test) {
						startMemoCountdown();
					}
				};
			}
		}





	}

	function preloadCardImages(test = false) {

		var cardArray = getStandardDeck();

		var actualCardArray = [];
		//preload images
		var cardsLoaded = 0;

		actualCardArray[0] = new Image();
		actualCardArray[0].src = "Card images " + cardSet + "/back.png";
		actualCardArray[0].onload = function () {
			console.log(++cardsLoaded);
			if (cardsLoaded == 53) {
				if (competitionMode) {
					document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
                    document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
					preloaded = true;
				} else {
					startMemoCountdown();
				}
			}
		};

		for (let c = 1; c < 53; c++) {
			actualCardArray[c] = new Image();
			actualCardArray[c].src = "Card images " + cardSet + "/" + cardArray[c - 1]["cs"] + getValueName(cardArray[c - 1]["cv"]) + ".png";
			actualCardArray[c].onload = function () {
				console.log(++cardsLoaded);
				if (cardsLoaded == 53) {
					if (competitionMode) {
						document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
                        document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
					} else {
						if (!test) startMemoCountdown();
					}
				}
			};
		}


	}


	function startMemo(test = false) {		
		//Display memo section only
		document.getElementById("countdownRow").style = "display:none";
		document.getElementById("memoRow").style = "display:block";

		//Display relevant memo depending on discipline
		switch (currentDiscipline) {
			case "5N":
			case "15N":
			case "30N":
			case "60N":
				startNumberMemo(test);
				break;
			case "5B":
			case "30B":
				startBinaryMemo(test);
				break;
			case "10C":
			case "30C":
			case "60C":
			case "SC":
				startCardMemo(test);
				break;
			case "D":
				startDatesMemo(test);
				break;
			case "5F":
			case "15F":
				startNamesMemo(test);
				break;
			case "5W":
			case "15W":
				startWordsMemo(test);
				break;
			case "S":
				startSpokenMemo(test);
			default:
				startImagesMemo(test);
		}
	}

	function startNumberMemo(test) {

		//set ended to false
		ended = false;

		if (miniGroupings.length == 0) {
			miniGroupings.push(locusSize);
			localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
		}

		//create the arrays of minigroup and locus starting points
		miniGroupStarts = [];
		locusStarts = [0];
		var counter = 0;
		curMiniGroup = 0;
		while (counter < amount) {
			miniGroupStarts.push(counter);
			counter += parseFloat(miniGroupings[curMiniGroup]);
			if (curMiniGroup == miniGroupings.length - 1) {
				locusStarts.push(counter);
				curMiniGroup = 0;
			} else {
				curMiniGroup = parseFloat(curMiniGroup) + 1 % miniGroupings.length;
			}
		}
		console.log(miniGroupStarts);
		console.log(locusStarts);


		//work out how many pages needed (480 digits per page)
		numberOfPages = Math.ceil(amount / numbersPerPage);
		curPos = 0;
		curLocus = 0;
		curMiniGroup = 0;
		curPage = 0;

		firstOfGroup = 0;

		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusNumMemo(" + numbersPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/>";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}

		//add the memo content
		var numberMemoString = "";
		for (i = 0; i < numberOfPages; i++) {

			if (i < numberOfPages - 1) {
				numbersOnThisPage = numbersPerPage;
			}
			else {
				numbersOnThisPage = amount - i * numbersPerPage;
			}

			numberMemoString += "<div id='page" + i + "'><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";
			for (j = 0; j < numbersOnThisPage; j++) {
				numberMemoString += "<td id='tdMemo" + (i * numbersPerPage + j) + "' class='" + skin + "numbersMemo' onclick='moveFocusNumMemo(" + (i * numbersPerPage + j) + ")'>" + numberList[i * numbersPerPage + j] + "</td>";
				if ((j + 1) % numbersPerRow == 0) {
					if (j + 1 == numbersOnThisPage) {
						numberMemoString += "</tr></table></div>";

					}
					else {

						numberMemoString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";


					}
				}

			}

		}


		numberMemoString += "</div><br />";
		//removed memo finish buttons
		// numberMemoString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";
		document.getElementById("memoContentDiv").innerHTML = numberMemoString;

		//add separations
		if (resuming) separations = JSON.parse(localStorage.getItem("separations"));

		if (separations.length > 0) {
			for (var i = 0; i < amount; i++) {
				if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
					document.getElementById("tdMemo" + i).classList.add("separation");
				}

			}
		}



		//go to first digits
		moveFocusNumMemo(0);



		//set current position
		curPos = 0;
		curPage = 0;

		r = document.getElementById(skin + 'MemoTimeInner');
		if (!test) {
			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);


				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					//Clear display
					document.getElementById("memoRow").style.display = "none";

					memoTimeTaken = memoTime;

					//set ended to true
					ended = true;
					localStorage.setItem("phase", "recall");
					localStorage.setItem(timeElapsed, "0");
					startRecallCountdown();
				}
				//Otherwise repeat this function
				else {
					if (!ended) {
						myTimer = setTimeout(f, 1000);
					}
				}
			})();
		} else {
			r.textContent = "";
		}

		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {				
				finishMemo(test);
			}



			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				e.preventDefault();
				moveNextNumMemo();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				e.preventDefault();
				movePreviousNumMemo();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpNumMemo();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownNumMemo();
			}


			//if [ is pressed, previous page
			if (e.key == ',' && !ended) {

				if (curPage > 0) moveFocusNumMemo(numbersPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusNumMemo(numbersPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusNumMemo(0);
			}



		};

	}

	function moveNextNumMemo() {
		if (!ended) {

			//go to next group start if possible
			if (!(curLocus == locusStarts.length - 1 && curMiniGroup == miniGroupings.length - 1)) {

				//see if it's a new locus
				//	if ((curMiniGroup+1) % miniGroupings.length == 0) {
				if (curMiniGroup == miniGroupings.length - 1) {
					moveLocusNumMemo(curLocus + 1, 0);
				} else {
					moveLocusNumMemo(curLocus, curMiniGroup + 1);
				}

			}
		}
	}

	function movePreviousNumMemo() {

		if (!ended) {
			//go to previous group start if possible
			if (!(curLocus == 0 && curMiniGroup == 0)) {

				//see if it's a new locus
				if (curMiniGroup == 0) {
					moveLocusNumMemo(curLocus - 1, miniGroupings.length - 1);
				} else {
					moveLocusNumMemo(curLocus, curMiniGroup - 1);
				}

			}
		}
	}

	function moveUpNumMemo() {

		//if we are on first row, don't move

		if (curPos >= numbersPerRow) {


			moveFocusNumMemo(curPos - numbersPerRow);


		}
	}

	function moveDownNumMemo() {

		//if we are on last row, don't move

		if (curPos + numbersPerRow < amount) {


			moveFocusNumMemo(curPos + numbersPerRow);


		}
	}

	function moveLocusNumMemo(newLocus, newMiniGroup) {
		var firstOfLocus = locusStarts[curLocus];
		var newFirstOfLocus = locusStarts[newLocus];
		var newPos;

		//if moving locus, remove all highlights from curLocus and add highlight to newLocus
		if (curLocus != newLocus) {
			//remove highlights
			document.getElementById("tdMemo" + firstOfLocus).classList.remove(skin + "numbersSelected");
			document.getElementById("tdMemo" + firstOfLocus).style.backgroundColor = "";
			for (var i = 1; i < locusSize; i++) {
				if (firstOfLocus < numberList.length - i) {
					document.getElementById("tdMemo" + (firstOfLocus + i)).classList.remove(skin + "numbersSelected");
					document.getElementById("tdMemo" + (firstOfLocus + i)).style.backgroundColor = "";
				}
			}
		} else { //not moving locus
			//put selected minigroup back to skin+numbersInLocus
			for (var i = 0; i < miniGroupings[curMiniGroup]; i++) {
				document.getElementById("tdMemo" + (curPos + i)).classList.remove(skin + "numbersSelected");
				document.getElementById("tdMemo" + (curPos + i)).classList.add(skin + "numbersInLocus");
			}
		}

		//add highlights
		var totalSoFar = 0;
		for (i = 0; i < miniGroupings.length; i++) {

			//go through all digits in this miniGroup
			for (j = 0; j < miniGroupings[i]; j++) {
				var pos = newFirstOfLocus + totalSoFar + j;
				if (i == newMiniGroup) {
					if (j == 0) newPos = pos;
					document.getElementById("tdMemo" + pos).classList.add(skin + "numbersSelected");
				} else {
					document.getElementById("tdMemo" + pos).classList.add(skin + "numbersInLocus");
				}
			}
			totalSoFar += parseFloat(miniGroupings[i]);
		}

		//get new page if necessary
		var newPage = Math.floor(newPos / numbersPerPage);
		if (newPage != curPage || curPos == 0) {

			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";

					if (numberOfPages > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i).style.display = "none";
					if (numberOfPages > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelink";
					}
				}
			}
			curPage = newPage;
		}
		curPos = newPos;
		curLocus = newLocus;
		curMiniGroup = newMiniGroup;
	}

	function moveFocusNumMemo(newPos) {

		var newLocus = Math.floor(newPos / locusSize);
		var newFirstOfLocus = locusStarts[newLocus];

		var totalSoFar = 0;
		var newMiniGroup = 0;

		for (i = 0; i < miniGroupings.length; i++) {
			totalSoFar += parseFloat(miniGroupings[i]);
			if (newPos - newFirstOfLocus < totalSoFar) {

				newPos = Number(parseFloat(newFirstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
				newMiniGroup = i;
				break;
			}
		}

		moveLocusNumMemo(newLocus, newMiniGroup);


		/*
		//get current first of locus
		var firstOfLocus = curPos - (curPos % locusSize);
		
		
		
		 //remove highlight from existing locus
		 document.getElementById("tdMemo" + firstOfLocus).className = skin + "numbersMemo";
			document.getElementById("tdMemo" + firstOfLocus).style.backgroundColor = "";
			for (var i = 1;i<locusSize;i++) {
			if (firstOfLocus < numberList.length - i) {
					document.getElementById("tdMemo" + (firstOfLocus + i)).className = skin + "numbersMemo";
					document.getElementById("tdMemo" + (firstOfLocus + i)).style.backgroundColor = "";
				}
			}*/


		/*
			//get first of grouping
			var firstOfGroup = curPos - (curPos % grouping);
		
		
				//remove highlight from existing grouping
			document.getElementById("tdMemo" + firstOfGroup).className = skin + "numbersMemo";
			document.getElementById("tdMemo" + firstOfGroup).style.backgroundColor = "";
			for (var i = 1;i<grouping;i++) {
			if (firstOfGroup < numberList.length - i) {
					document.getElementById("tdMemo" + (firstOfGroup + i)).className = skin + "numbersMemo";
					document.getElementById("tdMemo" + (firstOfGroup + i)).style.backgroundColor = "";
				}
		
			}
		*/

		/*
			//get new page
			var newPage = Math.floor(newPos/numbersPerPage);
			if (newPage != curPage || curPos == 0) {
		
		
			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";
					
				if (numberOfPages>1) {
				//highlight this page tab
				document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
				}
				}
				else {
				document.getElementById("page" + i).style.display = "none";
				if (numberOfPages>1) {
				//un-highlight this page tab
				document.getElementById("page" + i + "tablink").className = skin + "pagelink";
				}
				}
			}
			curPage = newPage;
			}
		
		
				if (newPos < amount) {
		
			//update firstOfLocus
			if ((newPos == 0) || (newPos % locusSize == 0)) {
		
		firstOfLocus = newPos;
		
		}
		else {
		firstOfLocus = newPos - (newPos % locusSize);
		
		}
		
		/*
				//update firstOfGroup
				if ((newPos == 0) || (newPos % grouping == 0)) {
		
					firstOfGroup = newPos;
		
				}
				else {
					firstOfGroup = newPos - (newPos % grouping);
		
				}
		*/

		/*
			//find actual newPos (it's the first in the minigroup)
			var totalSoFar = 0;
			var current = 0;
			var selGroup = 0;
		
			for (i = 0; i < miniGroupings.length; i++) {
				totalSoFar += parseFloat(miniGroupings[i]);
				if (newPos-firstOfLocus < totalSoFar) {
			
					newPos = Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
					selGroup = i;
					break;
				} 
			}
		
		
		//for each digit, add skin+numbersInLocus class, unless this is within newPos+its own grouping, in which case add skin+NumbersSelected
		totalSoFar = 0;
		for (i = 0; i < miniGroupings.length; i++) {
			
			//go through all digits in this miniGroup
			for (j = 0; j < miniGroupings[i]; j++) {
				
			if (totalSoFar + j >= parseFloat(newPos)-firstOfLocus && totalSoFar + j < (newPos-firstOfLocus) + parseFloat(miniGroupings[selGroup])) {
			document.getElementById("tdMemo" + (Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) + parseFloat(j)))).className = skin + "numbersMemo " + skin + "numbersSelected";
			} else {
				document.getElementById("tdMemo" + (Number(parseFloat(firstOfLocus) + parseFloat(totalSoFar) + parseFloat(j)))).className = skin + "numbersMemo " + skin + "numbersInLocus";
			}
			}
			totalSoFar += parseFloat(miniGroupings[i]);
		}
		
		//	newPos = firstOfGroup;
		//	document.getElementById("tdMemo" + (firstOfLocus)).className = skin + "numbersMemo " + skin + "numbersSelected";		
			
			//set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
			//add the selected skin to this digit
				/*
				newPos = firstOfGroup;
				document.getElementById("tdMemo" + (firstOfGroup)).className = skin + "numbersMemo " + skin + "numbersSelected";		
		*/



		/*
	
		for (var i = 1;i<grouping;i++) {
		if (firstOfGroup < numberList.length - i) {
				document.getElementById("tdMemo" + (Number(firstOfGroup + i))).className = skin + "numbersMemo " + skin + "numbersSelected";
		  
			}
		}
	
	*/
		/*
			curPos = newPos;
			}
		*/
	}


	function startBinaryMemo(test) {

		//set ended to false
		ended = false;

		//work out how many pages needed (360 digits per page)
		numberOfPages = Math.ceil(amount / binaryPerPage);
		curPos = 0;
		curPage = 0;
		firstOfGroup = 0;

		//work out number of levels
		var longLine = binaryPerRow;
		binLevels = 1;

		while (longLine % groupingW !== 0) {
			longLine += binaryPerRow;
			binLevels++;
		}



		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusBinMemo(" + binaryPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/>";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}

		//add the memo content
		var binaryMemoString = "";
		for (i = 0; i < numberOfPages; i++) {
			if (i < numberOfPages - 1) {
				binaryOnThisPage = binaryPerPage;
			}
			else {
				binaryOnThisPage = amount - i * binaryPerPage;
			}

			binaryMemoString += "<div id='page" + i + "'><table><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";
			for (j = 0; j < binaryOnThisPage; j++) {
				binaryMemoString += "<td id='tdMemo" + (i * binaryPerPage + j) + "' class='" + skin + "binaryMemo' onclick='moveFocusBinMemo(" + (i * binaryPerPage + j) + ")'>" + binaryList[i * binaryPerPage + j] + "</td>";
				if ((j + 1) % binaryPerRow == 0) {
					if (j + 1 == binaryOnThisPage) {
						binaryMemoString += "</tr></table></div>";

					}
					else {

						binaryMemoString += "</tr>";

						//spacer row
						//	for (k = 0; k < binaryPerRow; k++) {
						//   binaryMemoString += "<td id='tdMemoSpacer" + (i*binaryPerPage+Math.floor(j/binaryPerRow)*binaryPerRow+k) + "' height=16></td>";

						// }

						binaryMemoString += "<tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage + j) / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";


					}
				}

			}

		}


		binaryMemoString += "</div><br />";
		//removed finish button
		// binaryMemoString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";
		document.getElementById("memoContentDiv").innerHTML = binaryMemoString;

		//add separations
		if (resuming) separations = JSON.parse(localStorage.getItem("separationsBin"));


		//add separations
		if (separations.length > 0) {
			for (var i = 0; i < amount; i++) {
				if (separations.indexOf((i + 1) % groupingW) > -1 || (i + 1) % groupingW == 0) {
					document.getElementById("tdMemo" + i).classList.add("separation");
				}

			}
		}

		//go to first digits
		moveFocusBinMemo(0);



		//set current position
		curPos = 0;
		curPage = 0;

		r = document.getElementById(skin + 'MemoTimeInner');
		if (!test) {
			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);
				//ns=(((memoTime*1e3-memoTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
				//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);


				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					//Clear display
					document.getElementById("memoRow").style.display = "none";

					memoTimeTaken = memoTime;

					//set ended to true
					ended = true;
					localStorage.setItem("phase", "recall");
					localStorage.setItem(timeElapsed, "0");
					startRecallCountdown();
				}
				//Otherwise repeat this function
				else {
					if (!ended) {
						myTimer = setTimeout(f, 1000);
					}
				}
			})();
		} else {			
			r.textContent = "";
		}

		document.onkeydown = function (e) {
			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishMemo(test);

			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				moveNextBinMemo();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				movePreviousBinMemo();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpBinMemo();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownBinMemo();
			}

			//if [ is pressed, previous page
			if (e.key == ',' && !ended) {

				if (curPage > 0) moveFocusBinMemo(binaryPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusBinMemo(binaryPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusBinMemo(0);
			}


		};


	}

	function getFirstOfMatrix(pos) {
		var x = pos % binaryPerRow;
		var y = Math.floor(pos / binaryPerRow);

		var currentLevel = Math.floor(y / groupingH) % binLevels;
		var easyX = currentLevel * binaryPerRow + x;

		var newX = (easyX - (easyX % groupingW)) % binaryPerRow;
		var newY = y - (y % groupingH);
		//in case this matrix is split over two "big" rows, subtract matrix height * number of big rows' difference between this position and start of matrix
		newY -= groupingH * (Math.floor(easyX / binaryPerRow) - Math.floor((easyX - (easyX % groupingW)) / binaryPerRow));

		return newY * binaryPerRow + newX;
	}

	function getNextSquare(pos) {
		var positions = getMatrixPositions(pos);
		//find index of pos in positions
		var thisIndex = positions.indexOf(pos);
		//if it is highest then move to next matrix and return first
		if (thisIndex === positions.length - 1) {
			return getFirstOfMatrix(getNextImage(pos));
		}
		//else return position at thisIndex+1
		else {
			//check in case this is a truncated matrix
			if (positions[thisIndex + 1] >= amount) {
				return getFirstOfMatrix(getNextImage(pos));
			}
			//return next position in this matrix (USUAL CASE)
			return positions[thisIndex + 1];
		}
	}

	function getPreviousSquare(pos) {
		var positions = getMatrixPositions(pos);
		//find index of pos in positions
		var thisIndex = positions.indexOf(pos);
		//if it is lowest then move to previous matrix and return last
		if (thisIndex === 0) {
			var prevMatrixPositions = getMatrixPositions(getPreviousImage(pos));
			var result = prevMatrixPositions[prevMatrixPositions.length - 1];
			var i = prevMatrixPositions.length - 1;
			while (result >= amount) {
				i--;
				result = prevMatrixPositions[i];
			}
			return result;
		}
		//else return position at thisIndex-1
		else {
			return positions[thisIndex - 1];
		}
	}

	// binary code by Lance
	function getMatrixPositions(pos) {
		var firstOfMatrix = getFirstOfMatrix(pos);
		var x = firstOfMatrix % binaryPerRow;
		var y = Math.floor(firstOfMatrix / binaryPerRow);


		var positions = [];

		//loop through the height and width and add successive positions to the matrix, moving down as necessary
		for (var i = 0; i < groupingH; i++) {
			thisX = x;
			thisY = y + i;

			for (var j = 0; j < groupingW; j++) {
				positions.push(thisY * binaryPerRow + thisX);

				//if we have reached end of row, move back to beginning of row and move down by groupingH
				if (thisX + 1 === binaryPerRow) {
					thisX = 0;
					thisY += groupingH;
				}

				//else move along one to the right
				else {
					thisX++;
				}

			}
		}

		return positions;
	}

	function getNextImage(pos) {
		var x = (pos + groupingW) % binaryPerRow;
		var y = Math.floor(pos / binaryPerRow);
		if (pos + groupingW >= (y + 1) * binaryPerRow) {
			y += groupingH;
		}


		return y * binaryPerRow + x;

	}

	function getPreviousImage(pos) {
		var x = (pos - groupingW) % binaryPerRow;
		var y = Math.floor(pos / binaryPerRow);
		if (pos - groupingW < y * binaryPerRow) {
			y -= groupingH;
		}


		return y * binaryPerRow + x;

	}

	/*
	function getNextSquare(pos) {
		//check which row of a big row this is
		var rowCounter = 0;
	
			if (currentSquare % 90 >=30 && currentSquare % 90 < 59) {
				rowCounter = 1;
			}
			else if (currentSquare % 90 >=60) {
				rowCounter = 2;
			}
	
			//if it's last of 3, go to next row/image
			if (currentSquare % 3 == 2) {
				//next image
				if (rowCounter == 2) {
					//if end of big row, go to next digit
					if (currentSquare % 30 == 29) {
	
						return currentSquare + 1;
	
					}
					//else just go back up two rows to next image
					else {
					 return currentSquare - 59;
					}
				}
				//go to next row of this image
				else {
					return currentSquare + 28;
				}
			}
	
			else {
				return currentSquare+1;
			}
	}
	
	/*
	function setTheStage(width, height){
		var longLine = 30;
		var levels = 1;
	
	while (longLine % width !==0){
		longLine += 30;
		levels ++;
	}
	
		function toCorner(x,y){
		var currentLevel = Math.floor(y/height) % levels;
		var easyX = currentLevel * 30 + x;
	
	var newY = y - (y%height);
	var newX = easyX - (easyX % width);
	
	return [newX, newY];
	
	}
	}
	}
	}
	*/
	/*
	var newY = y - (y%height);
	var newX = (easyX - (easyX % width)) % 30;
	
	return [newX, newY];
	*/

	function moveNextBinMemo() {
		var nextImage = getNextImage(curPos)
		if (!ended) {
			if (nextImage >= amount) {
				/*
			//Get memo time
			memoTimeTaken = Date.now() - memoStart;
	
				//Clear display
			document.getElementById("memoRow").style.display = "none";
	
			//set ended to true
			ended = true;
	
	
			//Recall
			startRecallCountdown();
			*/

			}

			else {

				moveFocusBinMemo(nextImage);

			}
		}


	}

	function movePreviousBinMemo() {
		var prevImage = getPreviousImage(curPos);
		if (prevImage >= 0) {
			if (!ended) {
				moveFocusBinMemo(prevImage);
			}
		}
	}

	function moveUpBinMemo() {

		//if we are on first row, don't move

		if (curPos >= binaryPerRow * groupingH) {


			moveFocusBinMemo(curPos - binaryPerRow * groupingH);


		}
	}

	function moveDownBinMemo() {

		//if we are on last row, don't move

		if (curPos + binaryPerRow * groupingH < amount) {


			moveFocusBinMemo(curPos + binaryPerRow * groupingH);


		}
	}


	function moveFocusBinMemo(newPos) {
		//get grouping
		var positions = getMatrixPositions(curPos);
		//var firstOfGroup = positions[0];

		//remove highlight from existing grouping

		for (var i = 0; i < positions.length; i++) {
			if (positions[i] < binaryList.length) {
				document.getElementById("tdMemo" + (positions[i])).classList.remove(skin + "binarySelected");
				document.getElementById("tdMemo" + (positions[i])).style.backgroundColor = "";
			}

		}

		//get new page
		var newPage = Math.floor(newPos / binaryPerPage);
		if (newPage != curPage || curPos == 0) {



			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";
					if (numberOfPages > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i).style.display = "none";
					if (numberOfPages > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelink";
					}
				}
			}
			curPage = newPage;
		}

		if (newPos < amount) {

			//get grouping
			var newPositions = getMatrixPositions(newPos);

			firstOfGroup = newPositions[0];

			//set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
			newPos = firstOfGroup;


			//add highlight to new grouping

			for (var i = 0; i < positions.length; i++) {
				if (newPositions[i] < binaryList.length) {
					document.getElementById("tdMemo" + (newPositions[i])).classList.add(skin + "binarySelected");
					//  document.getElementById("tdMemo" + (newPositions[i])).style.backgroundColor = this[hiColour];	 
				}

			}


			curPos = newPos;
		}

	}




	function startCardMemo(test) {
		//card table if using analogue skin
		if (skin.indexOf("analogue") > -1) {
			$("#memoBox").addClass("cardTable");
			$(".disciplineTitleMemo").addClass("textCardTable");
			$(".disciplineTitleMemo").removeClass("textNonCards");
			//$(".spanShift").addClass("textCardTable");
			//$(".spanShift").removeClass("textNonCards");
			$(".digital1RecallTimeOuter").addClass("textCardTable");
			$(".digital1RecallTimeOuter").removeClass("textNonCards");
		}

	if (resuming) {
			//restore image list
		//	actualImageArray = JSON.parse(localStorage.getItem("imageArray")).map(el => { return { src: "IAM Images/" + el } });
			cardsLeftToRight = localStorage.getItem("cardsLeftToRight");
		} else {

			cardsLeftToRight = document.getElementById("chkLeftToRight").checked;
			localStorage.setItem("cardsLeftToRight", cardsLeftToRight);
		}


		//set ended to false
		ended = false;

		var cardsMemoString = "";
		curPos = 0;
		curPage = 0;
		firstOfGroup = 0;

		//add the page menu if >1 page
		if (amount > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < amount; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusCardsMemo(" + 52 * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/><br />";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}

		//add the memo content
		for (var i = 0; i < amount; i++) {

			cardsMemoString += "<div id='page" + i + "' style='position:relative'><div class='centred bigCards' style='position:relative;left:-" + (114.37 + (grouping - 1) * cardOffsetBig) / 2 + "' id='bigCards" + i + "''></div><br /><br />";
			/*cardsMemoString += "<div class='centred' style='position:relative;left:-" + (211+51*cardOffset)/2 + "'><span id='smallCardsBefore" + i + "'></span><span id='smallCardsAfter" + i + "''></span></div>";*/

			//adding extra fan
			cardsMemoString += "<div class='centred cardMemoFanDiv " + skin + "cardMemoFanDiv'>";
			//add cards to extra fan
			if (skin.indexOf("digital") > -1 && !cardsLeftToRight) {
				for (var j = 51; j >= 0; j--) {
					cardsMemoString += "<img src='Card images " + cardSet + "/" + cardList[i][j]["cs"] + getValueName(cardList[i][j]["cv"]) + ".png' class='cardMemoFan " + skin + "cardMemoFan' id='imgMemoFan" + (i * 52 + j) + "' onClick='moveFocusCardsMemo(" + (i * 52 + j) + ")'>";
				}

			} else {
				for (var j = 0; j < 52; j++) {
					cardsMemoString += "<img src='Card images " + cardSet + "/" + cardList[i][j]["cs"] + getValueName(cardList[i][j]["cv"]) + ".png' class='cardMemoFan " + skin + "cardMemoFan' id='imgMemoFan" + (i * 52 + j) + "' onClick='moveFocusCardsMemo(" + (i * 52 + j) + ")'>";
				}
			}

			cardsMemoString += "</div>";


			//
			cardsMemoString += "</div>";



		}

		document.getElementById("memoContentDiv").innerHTML = cardsMemoString
		//***USE THIS INSTEAD FOR FINISH BUTTON***
		//document.getElementById("memoContentDiv").innerHTML = cardsMemoString + "<br /><button class='btn btn-primary finishBtn' onclick='finishMemo();'>Finish</button>";





		//go to first digits
		moveFocusCardsMemo(0);

		//set current position
		curPos = 0;
		curPage = 0;

		////fan cards out
		if (skin.indexOf("analogue") > -1) {
			console.log("analogue");
			//fan memo cards out
			var cardsMF = document.getElementsByClassName("cardMemoFan");



			for (let j = 0; j < cardsMF.length; j++) {

				cardsMF[j].style.transform = "rotate(0deg)";
			}

			if (cardsLeftToRight) {
				for (let j = 0; j < cardsMF.length; j++) {
					cardsMF[j].style.transform = "rotate(" + ((j % 52) * 1) + "deg)";
				}
			} else {
				for (let j = cardsMF.length-1; j >=0; j--) {				
					cardsMF[cardsMF.length-1-j].style.transform = "rotate(" + ((j % 52) * 1) + "deg)";
					cardsMF[cardsMF.length-1-j].style.zIndex = j;
				}
			}
		} else {
			console.log("digital");
			var cardsM = document.getElementsByClassName("cardMemoFan");
			var w = document.getElementById("memoContentDiv").clientWidth;
			var offset = w / 52 + 30;
			console.log(offset);
			

			if (cardsLeftToRight) {
						for (let i = 0; i < cardsM.length; i++) {

							cardsM[i].style.transform = "translateX(-" + (offset * (i % 52) + 100) + "px)";

						}
			} else {
			//	var fanDivs = document.getElementsByClassName(skin + "cardMemoFanDiv");
			//	for (let i = 0; i < fanDivs.length; i++) {
			//		fanDivs[i].style.flexDirection = "row-reverse";
			//	}

				for (let i = cardsM.length-1; i >=0; i--) {			
				//	cardsM[i].style.position = "absolute";
			//		cardsM[i].style.left = (offset*(cardsM.length-1-i % 52) + 100) + "px";
					cardsM[i].style.transform = "translateX(-" + (offset * (i % 52) + 100) + "px)";
				//	cardsM[i].style.transform = "translateX(-" + (offset * ((cardsM.length-1-i) % 52) + 100) + "px)";
				//	cardsM[51-i].style.zIndex = 51-i;
			//		cardsM[51-i].style.position = "absolute";
				}

//				for (let i = 0; i < cardsM.length; i++) {

//cardsM[51-i].style.transform = "";
//cardsM[51-i].style.position  = "absolute";
//cardsM[51-i].style.left = ((offset-2)*(i % 52) - 140) + "px";

//}
			}
			

		}



		r = document.getElementById(skin + 'MemoTimeInner');

		if (!test) {

			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);


				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					finishMemo();
				}
				//Otherwise repeat this function
				else {
					if (!ended) {
						myTimer = setTimeout(f, 1000);
					}
				}
			})();
		} else {
			r.textContent = "";
		}

		document.onkeydown = function (e) {
			//If Enter is pressed in speed cards (during testing - for any event)
			//  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
			if (e.key == "Enter" && !ended) {
				finishMemo(test);
			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				if (cardsLeftToRight) {
					moveNextCardsMemo();
				} else {
					movePreviousCardsMemo();
				}
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				if (cardsLeftToRight) {
					movePreviousCardsMemo();
				} else {
					moveNextCardsMemo();
				}
			}



			//if , is pressed, previous page
			if (e.key == ',' && !ended) {

				if (curPage > 0) moveFocusCardsMemo(52 * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if . is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < amount - 1) moveFocusCardsMemo(52 * (curPage + 1));

			}

			//if up arrow is pressed, restart deck
			if (e.key == 'ArrowUp' && !ended) {

				moveFocusCardsMemo(52 * (curPage));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusCardsMemo(0);
			}
		};

	}

	function moveFocusCardsMemo(newPos) {
		//*show previously hidden cards in fan
		var oldFirstOfGroup = curPos - (curPos % 52 % grouping)
		for (i = oldFirstOfGroup; i < oldFirstOfGroup + grouping; i++) {
			document.getElementById("imgMemoFan" + i).style.visibility = "visible";
		}

		//get first of new grouping
		var firstOfGroup = newPos - (newPos % 52 % grouping);


		//get new page

		var newPage = Math.floor(newPos / 52);
		if (newPage != curPage || curPos == 0) {


			//show/hide correct pages
			for (var i = 0; i < amount; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";
					if (amount > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i).style.display = "none";
					if (amount > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelink";
					}
				}
			}
			curPage = newPage;
		}
		if (curPage <= amount) {

			//set new pos to first in group - if user has clicked on a card or new page, need to only highlight from first in group
			newPos = firstOfGroup;


			//Show group in bigCards
			var groupString = "";
			if (cardsLeftToRight) {
				for (var j = newPos % 52; j < newPos % 52 + grouping; j++) {
					if (j < 52) {
						//offset should increase by cardOffsetBig every time
						var offset = (j - newPos % 52) * cardOffsetBig;

						groupString += "<img src='Card images " + cardSet + "/" + cardList[curPage][j]["cs"] + getValueName(cardList[curPage][j]["cv"]) + ".png' class='" + skin + "cardImgBig'  style='left:50%;margin:0 0 0 " + offset + "px' id='imgMemo" + (curPage * 52 + j) + "' onClick='moveFocusCardsMemo(" + (curPage * 52 + j) + ")'>";
					}
				}
			} else {
				for (var j = newPos % 52+grouping-1; j >= newPos % 52; j--) {
				if (j < 52) {
					//offset should increase by cardOffsetBig every time
					var offset = -(j - (newPos % 52 + grouping-1)) * cardOffsetBig;

					groupString += "<img src='Card images " + cardSet + "/" + cardList[curPage][j]["cs"] + getValueName(cardList[curPage][j]["cv"]) + ".png' class='" + skin + "cardImgBig'  style='z-index:" + (51-j) + ";left:50%;margin:0 0 0 " + offset + "px' id='imgMemo" + (curPage * 52 + j) + "' onClick='moveFocusCardsMemo(" + (curPage * 52 + j) + ")'>";
				}
			}
			}
			document.getElementById('bigCards' + curPage).innerHTML = groupString;

			//*hide cards in fan
			for (i = firstOfGroup; i < firstOfGroup + grouping; i++) {
				if (i < amount*52) {
					 document.getElementById("imgMemoFan" + i).style.visibility = "hidden";
				}
			}


			curPos = newPos;
		}


	}

	function moveNextCardsMemo() {
		if (!ended) {

			if (curPos + grouping >= amount * 52) {
				if (currentDiscipline === "SC") {
					finishMemo();
				}

			}
			else {
				if ((curPos + grouping) % 52 < curPos % 52) {
					moveFocusCardsMemo(52 * (curPage + 1));
				} else {
					moveFocusCardsMemo(curPos + grouping);
				}
			}
		}
	}

	function movePreviousCardsMemo() {
		if (!ended) {

			if (curPos - grouping >= 0) {
				if ((curPos - grouping) % 52 > curPos % 52) {
					moveFocusCardsMemo(52 * (curPage - 1));
				} else {
					moveFocusCardsMemo(curPos - grouping);
				}
			}
		}
	}


	function getValueName(strValue) {
		var strValueName = "";

		switch (strValue) {
			case "A":
				strValueName = "01";
				break;
			case "J":
				strValueName = "11";
				break;
			case "Q":
				strValueName = "12";
				break;
			case "K":
				strValueName = "13";
				break;
			default:
				strValueName = strValue;
				if (strValueName.length == 1) {
					strValueName = "0" + strValueName;
				}
		}


		return strValueName;

	}

	function startImagesMemo(test) {


		if (resuming) {
			//restore image list
			actualImageArray = JSON.parse(localStorage.getItem("imageArray")).map(el => { return { src: "IAM Images/" + el } });
			blnImageSkip = localStorage.getItem("blnImageSkip");
		} else {

			blnImageSkip = document.getElementById("chkSkipFinalImage").checked;
			localStorage.setItem("blnImageSkip", blnImageSkip);
		}
		//set ended to false
		ended = false;

		var imagesMemoString = "";
		curPos = 0;
		curPage = 0;

		//work out how many pages needed (480 digits per page)
		numberOfPages = Math.ceil(amount / imagesPerPage);


		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusImagesMemo(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/><br />";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}



		//add the memo content
		for (var i = 0; i < numberOfPages; i++) {

			imagesMemoString += "<div id='page" + i + "'><table class='imageTable' id='memoTable" + i + "'>";
			var spacer;



			for (var j = 0; j < imagesPerPage; j++) {
				//if we haven't reached the end
				if (i * imagesPerPage + j < amount) {
					//add row num if needed
					if (j % 5 == 0) {
						imagesMemoString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
					}


					//add the next image and a number below it
					//	imagesMemoString += "<td id='tdMemo" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgMemo" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td class='imageNum'>" + ((j % 5 )+ 1) + "</td></tr></table></td>";

					//imagesMemoString += "<td id='tdMemo" + Number(i*imagesPerPage+j) + "'><span class='imageNum'>" + ((j % 5 )+ 1) + "&nbsp;</span><img class='imageClass' id='imgMemo" + Number(i*imagesPerPage+j) + "'  onclick='moveFocusImagesMemo(" + Number(i*imagesPerPage+j) + ")' src='" + actualImageArray[i*imagesPerPage+j].src + "' height=80></td>";
					//we no longer want image num next to image ***
					imagesMemoString += "<td id='tdMemo" + Number(i * imagesPerPage + j) + "'><img class='imageClass' id='imgMemo" + Number(i * imagesPerPage + j) + "'  onclick='moveFocusImagesMemo(" + Number(i * imagesPerPage + j) + ")' src='" + actualImageArray[i * imagesPerPage + j].src + "' height=80></td>";

					//close the row if needed
					if ((j + 1) % 5 == 0) {
						imagesMemoString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
					}
				}
			}
			imagesMemoString += "</table></div>";
		}

		document.getElementById("memoContentDiv").innerHTML = imagesMemoString



		//go to first image
		moveFocusImagesMemo(0);

		//set current position
		curPos = 0;
		curPage = 0;

		r = document.getElementById(skin + 'MemoTimeInner');

		if (!test) {
			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);


				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					finishMemo();
				}
				//Otherwise repeat this function
				else {
					if (!ended) {
						myTimer = setTimeout(f, 1000);
					}
				}
			})();
		} else {
			r.textContent = "";
		}

		document.onkeydown = function (e) {
			//If Enter is pressed in speed cards (during testing - for any event)
			//  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
			if (e.key == "Enter" && !ended) {
				finishMemo(test);


			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				moveNextImagesMemo();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				movePreviousImagesMemo();
			}


			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpImagesMemo();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownImagesMemo();
			}

			//if [ is pressed, previous page
			if (e.key == ',' && !ended) {

				if (curPage > 0) moveFocusImagesMemo(imagesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusImagesMemo(imagesPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusImagesMemo(0);
			}
		};

	}


	function moveNextImagesMemo() {
		//check if skipping and if this is the final image
		if (curPos + 1 < amount) {
			if (blnImageSkip && ((curPos + 2) % 5 == 0)) {
				moveFocusImagesMemo(curPos + 2);
			} else {
				moveFocusImagesMemo(curPos + 1);
			}
		}

	}

	function movePreviousImagesMemo() {
		//check if skipping and if this is the final image
		if (curPos > 0) {
			if (blnImageSkip && ((curPos) % 5 == 0)) {
				moveFocusImagesMemo(curPos - 2);
			} else {
				moveFocusImagesMemo(curPos - 1);
			}
		}
	}

	function moveUpImagesMemo() {
		//check if skipping and if this is the final image
		if (curPos >= 5) {

			moveFocusImagesMemo(curPos - 5);

		}
	}

	function moveDownImagesMemo() {
		//check if skipping and if this is the final image
		if (curPos + 5 < amount) {

			moveFocusImagesMemo(curPos + 5);

		}
	}

	function moveFocusImagesMemo(newPos) {
		//get new page
		var newPage = Math.floor(newPos / imagesPerPage);
		if (newPage != curPage || curPos == 0) {



			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";
					if (numberOfPages > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i).style.display = "none";
					if (numberOfPages > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelink";
					}
				}
			}
			curPage = newPage;
		}

		if (newPos < amount) {
			document.getElementById("imgMemo" + (curPos)).classList.remove(skin + "imagesSelected");

			document.getElementById("imgMemo" + (newPos)).className = skin + "imagesSelected";


			curPos = newPos;
		}

	}


	function startWordsMemo(test) {
		ended = false;

		if (resuming) {
			//restore word list
			wordList = JSON.parse(localStorage.getItem("correctAnswers"));
		} else if (!competitionMode) {

			

		}


		wordsPerPage = wordsPerColumn * wordColumnsPerPage;

		curPos = 0;
		curPage = 0;

		//work out how many pages needed (480 digits per page)
		numberOfPages = Math.ceil(amount / wordsPerPage);


		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusWordsMemo(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul>";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}


		//add the memo content
		for (var i = 0; i < numberOfPages; i++) {
			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i);

			//add table to hold the words
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "wordsTable");

			//add rows with cells
			for (j = 0; j < wordsPerColumn; j++) {
				var row = document.createElement("tr");
				for (k = 0; k < wordColumnsPerPage; k++) {
					var wordCell = document.createElement("td");
					var numberCell = document.createElement("td");
					var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

					if (thisIndex < wordList.length) {
						wordCell.innerHTML = wordList[thisIndex];
						numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
						numberCell.setAttribute("class", skin + "wordsNum");
						wordCell.setAttribute("id", "tdMemo" + thisIndex);
						wordCell.setAttribute("class", skin + "wordsMemo");
						wordCell.setAttribute("onclick", "moveFocusWordsMemo(" + thisIndex + ")");
					}
					row.appendChild(numberCell);
					row.appendChild(wordCell);
				}
				thisPageTable.appendChild(row);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("memoContentDiv").appendChild(pageDiv);
		}

		//go to first word
		moveFocusWordsMemo(0);

		//set current position
		curPos = 0;
		curPage = 0;

		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

		r = document.getElementById(skin + 'MemoTimeInner')
		if (!test) {
			//set the timer
			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);


				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					//Clear display
					document.getElementById("memoRow").style.display = "none";

					memoTimeTaken = memoTime;

					//set ended to true
					ended = true;
					localStorage.setItem("phase", "recall");
					localStorage.setItem(timeElapsed, "0");
					startRecallCountdown();
				}
				//Otherwise repeat this function
				else if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			})();
		} else {
			r.textContent = "";
		/*	$('#overlayDiv').html('<span id="alert">Press Enter to exit test</span>');
			$("#overlayDiv").css("zIndex",2);
			$('#alert').fadeOut(2500, "linear", ()=>$("#overlayDiv").css("zIndex",-2));*/
		}

		document.onkeydown = function (e) {
			//If Enter is pressed in speed cards (during testing - for any event)
			//  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
			if (e.key == "Enter" && !ended) {
				finishMemo(test);
			}

			//if right arrow or tab pressed, move on
			if ((e.key == "ArrowRight" || (e.key == "Tab" && !e.shift.Key)) && !ended) {
				e.preventDefault();
				moveNextWordsMemo();
			}

			//if left arrow or shift-tab is pressed to go back
			if ((e.key == "ArrowLeft" || e.shiftKey && e.key == "Tab") && !ended) {
				e.preventDefault();
				movePreviousWordsMemo();
			}

			//if up arrow pressed, move up (previous)
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				movePreviousWordsMemo();
			}

			//if down arrow pressed, move down (next)
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveNextWordsMemo();
			}

			//if [ is pressed, previous page
			if (e.key == ',' && !ended) {
				if (curPage > 0) moveFocusWordsMemo(wordsPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusWordsMemo(wordsPerPage * (curPage + 1));

			}


			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusWordsMemo(0);
			}
		};


	}


	function openWordsFile() {

		if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
			xmlhttp = new XMLHttpRequest();
		}
		else {// code for IE6, IE5
			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
		}
		xmlhttp.open("GET", "Training data/words.xml", false);
		xmlhttp.send();
		fobWordsDoc = xmlhttp.responseXML;

	}



	function startDatesMemo(test) {
		ended = false;
		if (!isAnalogue()) {
			document.getElementById("memoBox").classList.remove(skin + "memoHeight");
			document.getElementById("memoBox").classList.add(skin + "memoHeightDates");
		}

		if (resuming) {
			//restore date list
			dateList = JSON.parse(localStorage.getItem("correctAnswers"));

		} else if (!competitionMode) {

		//	openDatesFile();
	//		generateDatesList();

			//save date list in storage
		//	localStorage.setItem("correctAnswers", JSON.stringify(dateList));
		}

		curPos = 0;
		curPage = 0;
		//work out how many pages needed (480 digits per page)
		numberOfPages = Math.ceil(amount / datesPerPage);


		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusDatesMemo(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/>";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}


		//add the memo content
		for (var i = 0; i < numberOfPages; i++) {
			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i);

			//add table to hold the dates
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "datesTable");

			//add rows with cells
			for (j = 0; j < datesPerPage; j++) {
				var row = document.createElement("tr");

				var yearCell = document.createElement("td");
				var eventCell = document.createElement("td");
				var thisIndex = i * datesPerPage + j;

				if (thisIndex < dateList.length) {
					yearCell.innerHTML = dateList[thisIndex].year;
					eventCell.innerHTML = dateList[thisIndex].event;
					yearCell.setAttribute("class", skin + "datesYearMemo");
					eventCell.setAttribute("class", skin + "datesMemo");
					row.setAttribute("id", "trMemo" + thisIndex);

				}
				row.appendChild(yearCell);
				row.appendChild(eventCell);

				thisPageTable.appendChild(row);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("memoContentDiv").appendChild(pageDiv);
		}

		//go to first word
		moveFocusDatesMemo(0);

		//set current position
		curPos = 0;
		curPage = 0;

		r = document.getElementById(skin + 'MemoTimeInner')

		if (!test) {
			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);

				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					//Clear display
					document.getElementById("memoRow").style.display = "none";

					memoTimeTaken = memoTime;

					//set ended to true
					ended = true;
					localStorage.setItem("phase", "recall");
					localStorage.setItem(timeElapsed, "0");
					startRecallCountdown();
				}
				//Otherwise repeat this function
				else if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			})();
		} else {
			r.textContent = "";
		}

		document.onkeydown = function (e) {
			//If Enter is pressed in speed cards (during testing - for any event)
			//  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
			if (e.key == "Enter" && !ended) {
				finishMemo(test);
			}

			//if right or down arrow or tab pressed, move on
			if ((e.key == "ArrowRight" || e.key == "ArrowDown" || (e.key == "Tab" && !e.shiftKey)) && !ended) {
				e.preventDefault();

				moveNextDatesMemo();
			}


			//if left or up arrow or shift-tab is pressed to go back
			if ((e.key == "ArrowLeft" || e.key == "ArrowUp" || e.shiftKey && e.key == "Tab") && !ended) {
				e.preventDefault();
				movePreviousDatesMemo();
			}


			//if [ is pressed, previous page
			if (e.key == ',' && !ended) {

				if (curPage > 0) moveFocusDatesMemo(datesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusDatesMemo(datesPerPage * (curPage + 1));

			}


			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusDatesMemo(0);
			}
		};

	}

	function openDatesFile() {

		if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
			xmlhttp = new XMLHttpRequest();
		}
		else {// code for IE6, IE5
			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
		}
		xmlhttp.open("GET", "Training data/dates.xml", false);
		xmlhttp.send();
		fobDatesDoc = xmlhttp.responseXML;

	}


	function generateDatesList() {
		dateList = [];
		var date_events = SelectNodes(fobDatesDoc, "//date_event");

		//Alert if not enough in our database
		if (date_events.length < amount) {
			alert("not enough dates in database");
			return;
		}

		//add all years to the array
		for (var i = 1000; i <= 2099; i++) {
			dateList.push({ year: i });
		}

		//shuffle
		shuffle(dateList);

		//add events to the array
		for (var i = 0; i < amount; i++) {
			dateList[i].event = date_events[i].textContent;
		}

		//truncate to right amount
		dateList = dateList.splice(0, amount);

		//shuffle again
		shuffle(dateList);
	}

	function preloadDatesLanguages() {

		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Dates_lkjfsldkjf/dates_languages.txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var datesLangText = rawFile.responseText;
					datesLangText.trim();
					var txtArray = datesLangText.split('\n');

					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {
							var sel = document.getElementById("selDatesLanguage");
							var option = document.createElement("option");
							option.value = txtArray[i];
							option.text = txtArray[i];
							sel.add(option);
						}
					}

					datesLanguagesPreloaded = true;
				}
			}
		}
		rawFile.send(null);





	}

	function preloadWordsLanguages() {

		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Words_lkjfsldkjf/words_languages.txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var wordsLangText = rawFile.responseText;
					wordsLangText.trim();
					var txtArray = wordsLangText.split('\n');

					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {
							var sel = document.getElementById("selWordsLanguage");
							var option = document.createElement("option");
							option.value = txtArray[i];
							option.text = txtArray[i];
							sel.add(option);
						}
					}

					wordsLanguagesPreloaded = true;
				}
			}
		}
		rawFile.send(null);





	}


	function preloadNamesCharsets() {

		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Names_lkjfsldkjf/names_charsets.txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var namesCharsetText = rawFile.responseText;
					namesCharsetText.trim();
					var txtArray = namesCharsetText.split('\n');

					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {
							var sel = document.getElementById("selNamesCharset");
							var option = document.createElement("option");
							option.value = txtArray[i];
							option.text = txtArray[i];
							sel.add(option);
						}
					}
				}

				namesCharsetsPreloaded = true;
			}
		}
		rawFile.send(null);





	}


	function readDatesFile(language) {
		document.getElementById("btnStartMemoCountdown").innerText = "Loading data... Please wait";
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Dates_lkjfsldkjf/dates_" + language + ".txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var datesText = rawFile.responseText;
					datesText.trim();
					var txtArray = datesText.split('\n');
					dateList = [];
					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {
							elements = txtArray[i].split('\t');
							dateList.push({ year: elements[0], event: elements[1] });
						}
					}
					//maybe call these few lines function donePreloading()

					document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
                    document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
					document.getElementById("btnStartMemoCountdown").innerText = "Start";
					localStorage.setItem("preloadedData",JSON.stringify(dateList));
					preloaded = true;
				}
			}
		}
		rawFile.send(null);




	}

	function readWordsFile(language) {
		document.getElementById("btnStartMemoCountdown").innerText = "Loading data... Please wait";
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Words_lkjfsldkjf/words_" + language + ".txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var wordsText = rawFile.responseText;
					wordsText.trim();
					var txtArray = wordsText.split('\n');
					wordList = [];
					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {

							wordList.push(txtArray[i]);
						}
					}

					document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
                    document.getElementById("btnStartMemoCountdown").classList.add("glowButton");
					document.getElementById("btnStartMemoCountdown").innerText = "Start";
					localStorage.setItem("preloadedData",JSON.stringify(wordList));
					preloaded = true;
				}
			}
		}
		rawFile.send(null);




	}

	function readNamesFile(charset) {
		//This function is used in competition when we are reading in the names file for a specific language

		//Disable Start button and remove glow
		document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
        document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");

		//Open the names file for the selected character set
		var rawFile = new XMLHttpRequest();
		rawFile.open("GET", "Data/Names_lkjfsldkjf/names_" + charset + ".txt", false);
		rawFile.onreadystatechange = function () {
			if (rawFile.readyState === 4) {
				if (rawFile.status === 200 || rawFile.status == 0) {
					var namesText = rawFile.responseText;
					namesText.trim();
					var txtArray = namesText.split('\n');
					nameList = [];

					//Parse the text file and assign first name and surname, as well as the URL of the corresponding image file
					for (var i = 0; i < txtArray.length; i++) {
						if (txtArray[i] !== "") {
							elements = txtArray[i].split(' ');
							nameList[i] = new nameObject();
							nameList[i].imageURL = "Data/Names_lkjfsldkjf/" + Number(i + 1) + ".jpg";
							nameList[i].firstname = elements[0];
							nameList[i].surname = elements[1];
						}
					}

					//truncate names list if it exceeds the specified amount for the discipline
					amount = lookupProperty(currentDiscipline, "amount");
					facesAmount = Math.ceil(amount / 2);
				
					//Alert if not enough in our database
					if (nameList.length < facesAmount) {
						alert("not enough names in database");
						goToSettings();
					}
		
					if (nameList.length > facesAmount) {
						//Truncate array to just amount required (to take into account the odd one or two left over from Math.ceil because cannot divide exactly by 6)
						nameList = nameList.splice(0, facesAmount);
					}

					//save this preloadedData in case we are going to look at test page
					localStorage.setItem("preloadedData",JSON.stringify(nameList));

					//preload face images					
					var imagesLoaded = 0;
					actualImages = [];
					for (let im = 0; im < nameList.length; im++) {

						actualImages[im] = new Image();					
						actualImages[im].onload = function () {
							console.log(++imagesLoaded);
							if (imagesLoaded == nameList.length) {

								document.getElementById("btnStartMemoCountdown").removeAttribute("disabled");
								document.getElementById("btnStartMemoCountdown").innerText = "Start";
                                document.getElementById("btnStartMemoCountdown").classList.add("glowButton");							
								preloaded = true;
							}
						};


						setTimeout(function () {
							actualImages[im].src = nameList[im].imageURL;
						}, 500);

					
					}					

				}
			}
		}
		rawFile.send(null);




	}


	function moveFocusDatesMemo(newPos) {
		if (newPos < amount) {
			//remove highlight from existing date
			document.getElementById("trMemo" + curPos).classList.remove(skin + "datesSelected");


			//get new page
			var newPage = Math.floor(newPos / datesPerPage);
			if (newPage != curPage || curPos == 0) {



				//show/hide correct pages
				for (var i = 0; i < numberOfPages; i++) {
					if (i == newPage) {
						document.getElementById("page" + i).style.display = "block";
						if (numberOfPages > 1) {
							//highlight this page tab
							document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
						}
					}
					else {
						document.getElementById("page" + i).style.display = "none";
						if (numberOfPages > 1) {
							//un-highlight this page tab
							document.getElementById("page" + i + "tablink").className = skin + "pagelink";
						}
					}
				}
				curPage = newPage;
			}
			document.getElementById("trMemo" + newPos).classList.add(skin + "datesSelected");

			curPos = newPos;
		}
	}

	function moveNextDatesMemo() {
		if (!ended && curPos < amount - 1) {
			moveFocusDatesMemo(curPos + 1);
		}
	}

	function movePreviousDatesMemo() {
		if (curPos > 0 && !ended) {
			moveFocusDatesMemo(curPos - 1);
		}
	}


	function startDatesRecall() {
		ended = false;

		if (!isAnalogue()) {
			document.getElementById("recallBox").classList.remove(skin + "memoHeight");
			document.getElementById("recallBox").classList.add(skin + "memoHeightDates");
		}

		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			numberOfPages = Math.ceil(amount / datesPerPage); //added in case went straight to recall

			//restore data
			dateList = JSON.parse(localStorage.getItem("correctAnswers"));
			shuffledDateList = JSON.parse(localStorage.getItem("shuffledDateList"));
		} else {

			shuffledDateList = shuffle(dateList);
			localStorage.setItem("shuffledDateList", JSON.stringify(shuffledDateList));
		}
		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusDatesRecall(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br /><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString //+ "<span id='spanShift'><span onclick='shiftDataForward()'>+</span>&nbsp;<span onclick='shiftDataBackward()'>-</span></span>";

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}


		//add the recall content
		for (i = 0; i < numberOfPages; i++) {
			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i + "Recall");
			//add table to hold the words
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "datesRecallTable");
			//add rows with cells
			for (j = 0; j < datesPerPage; j++) {
				var row = document.createElement("tr");
				var thisIndex = i * datesPerPage + j;
				if (thisIndex < dateList.length) {
					var yearCell = document.createElement("td");
					var yearInput = document.createElement("input");
					var eventCell = document.createElement("td");
					yearInput.setAttribute("id", "inpRecall" + thisIndex);
					yearInput.setAttribute("size", 4);
					yearInput.setAttribute("maxlength", 4);
					eventCell.innerHTML = shuffledDateList[thisIndex].event;
					row.setAttribute("id", "trRecall" + thisIndex);
					yearInput.setAttribute("class", skin + "datesYearRecall");
					yearCell.setAttribute("class", skin + "datesRecallTD");
					eventCell.setAttribute("class", skin + "datesEventRecall");
					yearInput.thisIndex = thisIndex;
					yearInput.addEventListener("click", function (e) {
						moveFocusDatesRecall(e.target.thisIndex);
					});
					yearInput.addEventListener("dblclick", function (e) {
						toggleMark(e.target);
					});
					yearCell.appendChild(yearInput);
					row.appendChild(yearCell);
					row.appendChild(eventCell);
				}
				thisPageTable.appendChild(row);
			}
			pageDiv.appendChild(thisPageTable);
			document.getElementById("recallContentDiv").appendChild(pageDiv);
		}

		//***FINISH BUTTON kEpT fOr ReCall
		var button = document.createElement("button");
		button.setAttribute("class", "btn btn-primary finishBtn");
		button.addEventListener("click", finishRecall);
		button.innerText = "Finish";
		$("#finishBtnDiv").empty();
		document.getElementById("finishBtnDiv").appendChild(button);

		//restore data if resuming
		if (resuming) {

			restoreDatesData();

		}


		//go to first digits
		setTimeout(function () {
			moveFocusDatesRecall(0);
		}, 40);


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
			//ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
			//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveDatesData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);


			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();
			}

			//if tab (NOT RIGHT) is pressed, move on
			if (e.key == "Tab" && !e.shiftKey && !ended) {
				e.preventDefault();
				moveNextDatesRecall();
			}


			//if shift-tab is pressed to go back (NOT LEFT) ***shift-tab not working here or memo
			if (e.shiftKey && e.key == "Tab" && !ended) {
				e.preventDefault();
				movePreviousDatesRecall();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				movePreviousDatesRecall();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveNextDatesRecall();
			}

			//if backspace (8) is pressed and nothing in this box, go backwards
			/*
			if ((e.key == "Backspace") && !ended && document.getElementById("inpRecall" + curPos).value.length == 0) {
				e.preventDefault();
				movePreviousDatesRecall();
				document.getElementById("inpRecall" + curPos).focus();
			}
*/
		//if left arrow pressed, move left through word or (if at beginning) to previous box
		if (e.key == "ArrowLeft" && !ended) {
				//e.preventDefault();
				if (getCaretPosition(e.target) == 0) {
					e.preventDefault();					
					movePreviousDatesRecall();
					}
				}
			

			//if right arrow pressed, move right through word or (if at end) to next box
		if (e.key == "ArrowRight" && !ended) {
				
				if (getCaretPosition(e.target) == e.target.value.length) {
					e.preventDefault();
					if (e.target.id.indexOf("F") == -1) {
						moveNextDatesRecall();
					}
				}
			}


			//if [ is pressed, previous page
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusDatesRecall(datesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.') {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusDatesRecall(datesPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusDatesRecall(0);
			}

		};

	}


	function moveFocusDatesRecall(newPos) {

		if (newPos < amount) {
			//get current page
			curPage = Math.floor(newPos / datesPerPage);

			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == curPage) {
					document.getElementById("page" + i + "Recall").style.display = "block";
					if (numberOfPages > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i + "Recall").style.display = "none";
					if (numberOfPages > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
					}
				}
			}




		}

		if (!ended && newPos < amount) {
			document.getElementById("inpRecall" + newPos).focus();
		//	document.getElementById("inpRecall" + newPos).select();

			//un-highlight current date
			document.getElementById("inpRecall" + curPos).classList.remove(skin + "datesSelectedRecall");

			//highlight selected date

			document.getElementById("inpRecall" + newPos).classList.add(skin + "datesSelectedRecall");
		}

		curPos = newPos;

	}

	function moveNextDatesRecall() {

		//if we have reached end of list, don't move


		if (curPos < (amount - 1)) {



			moveFocusDatesRecall(curPos + 1);


		}
	}

	function movePreviousDatesRecall() {

		//if we are at start of list, don't move

		if (curPos > 0) {

			moveFocusDatesRecall(curPos - 1);


		}
	}




	function startNamesMemo(test) {
		
		ended = false;

		if (resuming) {
			//restore name list
			nameList = JSON.parse(localStorage.getItem("nameList"));
			facesAmount = Math.ceil(amount / 2);
		} else {
			if (!competitionMode || test) {
				assignFaceImages();
			}		
			localStorage.setItem("nameList", JSON.stringify(nameList));
		}

	

		namesPerPage = namesPerRow * nameRowsPerPage;
		curPos = 0;

		//work out how many pages needed 
		numberOfPages = Math.ceil(facesAmount / namesPerPage);


		//add the page menu if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablink' class='" + skin + "pagelink' onclick='moveFocusNamesMemo(" + namesPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/>";
			document.getElementById("menuDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuDiv").innerHTML = "";
		}


		//add the memo content
		for (var i = 0; i < numberOfPages; i++) {
			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i);

			//add table to hold the names
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "nameTable");

			//add rows with cells
			for (j = 0; j < nameRowsPerPage; j++) {
				var faceRow = document.createElement("tr");
				var nameRow = document.createElement("tr");

				for (k = 0; k < namesPerRow; k++) {
					var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
					if (thisIndex < nameList.length) {
						var faceCell = document.createElement("td");
						faceCell.classList.add("faceMemo");
						var faceImg = document.createElement("img");
						//**debug
						if (!nameList[thisIndex]) console.log(thisIndex);
//						faceImg.setAttribute("src", actualImages[thisIndex].src);
faceImg.setAttribute("src", nameList[thisIndex].imageURL);
					
						if (competitionMode) {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "128");
						} else {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "101.5");
						}

						console.log(faceImg);
						var nameCell = document.createElement("td");
						nameCell.innerHTML = nameList[thisIndex].firstname + " " + nameList[thisIndex].surname;
						nameCell.classList.add("nameMemo");
						nameCell.classList.add(skin + "nameMemo");

						faceCell.appendChild(faceImg);
						faceCell.setAttribute("id", "tdFace" + thisIndex);
						nameCell.setAttribute("id", "tdMemo" + thisIndex);

					}
					nameRow.appendChild(nameCell);
					faceRow.appendChild(faceCell);
				}
				thisPageTable.appendChild(faceRow);
				thisPageTable.appendChild(nameRow);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("memoContentDiv").appendChild(pageDiv);
		}

		//go to first word
		moveFocusNamesMemo(0);

		//set current position
		curPos = 0;
		


		r = document.getElementById(skin + 'MemoTimeInner');
		if (!test) {
			//set the timer
			var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
			memoStart = Date.now();
			(function f() {
				memoTimeDiff = Date.now() - memoStart + Number(timeElapsed);
				r.textContent = timeFormat(memoTime * 1e3 - memoTimeDiff);

				//save the elapsed time every second
				localStorage.setItem("timeElapsed", memoTimeDiff);

				//When timer reaches 0, go to recall
				if (memoTimeDiff / 1e3 >= memoTime) {

					finishMemo();
				}
				//Otherwise repeat this function
				else {
					if (!ended) {
						myTimer = setTimeout(f, 1000);
					}
				}
			})();
		} else {
			r.textContent = "";
	//		$('#overlayDiv').html('<span id="alert">Press Enter to exit test</span>');
//			$('#alert').fadeOut(2500, "linear");
		}

		document.onkeydown = function (e) {
			//If Enter is pressed in speed cards (during testing - for any event)
			//  if (currentDiscipline == "SC" && e.keyCode == 13 && !ended) {
			if (e.key == "Enter" && !ended) {
				finishMemo(test);
			}

			//if right arrow or tab pressed, move on
			if ((e.key == "ArrowRight" || (e.key == "Tab" && !e.shiftKey)) && !ended) {
				e.preventDefault();
				moveNextNamesMemo();
			}


			//if left arrow or shift-tab is pressed to go back
			if ((e.key == "ArrowLeft" || (e.shiftKey && e.key == "Tab")) && !ended) {
				e.preventDefault();
				movePreviousNamesMemo();
			}


			//if up arrow pressed, move back namesPerRow
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveFocusNamesMemo(curPos - namesPerRow);
			}

			//if down arrow pressed, move forward namesPerRow
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveFocusNamesMemo(curPos + namesPerRow);
			}


			//if [ is pressed, previous page
			if (e.key == ',') {

				if (curPage > 0) moveFocusNamesMemo(namesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < numberOfPages - 1) moveFocusNamesMemo(namesPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusNamesMemo(0);
			}
		};

	}

	function openNamesFile() {

		if (window.XMLHttpRequest) {// code for IE7+, Firefox, Chrome, Opera, Safari
			xmlhttp = new XMLHttpRequest();
		}
		else {// code for IE6, IE5
			xmlhttp = new ActiveXObject("Microsoft.XMLHTTP");
		}
		xmlhttp.open("GET", "Training data/names-training.xml", false);
		xmlhttp.send();
		fobNamesDoc = xmlhttp.responseXML;

	}

	function accent_fold (s) {
  if (!s) { return ''; }
  var ret = '';
  for (var i = 0; i < s.length; i++) {
    ret += accentMap[s.charAt(i)] || s.charAt(i);
  }
  return ret;
}

	function generateNamesandFaces() {
		
		nameList = [];
		facesAmount = Math.ceil(amount / 2);
		var regions = [
			['English', 'Welsh', 'Scottish', 'Scottish Gaelic', 'Manx'], // region 0
			['Swedish', 'Dutch', 'Italian', 'French', 'German', 'Danish', 'Icelandic', 'Norwegian', 'Irish', 'Breton', 'Russian', 'Lithuanian', 'Hungarian', 'Greek', 'Finnish', 'Czech', 'Slovak', 'Croatian', 'Polish', 'Macedonian', 'Albanian', 'Estonian', 'Serbian', 'Slovenian', 'Romanian', 'Ukrainian'], //region 1
			['Arabic', 'Hebrew', 'Jewish', 'Israeli', 'Persian', 'Pashto', 'Turkish', 'Egyptian'], //region 2
			['Chinese', 'Japanese', 'Korean', 'Chinese (HK)', 'Chinese (Taiwan)', 'Manchu'], //region 3
			['Fijian', 'Aboriginal', 'Chinese (Singapore)', 'Indonesian', 'Thai', 'Cambodian', 'Vietnamese', 'Filipino', 'Polynesian', 'Hawaiian', 'Samoan'], //region 4
			['Indian', 'Indian (Kashmir)', 'Gujarati','Indian (Maratha)','Telugu', 'Armenian', 'Azerbaijani', 'Georgian', 'Nepali', 'Nepalese', 'Bengali', 'Mongolian'],		//region 5
			['African', 'Yoruba', 'Kenyan', 'Nigerian', 'Igbo', 'Wolof', 'West African', 'Akan', 'Central African', 'Serer', 'Tiv', 'Ethiopian', 'Afrikaans','South African','Nguni','Ghanaian'], //region 6
			['Spanish', 'Portuguese', 'Valencian', 'Basque', 'Catalan'] //region 7
		]
		var maleNodes;
		var femaleNodes;
		var surnameNodes;
		males = [];
		females = [];
		surnames = [];
		var maleNodesFromRegion;
		var femaleNodesFromRegion;
		var surnameNodesRegion;
		var malesFromRegion;
		var femalesFromRegion;
		var surnamesFromRegion;
		var longMales;
		var longFemales;
		var longSurnames;
		var longMalesFromRegion = [];
		var longFemalesFromRegion = [];
		var longSurnamesFromRegion = [];
		numberOfMales = Math.ceil(facesAmount / 2);
		numberOfFemales = numberOfMales;

		numberOfMalesFromRegion = Math.ceil(facesAmount / regions.length / 2);//Math.ceil(amount/12); //for 6 regions and then half of that		
		numberOfFemalesFromRegion = numberOfMalesFromRegion;
		numberOfSurnamesFromRegion = Math.ceil(facesAmount / regions.length);// Math.ceil(amount/6); //for 6 regions

		var longNames = (currentDiscipline == '5N') ? 12 : 24;

		//distribute long names
		for (i = 0; i < longNames; i++) {
		  switch(Math.floor(Math.random() * 3)) {
		    case 0:
			longMales++;
			break;
			case 1:
			longFemales++;
			break;
			case 2:
			longSurnames++;
		  }
		}


		function getRegionString(num) {
			var str = "(";
			regions[num].forEach(function (el) {
				str += "nationality ='" + el + "' or ";
			});
			return str.slice(0, str.length - 4) + ")";
		}

		//do random numbers to decide what region each of the longMales, longFemales and longSurnames will be from
		var longFemaleRegions = new Array(regions.length).fill(0);
		var longMaleRegions = new Array(regions.length).fill(0);
		var longSurnameRegions = new Array(regions.length).fill(0);


		for (let i = 0; i < longMales; i++) {
			longMaleRegions[Math.floor(Math.random() * regions.length)]++;
		}
		for (let i = 0; i < longFemales; i++) {
			longFemaleRegions[Math.floor(Math.random() * regions.length)]++;
		}
		for (let i = 0; i < longSurnames; i++) {
			longSurnameRegions[Math.floor(Math.random() * regions.length)]++;
		}
		console.log(longMaleRegions);
		console.log(longFemaleRegions);
		console.log(longSurnameRegions);
		for (var i = 0; i < regions.length; i++) {
			//get names from regions
			maleNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 'm' and " + getRegionString(i) + "]");
			console.log(maleNodesFromRegion.length);
			malesFromRegion = maleNodesFromRegion.map(function (x) {
				return bunchup(GetChildNodeValueIfExists(x, "nametext"));
			});
			shuffle(malesFromRegion);
			console.log(malesFromRegion);

			//filter out long males - remove from malesFromRegion and, if longregions[i]>0, save in a new array
			console.log(malesFromRegion.length + " males from region " + i);
			malesFromRegion = malesFromRegion.filter(function (x) {
				if (longMaleRegions[i] > 0 && x.length >= 8) {
					longMalesFromRegion.push(x);
				}
				return x.length < 8;
			});
			console.log(malesFromRegion.length + " short males from region");

			console.log(longMalesFromRegion);
			//for 1 to longMaleRegions[i], add one (at the start) from longMalesFromRegion  and remove it from list of long names
			for (let l = 0; l < longMaleRegions[i]; l++) {
				var longMaleIndex = Math.floor(Math.random() * longMalesFromRegion.length);
				malesFromRegion.unshift(longMalesFromRegion[longMaleIndex]);
				longMalesFromRegion.splice(longMaleIndex, 1)
			}
			longMalesFromRegion = [];
			console.log(malesFromRegion.length + " final males from region " + i);
			//end of filtering part

			malesFromRegion = malesFromRegion.splice(0, numberOfMalesFromRegion);
			males = males.concat(malesFromRegion);

			femaleNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 'f' and " + getRegionString(i) + "]");
			console.log(femaleNodesFromRegion.length);
			femalesFromRegion = femaleNodesFromRegion.map(function (x) {
				return bunchup(GetChildNodeValueIfExists(x, "nametext"));
			});
			shuffle(femalesFromRegion);
			console.log(femalesFromRegion);

			//filter out long females - remove from femalesFromRegion and, if longregions[i]>0, save in a new array
			console.log(femalesFromRegion.length + " females from region " + i);
			femalesFromRegion = femalesFromRegion.filter(function (x) {
				if (longFemaleRegions[i] > 0 && x.length >= 8) {
					longFemalesFromRegion.push(x);
				}
				return x.length < 8;
			});

			console.log(femalesFromRegion.length + " short females from region " + i);

			console.log(longFemalesFromRegion);
			if (longFemaleRegions[i] > 0 && longFemalesFromRegion.length == 0) {
				alert("not enough long females in region " + i);
			}
			//for 1 to longFemaleRegions[i], add one (at the start) from longFemalesFromRegion  and remove it from list of long names
			for (let l = 0; l < longFemaleRegions[i]; l++) {
				var longFemaleIndex = Math.floor(Math.random() * longFemalesFromRegion.length);
				femalesFromRegion.unshift(longFemalesFromRegion[longFemaleIndex]);
				longFemalesFromRegion.splice(longFemaleIndex, 1)

			}
			longFemalesFromRegion = [];
			console.log(femalesFromRegion.length + " final females from region " + i);
			//end of filtering part

			femalesFromRegion = femalesFromRegion.splice(0, numberOfFemalesFromRegion);
			females = females.concat(femalesFromRegion);

			surnameNodesFromRegion = SelectNodes(fobNamesDoc, "//name[type = 's' and  " + getRegionString(i) + "]");
			console.log(surnameNodesFromRegion.length);
			surnamesFromRegion = surnameNodesFromRegion.map(function (x) {
				return bunchup(GetChildNodeValueIfExists(x, "nametext"));
			});
			shuffle(surnamesFromRegion);
			console.log(surnamesFromRegion);

			//filter out long surnames - remove from surnamesFromRegion and, if longregions[i]>0, save in a new array
			console.log(surnamesFromRegion.length + " surnames from region " + i);
			surnamesFromRegion = surnamesFromRegion.filter(function (x) {
				if (longSurnameRegions[i] > 0 && x.length >= 8) {
					longSurnamesFromRegion.push(x);
				}
				return x.length < 8;
			});

			console.log(surnamesFromRegion.length + " short surnames from region " + i);

			console.log(longSurnamesFromRegion);
			//for 1 to longSurnameRegions[i], add one (at the start) from longSurnamesFromRegion, and remove it from list of long names
			for (let l = 0; l < longSurnameRegions[i]; l++) {
				var longSurnameIndex = Math.floor(Math.random() * longSurnamesFromRegion.length);
				surnamesFromRegion.unshift(longSurnamesFromRegion[longSurnameIndex]);
				longSurnamesFromRegion.splice(longSurnameIndex, 1)

			}
			longSurnamesFromRegion = [];
			console.log(surnamesFromRegion.length + " final surnames from region " + i);
			//end of filtering part

			surnamesFromRegion = surnamesFromRegion.splice(0, numberOfSurnamesFromRegion);
			surnames = surnames.concat(surnamesFromRegion);
		}
		//Western Europe
		//'English','Swedish','Basque','Spanish','Portuguese','Dutch','Italian','French','German','Catalan','Valencian','Danish','Icelandic','Norwegian','Irish','Welsh','Breton','Scottish','Scottish Gaelic','Manx'

		//Eastern Europe
		//Russian, Lithuanian, Hungarian, Greek, Finnish, Czech, Slovak, Croatian, Polish, Macedonian, Albanian, Estonian, Serbian, Slovenian, Romanian, Ukrainian

		//Africa
		//Yoruba, Kenyan, Nigerian, Igbo

		//Middle East
		//Arabic, Hebrew, Jewish, Israeli, Persian/Farsi, Pashto, Turkish

		//South-east Asia/Oceania
		//Fijian, Aboriginal, Chinese (Singapore), Indonesian, Thai, Cambodian, Vietnamese

		//Western Asia (Indo-Iranian and others)
		//Indian, Indian (Kashmir), Indian (Maratha), Mongolian, Armenian, Azerbaijani, Georgian, Nepalese

		//East Asia
		//Chinese, Japanese, Korean, Chinese (HK), Chinese (Taiwan)

		shuffle(males);
		shuffle(females);
		shuffle(surnames);

		for (i = 0; i < males.length; i++) {

			nameList[i] = new nameObject();
			nameList[i].imageURL = "";
			nameList[i].firstname = males[i].trim();
			nameList[i].gender = "male";

		}

		for (i = males.length; i < males.length + females.length; i++) {

			nameList[i] = new nameObject();
			nameList[i].imageURL = "";
			nameList[i].firstname = females[i - males.length].trim();
			nameList[i].gender = "female";

		}

		//Alert if not enough in our database
		if (nameList.length < facesAmount) {
			alert("not enough names in database");
			return;
		}


		shuffle(nameList);

		//Truncate array to just amount required (to take into account the odd one or two left over from Math.ceil because cannot divide exactly by 6)
		nameList = nameList.splice(0, facesAmount);

		//Add surnames 
		for (i = 0; i < nameList.length; i++) {


			nameList[i].surname = surnames[i].trim();


		}


		//Download numberofMales and numberofMales in two separate API calls
		//images from https://randomuser.me/
/*
		$.ajax({
			url: "https://randomuser.me/api/?results=" + (numberOfMales * 2) + "&format=json&gender=male",
			dataType: 'jsonp',
			success: function (data) {

				maleImageArray = [];
				//alert(data.results[1].gender);
				$.each(data.results, function (i, result) {

					if (numberOfMales > 0) {

						alreadyExists = false;
						//console.log(result.picture.large);
						for (j = 0; j < maleImageArray.length; j++) {
							if (result.picture.large == maleImageArray[j]) {
								alreadyExists = true;
							}
						}
						if (!alreadyExists) {
							var img = new Image();
							img.src = result.picture.large;
							if (isImageOK(img)) {
								maleImageArray.push(result.picture.large);
							}
						}

					}

				});

			}


		});


		$.ajax({
			url: "https://randomuser.me/api/?results=" + (numberOfFemales * 2) + "&format=json&gender=female",
			dataType: 'jsonp',
			success: function (data) {
				femaleImageArray = [];
				//alert(data.results[1].gender);
				$.each(data.results, function (i, result) {

					if (numberOfFemales > 0) {

						alreadyExists = false;
						//console.log(result.picture.large);
						for (j = 0; j < femaleImageArray.length; j++) {
							if (result.picture.large == femaleImageArray[j]) {
								alreadyExists = true;
							}
						}
						if (!alreadyExists) {
							var img = new Image();
							img.src = result.picture.large;
							if (isImageOK(img)) {
								femaleImageArray.push(result.picture.large);
							}
						}

					}

				});

			}
		});

*/

		//Get numberOfMales and numberOfFemales from folder
		maleImageArray = [];
		femaleImageArray = [];
		var proposedImage;

		//Get males
		for (var i = 0; i < numberOfMales; i++) {
			proposedImage = Math.floor(Math.random() * 100) + 1;
			while (maleImageArray.indexOf(proposedImage)>-1) {
				proposedImage = Math.floor(Math.random() * 100) + 1;
			}
			maleImageArray.push(proposedImage);
		}


		//Get females
		for (var i = 0; i < numberOfFemales; i++) {
			proposedImage = Math.floor(Math.random() * 99) + 1;
			while (femaleImageArray.indexOf(proposedImage)>-1) {
				proposedImage = Math.floor(Math.random() * 99) + 1;
			}
			femaleImageArray.push(proposedImage);
		}

		//preload images
		var imagesLoaded = 0;
	    actualImages = [];
		for (let im = 0; im < femaleImageArray.length; im++) {

			actualImages[im] = new Image();
			actualImages[im].src = "Training data/f/Females (" + femaleImageArray[im] + ").jpg";
			//actualImageArray[im].onload = function() {console.log(imagesLoaded++)};
		}

		for (let im = actualImages.length; im < femaleImageArray.length + maleImageArray.length; im++) {

			actualImages[im] = new Image();
			actualImages[im].src = "Training data/m/Males (" + maleImageArray[im-femaleImageArray.length] + ").jpg";
			//actualImageArray[im].onload = function() {console.log(imagesLoaded++)};
		}


		//Shuffle again for memo
		shuffle(nameList);


	}

	function isImageOK(img) {
		if (img.complete && img.naturalWidth == 0) {
			return false;
		}
		return true;
	}

	function bunchup(name) {
		name = name.replace(/\s\w|-\w/g, function (l) {
			return l.charAt(1).toUpperCase() + l.slice(2);
		});
		return name;
	}

	
function assignFaceImages() {
		
		maleImageIndex = 0;
		femaleImageIndex = 0;
	
	for (i = 0; i < nameList.length; i++) {
		if (nameList[i].gender == "male") {
			nameList[i].imageURL = actualImages[femaleImageArray.length+maleImageIndex].src;
		maleImageIndex++;
		}
		else {
			nameList[i].imageURL = actualImages[femaleImageIndex].src;
		femaleImageIndex++;
		}
	}
	
	
}

	function nameObject() {
		this.imageURL = "";
		this.firstname = "";
		this.surname = "";
		this.gender = "";
	}


	function moveFocusNamesMemo(newPos) {
		if (newPos < facesAmount && newPos >= 0) {
			//remove highlight from existing face
			//	document.getElementById("tdMemo" + curPos).classList.remove(skin + "namesSelected");
			document.getElementById("tdMemo" + curPos).classList.remove(skin + "namesSelectedRecall");
			document.getElementById("tdFace" + curPos).classList.remove(skin + "namesSelectedRecall");

			//get new page
			var newPage = Math.floor(newPos / namesPerPage);
			if (newPage != curPage || curPos == 0) {


				//show/hide correct pages
				for (var i = 0; i < numberOfPages; i++) {
					if (i == newPage) {
						document.getElementById("page" + i).style.display = "block";
						if (numberOfPages > 1) {
							//highlight this page tab
							document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
						}
					}
					else {
						document.getElementById("page" + i).style.display = "none";
						if (numberOfPages > 1) {
							//un-highlight this page tab
							document.getElementById("page" + i + "tablink").className = skin + "pagelink";
						}
					}
				}
				curPage = newPage;
			}

			document.getElementById("tdMemo" + newPos).classList.add(skin + "namesSelectedRecall");
			document.getElementById("tdFace" + newPos).classList.add(skin + "namesSelectedRecall");
			curPos = newPos;
		}
	}

	function moveNextNamesMemo() {
		if (!ended && curPos < facesAmount - 1) {
			moveFocusNamesMemo(curPos + 1);
		}
	}

	function movePreviousNamesMemo() {
		if (curPos > 0 && !ended) {
			moveFocusNamesMemo(curPos - 1);
		}
	}

	function GetChildNodeValueIfExists(pNode, pNodeName) {
		if (NodeExists(pNode, pNodeName)) {

			return pNode.getElementsByTagName(pNodeName)[0].innerHTML;
		} else {
			return "";
		}
	}

	function NodeExists(pNode, pChildNodeName) {

		for (var i = 0; i < pNode.childNodes.length; i++) {

			if (pNode.childNodes[i].nodeName == pChildNodeName) {
				return true;
			}
		}
		return false;
	}

	function SelectNodes(xmlDoc, elementPath) {
		if (document.implementation && document.implementation.createDocument) {

			var nodes = xmlDoc.evaluate(elementPath, xmlDoc, null, XPathResult.ANY_TYPE, null);
			//var results=nodes.iterateNext();

			var arrResults = [];
			var theResult = nodes.iterateNext();

			while (theResult) {
				arrResults.push(theResult);
				theResult = nodes.iterateNext();
			}
			return arrResults;
		}
	}

	function SelectSingleNode(xmlDoc, xmlNode, elementPath) {
		if (document.implementation && document.implementation.createDocument) {

			var nodes = xmlDoc.evaluate(elementPath, xmlNode, null, XPathResult.ANY_TYPE, null);
			var results = nodes.iterateNext();

			return results;
		}
	}


	function generateWordList() {

		//Clear wordList array
		wordList = [];
		
		var databaseString = " and source='TR'";
		var numberOfCNs = Math.ceil((percOfCNs / 100) * amount);
		var numberOfANs = Math.ceil((percOfANs / 100) * amount);
		var numberOfVs = Math.ceil((percOfVs / 100) * amount);

		//Get the concrete nouns
		var allnodes = SelectNodes(fobWordsDoc, "//word[type='c' " + databaseString + "]");
		shuffle(allnodes);
		var nodes = allnodes.slice(0, numberOfCNs);
		//loop through nodes and add to wordList array
		for (i = 0; i < nodes.length; i++) {
			wordList.push(GetChildNodeValueIfExists(nodes[i], "wordtext"));
		}
	
		//Get the abstract nouns
		allnodes = SelectNodes(fobWordsDoc, "//word[type='a'" + databaseString + "]");
		shuffle(allnodes);
		nodes = allnodes.slice(0, numberOfANs);
		//loop through nodes and add to wordList array
		for (i = 0; i < nodes.length; i++) {
			var thisWord = GetChildNodeValueIfExists(nodes[i], "wordtext")
			//check not already there
			var counter = numberOfANs;
			while (wordList.indexOf(thisWord) > -1) {
				thisWord = GetChildNodeValueIfExists(allnodes[counter], "wordtext");
				counter++;
				if (counter == allnodes.length - 1) {
					break;
				}
			}
			wordList.push(thisWord);
		}

		//Get the verbs
		allnodes = SelectNodes(fobWordsDoc, "//word[type='v'" + databaseString + "]");
		shuffle(allnodes);
		nodes = allnodes.slice(0, numberOfVs);
		//loop through nodes and add to wordList array
		for (i = 0; i < nodes.length; i++) {
			var thisWord = GetChildNodeValueIfExists(nodes[i], "wordtext")
			//check not already there
			var counter = numberOfVs;
			while (wordList.indexOf(thisWord) > -1) {
				thisWord = GetChildNodeValueIfExists(allnodes[counter], "wordtext");
				counter++;
				if (counter == allnodes.length - 1) {
					break;
				}
			}
			wordList.push(thisWord);
		}


		shuffle(wordList);
		wordList = wordList.slice(0, amount);

	}


	function getWordList(array) {
		var wordString = "";

		document.getElementById("wordListView").style = "font-family: 'Arial', serif";
		wordString = "<table>";

		for (i = 0; i < wordList.length; i++) {
			wordString += "<tr><td>" + (i + 1) + ". " + wordList[i] + "</td></tr>";
		}
		wordString += "</table>";
		return wordString;
	}




	function moveFocusWordsMemo(newPos) {
		//get first of grouping
		var firstOfGroup = curPos - (curPos % grouping);


		//remove highlight from existing grouping
		document.getElementById("tdMemo" + firstOfGroup).className = skin + "wordsMemo";
		document.getElementById("tdMemo" + firstOfGroup).style.backgroundColor = "";
		for (var i = 1; i < grouping; i++) {
			if (firstOfGroup < wordList.length - i) {
				document.getElementById("tdMemo" + (firstOfGroup + i)).className = skin + "wordsMemo";
				document.getElementById("tdMemo" + (firstOfGroup + i)).style.backgroundColor = "";
			}

		}

		//get new page
		var newPage = Math.floor(newPos / wordsPerPage);
		if (newPage != curPage || curPos == 0) {


			//show/hide correct pages
			for (var i = 0; i < numberOfPages; i++) {
				if (i == newPage) {
					document.getElementById("page" + i).style.display = "block";
					if (numberOfPages > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i).style.display = "none";
					if (numberOfPages > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablink").className = skin + "pagelink";
					}
				}
			}
			curPage = newPage;
		}
		if (newPos < amount) {

			//update firstOfGroup
			if ((newPos == 0) || (newPos % grouping == 0)) {

				firstOfGroup = newPos;

			}
			else {
				firstOfGroup = newPos - (newPos % grouping);

			}

			//set new pos to first in group - if user has clicked on a digit or new page, need to only highlight from first in group
			newPos = firstOfGroup;



			document.getElementById("tdMemo" + (firstOfGroup)).className = skin + "wordsMemo " + skin + "wordsSelected";
			// document.getElementById("tdMemo" + (firstOfGroup)).style.backgroundColor = this[hiColour];

			for (var i = 1; i < grouping; i++) {
				if (firstOfGroup < wordList.length - i) {
					document.getElementById("tdMemo" + (Number(firstOfGroup + i))).className = skin + "wordsMemo " + skin + "wordsSelected";
					//  document.getElementById("tdMemo" + (Number(firstOfGroup + i))).style.backgroundColor = this[hiColour];
				}
			}

			curPos = newPos;
		}
	}



	function moveNextWordsMemo() {
		if (!ended && curPos + grouping < amount) {
			moveFocusWordsMemo(curPos + grouping);
		}
	}

	function movePreviousWordsMemo() {
		if (curPos >= grouping && !ended) {
			moveFocusWordsMemo(curPos - grouping);
		}
	}




	function startWordsRecall() {
		ended = false;


		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			wordsPerPage = wordsPerColumn * wordColumnsPerPage;
			numberOfPages = Math.ceil(amount / wordsPerPage); //added in case went straight to recall

			//restore data
			wordList = JSON.parse(localStorage.getItem("correctAnswers"));
		}

		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusWordsRecall(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br /><br /><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString //+ "<span id='spanShift'><span onclick='shiftDataForward()'>+</span>&nbsp;<span onclick='shiftDataBackward()'>-</span></span>";

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}


		//add the recall content
		for (i = 0; i < numberOfPages; i++) {


			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i + "Recall");

			//add table to hold the words
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "wordsRecallTable");

			//add rows with cells
			for (j = 0; j < wordsPerColumn; j++) {
				var row = document.createElement("tr");
				for (k = 0; k < wordColumnsPerPage; k++) {
					var wordCell = document.createElement("td");
					var wordInput = document.createElement("input");

					var numberCell = document.createElement("td");
					var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

					if (thisIndex < wordList.length) {
						numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
						numberCell.setAttribute("class", skin + "wordsNum");
						wordInput.setAttribute("id", "inpRecall" + thisIndex);
						wordInput.setAttribute("class", skin + "wordsRecall");
						wordInput.thisIndex = thisIndex;
						wordInput.addEventListener("click", function (e) {
							moveFocusWordsRecall(e.target.thisIndex);
						});
						wordInput.addEventListener("dblclick", function (e) {
							toggleMark(e.target);
						});

						wordCell.setAttribute("class", skin + "wordsRecallTD");
						wordCell.setAttribute("id", "tdRecall" + thisIndex);
						wordCell.appendChild(wordInput);
					}

					row.appendChild(numberCell);
					row.appendChild(wordCell);
				}
				thisPageTable.appendChild(row);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("recallContentDiv").appendChild(pageDiv);

		}


		//***FINISH BUTTON kEpT fOr ReCall
		var button = document.createElement("button");
		button.setAttribute("class", "btn btn-primary finishBtn");
		button.addEventListener("click", finishRecall);
		button.innerText = "Finish";
		$("#finishBtnDiv").empty();
		document.getElementById("finishBtnDiv").appendChild(button);


		//restore data if resuming
		if (resuming) {

			restoreWordsData();
			restoreMarks();
		}

		//go to first digits


		setTimeout(function () {
			moveFocusWordsRecall(0);
		}, 40);


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
			//ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
			//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveWordsData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);

			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {
				finishRecall();

			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();


			}

			//if tab is pressed (NOT RIGHT), move on
			if (e.key == "Tab" && !ended && !e.shiftKey) {
				e.preventDefault();
				moveNextWordsRecall();
			}


			//if shift-tab is pressed (NOT LEFT) to go back ***shift-tab not working here or memo
			if (e.shiftKey && e.key == "Tab" && !ended) {
				e.preventDefault();
				movePreviousWordsRecall();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				movePreviousWordsRecall();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveNextWordsRecall();
			}

			//if backspace (8) is pressed and nothing in this box, go backwards
		/*	if ((e.key == "Backspace") && !ended && document.getElementById("inpRecall" + curPos).value.length == 0) {
				e.preventDefault();
				movePreviousWordsRecall();
				document.getElementById("inpRecall" + curPos).focus();
			}*/

			//If + is pressed
			if ((e.key == '+' || e.key == '=') && !ended) {
				e.preventDefault();
				shiftWordsForward();

			}

			//If - is pressed
			if ((e.key == '-' || e.key == '-') && !ended) {

				e.preventDefault();
				shiftWordsBackward();

			}


		//if left arrow pressed, move left through word or (if at beginning) to previous box
		if (e.key == "ArrowLeft" && !ended) {
				//e.preventDefault();
				if (getCaretPosition(e.target) == 0) {
					e.preventDefault();					
					movePreviousWordsRecall();
					}
				}
			

			//if right arrow pressed, move right through word or (if at end) to next box
		if (e.key == "ArrowRight" && !ended) {
				
				if (getCaretPosition(e.target) == e.target.value.length) {
					e.preventDefault();
					if (e.target.id.indexOf("F") == -1) {
						moveNextWordsRecall();
					}
				}
			}


			//if [ is pressed, previous page
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusWordsRecall(wordsPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.') {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusWordsRecall(wordsPerPage * (curPage + 1));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusWordsRecall(0);
			}

		};


	}

	function moveFocusWordsRecall(newPos) {

		//get current page
		curPage = Math.floor(newPos / wordsPerPage);


		//show/hide correct pages
		for (var i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
				}
			}
		}


		if (!ended) {
			//get first of grouping
			var firstOfGroup = curPos - (curPos % grouping);


			if (newPos < amount) {
				document.getElementById("inpRecall" + newPos).focus();
				//document.getElementById("inpRecall" + newPos).select();

				//un-highlight current group
				document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
				document.getElementById("inpRecall" + firstOfGroup).classList.remove(skin + "wordsSelectedRecall");
				document.getElementById("inpRecall" + firstOfGroup).classList.remove(skin + "wordsInGroup");
				for (var i = 1; i < grouping; i++) {
					if (firstOfGroup < amount - i) {
						document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
						document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "wordsSelectedRecall");
						document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "wordsInGroup");
					}
				}

				//update firstOfGroup

				firstOfGroup = newPos - (newPos % grouping);

				//highlight selected word and also other words in group (different colour)


				document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
				document.getElementById("inpRecall" + (firstOfGroup)).classList.add(skin + "wordsInGroup");
				for (var i = 1; i < grouping; i++) {
					if (firstOfGroup < amount - i) {
						document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
						document.getElementById("inpRecall" + (firstOfGroup + i)).classList.add(skin + "wordsInGroup");
					}
				}

				document.getElementById("inpRecall" + newPos).classList.add(skin + "wordsSelectedRecall");
			}
		}



		curPos = newPos;





	}

	function moveNextWordsRecall() {

		//if we have reached end of list, don't move

		if (curPos < (amount - 1)) {



			moveFocusWordsRecall(curPos + 1);


		}
	}

	function movePreviousWordsRecall() {

		//if we are at start of list, don't move

		if (curPos > 0) {

			moveFocusWordsRecall(curPos - 1);


		}
	}


	function shiftWordsForward() {

		for (var i = amount - 1; i >= curPos + 1; i--) {
			document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
			if (document.getElementById("inpRecall" + Number(i - 1)).classList.contains("markOther")) {
				document.getElementById("inpRecall" + Number(i - 1)).classList.remove("markOther");
				document.getElementById("inpRecall" + i).classList.add("markOther");
			} else {
				document.getElementById("inpRecall" + i).classList.remove("markOther");
			}
		}


		document.getElementById("inpRecall" + (curPos)).value = "";
		document.getElementById("inpRecall" + (curPos)).classList.remove("markOther");


	}

	function shiftWordsBackward() {
		document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + Number(curPos + 1)).value;
		if (document.getElementById("inpRecall" + Number(curPos + 1)).classList.contains("markOther")) {
			document.getElementById("inpRecall" + Number(curPos + 1)).classList.remove("markOther");
			document.getElementById("inpRecall" + curPos).classList.add("markOther");
		}


		for (var i = curPos + 1; i < amount - 1; i++) {

			document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
			if (document.getElementById("inpRecall" + Number(i + 1)).classList.contains("markOther")) {
				document.getElementById("inpRecall" + Number(i + 1)).classList.remove("markOther");
				document.getElementById("inpRecall" + i).classList.add("markOther");
			}

		}
		document.getElementById("inpRecall" + (amount - 1)).value = "";
		document.getElementById("inpRecall" + (amount - 1)).classList.remove("markOther");

	}


	function startNamesRecall() {
		ended = false;

		//in dates it's just hidden
		//document.getElementById("spanShift").style.display = "none";

		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			facesAmount = Math.ceil(amount / 2);
			namesPerPage = namesPerRow * nameRowsPerPage;
			numberOfPages = Math.ceil(facesAmount / namesPerPage); //added in case went straight to recall
			//restore data		
			nameList = JSON.parse(localStorage.getItem("nameList"));
			shuffledNameList = JSON.parse(localStorage.getItem("shuffledNameList"));
		} else {
			//shuffle name list
			shuffledNameList = shuffle(nameList);
			//save it
			localStorage.setItem("shuffledNameList",JSON.stringify(shuffledNameList));
		}

		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNamesRecall(" + namesPerPage * i + ",true)'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}


		//add the recall content

		for (i = 0; i < numberOfPages; i++) {

			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i + "Recall");
			//add table to hold the names
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "nameTable");

			//add rows with cells
			for (j = 0; j < nameRowsPerPage; j++) {
				var faceRow = document.createElement("tr");
				var nameRow = document.createElement("tr");

				for (k = 0; k < namesPerRow; k++) {
					var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
					if (thisIndex < nameList.length) {
						var faceCell = document.createElement("td");
						faceCell.classList.add("faceMemo");
						var faceImg = document.createElement("img");

						faceImg.setAttribute("src", shuffledNameList[thisIndex].imageURL);
					
						if (competitionMode) {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "128");
						} else {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "101.5");
						}

						var nameCell = document.createElement("td");

						// nameCell.classList.add("nameRecallTD");
						// nameCell.classList.add(skin + "nameRecallTD");

						var nameInputFCell = document.createElement("input");
						nameInputFCell.classList.add("nameRecall");
						nameInputFCell.classList.add(skin + "nameRecall");
						nameInputFCell.setAttribute("id", "inpRecallF" + thisIndex);
						nameInputFCell.thisIndex = thisIndex;
						nameInputFCell.addEventListener("click", function (e) {
							moveFocusNamesRecall(e.target.thisIndex, true);
						});
						nameInputFCell.addEventListener("dblclick", function (e) {
							toggleMark(e.target);
						});

						var nameInputSCell = document.createElement("input");
						nameInputSCell.classList.add("nameRecall");
						nameInputSCell.classList.add(skin + "nameRecall");
						nameInputSCell.setAttribute("id", "inpRecallS" + thisIndex);
						nameInputSCell.thisIndex = thisIndex;
						nameInputSCell.addEventListener("click", function (e) {
							moveFocusNamesRecall(e.target.thisIndex, false);
						});
						nameInputSCell.addEventListener("dblclick", function (e) {
							toggleMark(e.target);
						});
						faceCell.appendChild(faceImg);
						faceCell.setAttribute("id", "tdFace" + thisIndex);

						
						nameCell.setAttribute("id", "tdRecall" + thisIndex);

					}
					nameCell.appendChild(nameInputFCell);
					nameCell.appendChild(nameInputSCell);
					nameRow.appendChild(nameCell);
					faceRow.appendChild(faceCell);
				}
				thisPageTable.appendChild(faceRow);
				thisPageTable.appendChild(nameRow);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("recallContentDiv").appendChild(pageDiv);



		}

		//***FINISH BUTTON kEpT fOr ReCall
		var button = document.createElement("button");
		button.setAttribute("class", "btn btn-primary finishBtn");
		button.addEventListener("click", finishRecall);
		button.innerText = "Finish";
		$("#finishBtnDiv").empty();
		document.getElementById("finishBtnDiv").appendChild(button);

		//restore data if resuming
		if (resuming) {
			restoreNamesData();
			restoreMarks();
		}

		//go to first digits
		setTimeout(function () {
			moveFocusNamesRecall(0, true);
		}, 40);


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}



		//set current position
		curPos = 0;

		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
			//ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
			//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveNamesData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);


			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();
			}

			//if  tab is pressed, move on
			if (e.key == "Tab" && !e.shiftKey && !ended) {
				e.preventDefault();
				console.log(e.target.id);
				if (e.target.id.indexOf("F") == -1) {
					moveNextNamesRecall();
				} else {
					//	document.getElementById("inpRecallS" + curPos).focus)();
					moveFocusNamesRecall(curPos, false);
				}
			}


			//if  shifttab is pressed to go back ***shift-tab not working here or memo
			if ((e.shiftKey && e.key == "Tab") && !ended) {
				e.preventDefault();
				if (e.target.id.indexOf("F") > -1) {
				
					movePreviousNamesRecall();
				} else {
				
					moveFocusNamesRecall(curPos, true);
				}
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveFocusNamesRecall(curPos - namesPerRow, true);
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveFocusNamesRecall(curPos + namesPerRow, true);
			}

			//if left arrow pressed, move left through word or (if at beginning) to previous box
				if (e.key == "ArrowLeft" && !ended) {
				//e.preventDefault();
				if (getCaretPosition(e.target) == 0) {
					e.preventDefault();
					if (e.target.id.indexOf("F") > -1) {						
						moveFocusNamesRecall(curPos-1, false);
					} else {


					moveFocusNamesRecall(curPos, true);
					}
				}
			}

			//if right arrow pressed, move right through word or (if at end) to next box
				if (e.key == "ArrowRight" && !ended) {
				
				if (getCaretPosition(e.target) == e.target.value.length) {
					e.preventDefault();
					if (e.target.id.indexOf("F") == -1) {
						moveNextNamesRecall();
					} else {
						//	document.getElementById("inpRecallS" + curPos).focus)();
						moveFocusNamesRecall(curPos, false);
					}
				}
			}

			//if [ is pressed, previous page
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusNamesRecall(namesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.') {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusNamesRecall(namesPerPage * (curPage + 1));

			}


			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusNamesRecall(0);
			}

/*
			//if backspace (8) is pressed and nothing in this box, go backwards
			if (e.key == "Backspace" && !ended && document.getElementById("inpRecallF" + curPos).value.length == 0) {
				e.preventDefault();
				if (e.target.id.indexOf("F") > -1) {
					movePreviousNamesRecall();

				} else {
					//	document.getElementById("inpRecallF" + curPos).focus();
					
					moveFocusNamesRecall(curPos, true);
				}
			}

*/

		};


	}


	function moveFocusNamesRecall(newPos, isFirstname = true) {
		if (!ended) {
			if (newPos < amount) {
			

				//un-highlight current name

				document.getElementById("inpRecallF" + curPos).classList.remove(skin + "namesSelectedRecall");
				document.getElementById("inpRecallS" + curPos).classList.remove(skin + "namesSelectedRecall");

				//highlight new one
				if (isFirstname) {
					document.getElementById("inpRecallF" + newPos).classList.add(skin + "namesSelectedRecall");
				} else {
					document.getElementById("inpRecallS" + newPos).classList.add(skin + "namesSelectedRecall");
				}
			}

		}
		//get current page
		curPage = Math.floor(newPos / namesPerPage);


		//show/hide correct pages
		for (var i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
				}
			}

			
			curPos = newPos;
			if (isFirstname) {
					document.getElementById("inpRecallF" + newPos).focus();
				//	document.getElementById("inpRecallF" + newPos).select();
				} else {
					document.getElementById("inpRecallS" + newPos).focus();
				//	document.getElementById("inpRecallS" + newPos).select();
				}

		}




	}

	function moveNextNamesRecall() {

		//if we have reached end of list, don't move

		if (curPos < (amount - 1)) {



			moveFocusNamesRecall(curPos + 1, true);


		}
	}

	function movePreviousNamesRecall() {

		//if we are at start of list, don't move

		if (curPos > 0) {

			moveFocusNamesRecall(curPos - 1, false);


		}
	}





	function finishMemo(test = false) {
		if (test)  {
			goToSettings();
			return;
		} 
		memoTimeTaken = Date.now() - memoStart;

		//Clear display
		document.getElementById("memoRow").style.display = "none";

		//set ended to true
		ended = true;
		clearTimeout(myTimer);
		resuming = false;

		localStorage.setItem("phase", "recall");
		localStorage.setItem("timeElapsed", "0");
		//Recall
		startRecallCountdown();

	}

	function startRecallCountdown() {
		//display correct sections
		document.getElementById("logoRow").style = "display:none";
		document.getElementById("topMargin").style = "display:block";
		document.getElementById("btnBackToSelection2").style = "display:none";

		/*
			//Show logo row if digital1
			if (skin.indexOf("analogue")===-1) {
					document.getElementById("logoRow").style="display:block";
					document.getElementById("topMargin").style="display:none";
			}
			else {
				document.getElementById("logoRow").style="display:none";
				document.getElementById("topMargin").style="display:block";
			}*/

		//Display countdown section only
		document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to countdown
		document.getElementById("countdownTable").style.display = 'none';
		document.getElementById("countdownRecallTable").style = "display:inline";
		document.getElementById("countdownRecallText").innerHTML = "";
		document.getElementById("countdownRecallTime").innerHTML = "";
		document.getElementById("countdownRow").style = "display:block";
		document.getElementById("memoRow").style = "display:none";
		// document.getElementById("countdownDisciplineTitle").innerHTML = lookupProperty(currentDiscipline,"label");

		//Get recall time
		recallTime = lookupProperty(currentDiscipline, "recallTime");

		if (resuming) {
			var titleElements = document.getElementsByClassName("countdownDisciplineTitle");
			var title = lookupProperty(currentDiscipline, "label");
			for (var i = 0; i < titleElements.length; i++) {
				titleElements[i].innerHTML = title;
			}
		}

		//Display countdown clock
		countSeconds = countdownSeconds;
		cint = setInterval(showSecondsR, 1000);
	}

	function showSecondsR() {
		document.getElementById("countdownRecallText").innerHTML = "Recall starts in: ";
		document.getElementById("countdownRecallTime").innerHTML = countSeconds;
		countSeconds--;
		if (countSeconds <= -1) {
			clearInterval(cint);
			startRecall();
			//localStorage.setItem("phase","recall");
		}
	}

	function startRecall() {

		//Display recall section only
		document.getElementById("countdownRow").style = "display:none";
		document.getElementById("recallRow").style = "display:block";

		//Display relevant memo depending on discipline
		switch (currentDiscipline) {
			case "5N":
			case "15N":
			case "30N":
			case "60N":
				startNumberRecall();
				break;
			case "5B":
			case "30B":
				startBinaryRecall();
				break;
			case "10C":
			case "30C":
			case "60C":
			case "SC":
				startCardRecall();
				break;
			case "D":
				startDatesRecall();
				break;
			case "5F":
			case "15F":
				startNamesRecall();
				break;
			case "5W":
			case "15W":
				startWordsRecall();
				break;
			case "S":
				startSpokenRecall();
			default:
				startImagesRecall();
		}
	}

	function startNumberRecall() {

		ended = false;

		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			miniGroupings = JSON.parse(localStorage.getItem("miniGroupings"));

			//restore data
			numberList = JSON.parse(localStorage.getItem("correctAnswers"));

			//create the arrays of minigroup and locus starting points
			miniGroupStarts = [];
			locusStarts = [0];
			var counter = 0;
			curMiniGroup = 0;
			while (counter < amount) {
				miniGroupStarts.push(counter);
				counter += parseFloat(miniGroupings[curMiniGroup]);
				if (curMiniGroup == miniGroupings.length - 1) {
					locusStarts.push(counter);
					curMiniGroup = 0;
				} else {
					curMiniGroup = parseFloat(curMiniGroup) + 1 % miniGroupings.length;
				}
			}
		}


		numberOfPages = Math.ceil(amount / numbersPerPage); //added in case went straight to recall

		curPos = 0;
		curLocus = 0;
		curMiniGroup = 0;
		curPage = 0;
		var numberRecallString = "";


		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNumRecall(" + numbersPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}

			menuString += "</ul><br /><br /><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString;


			/*
			//new menu 
			for (var i=0;i<numberOfPages;i++) {
					var menuItem = document.createElement("a");
					menuItem.setAttribute("href","#");
					menuItem.setAttribute("id","page" + i + "tablinkRecall");
					menuItem.classList.add(skin + "pagelink");
					menuItem.classList.add("menu");
					menuItem.innerHTML = (i+1) + "";
					document.getElementById("menuRecallDiv").appendChild(menuItem);
					//+= "<li><a href='#' id='page"+ i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNumRecall(" + numbersPerPage*i + ")'>" + (i+1) + "</a></li>";
				}
				*/
		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}



		//add the recall content
		for (i = 0; i < numberOfPages; i++) {
			if (i < numberOfPages - 1) {
				numbersOnThisPage = numbersPerPage;
			}
			else {
				numbersOnThisPage = amount - i * numbersPerPage;
			}

			numberRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";

			for (j = 0; j < numbersOnThisPage; j++) {

				numberRecallString += "<td id='tdRecall" + (i * numbersPerPage + j) + "' class='" + skin + "numbersRecallTD'><input ondblclick='toggleMark(this)' class='" + skin + "numbersRecall' id='inpRecall" + (i * numbersPerPage + j) + "' maxlength='1'	  onclick='moveFocusNumRecall(" + (i * numbersPerPage + j) + ")' oninput='checkMoveLocusNumRecall(" + (i * numbersPerPage + j + 1) + ")'></input><span style='height:10px' class='slash'><sup class='digitMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";


				if ((j + 1) % numbersPerRow == 0) {
					if (j + 1 == numbersOnThisPage) {
						numberRecallString += "</tr></table></div>";

					}

					else {

						numberRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";



					}

				}

			}

		}


		//***FINISH BUTTON kEpT fOr ReCall
		//numberRecallString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button>";
		document.getElementById("recallContentDiv").innerHTML = numberRecallString;

		var button = document.createElement("button");
		button.setAttribute("class", "btn btn-primary finishBtn");
		button.addEventListener("click", finishRecall);
		button.innerText = "Finish";
		$("#finishBtnDiv").empty();
		document.getElementById("finishBtnDiv").appendChild(button);



		//add separations
		if (separations.length > 0) {
			for (var i = 0; i < amount; i++) {
				if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
					document.getElementById("tdRecall" + i).classList.add("separation");
				}

			}
		}



		if (skin.indexOf('analogue') > -1 && !resuming) {
			var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
			for (var i = 0; i < amount; i++) {
				document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
				document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
			}
		}

		//restore data if resuming
		if (resuming) {

			restoreNumbersData();
			restoreMarks();
		}

		//go to first digits

		setTimeout(function () {
			moveLocusNumRecall(0, 0, 0);
		}, 40);


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}

		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;


		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
			//ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
			//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveNumbersData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);

			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();
			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				e.preventDefault();
				moveNextNumbersRecall();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				e.preventDefault();
				movePreviousNumbersRecall();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpNumbersRecall();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownNumbersRecall();
			}

			//if backspace (8) is pressed, 

			if (e.key == "Backspace" && !ended) {
				e.preventDefault();
				if (document.getElementById("inpRecall" + curPos).value == "") {
					//if nothing in this box, delete the number in previous box and move back to that space
					movePreviousNumbersRecall();
					document.getElementById("inpRecall" + curPos).value = "";
				} else {
					//else delete what's in this box
					document.getElementById("inpRecall" + curPos).value = "";
				}
			}
			//If + is pressed
			if ((e.key == '+' || e.key == '=') && !ended) {
				e.preventDefault();
				shiftNumbersForward();

			}

			//If - is pressed
			if ((e.key == '-' || e.key == '-') && !ended) {
				e.preventDefault();

				shiftNumbersBackward();

			}

			//if [ is pressed, previous page
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusNumRecall(numbersPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusNumRecall(numbersPerPage * (curPage + 1));

			}


			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusNumRecall(0);
			}

		};





	}

	function moveNextNumbersRecall() {

		//if we have reached end of list, don't move

		if (curPos < (amount - 1)) {

			if (locusStarts.indexOf(curPos + 1) > -1) {
				moveLocusNumRecall(curLocus + 1, 0, curPos + 1);
			} else {
				if (miniGroupStarts.indexOf(curPos + 1) > -1) {
					moveLocusNumRecall(curLocus, curMiniGroup + 1, curPos + 1);
				} else {
					moveLocusNumRecall(curLocus, curMiniGroup, curPos + 1);
				}
			}

			//	moveFocusNumRecall(curPos+1);

		}
	}

	function movePreviousNumbersRecall() {

		//if we are at start of list, don't move

		if (curPos > 0) {

			moveFocusNumRecall(curPos - 1);


		}
	}

	function moveUpNumbersRecall() {

		//if we are on first row, don't move

		if (curPos >= numbersPerRow) {


			moveFocusNumRecall(curPos - numbersPerRow);


		}
	}

	function moveDownNumbersRecall() {

		//if we are on last row, don't move

		if (curPos + numbersPerRow < amount) {


			moveFocusNumRecall(curPos + numbersPerRow);


		}
	}

	function saveNumbersData() {

		console.log("saving data");
		chosenAnswers = [];
		//save data
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many digits on page
			if (j < numberOfPages - 1) {
				numberOfDigits = numbersPerPage;
			}
			else {
				numberOfDigits = amount - j * numbersPerPage;
			}
			//loop through the digits on the page

			for (var i = 0; i < numberOfDigits; i++) {
				//get the chosen answer for the digit
				chosenAnswers.push(document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value);
			}
		}
		localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

	}

	function saveBinaryData() {

		console.log("saving data");
		chosenAnswers = [];
		//save data
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many digits on page
			if (j < numberOfPages - 1) {
				numberOfDigits = binaryPerPage;
			}
			else {
				numberOfDigits = amount - j * binaryPerPage;
			}
			//loop through the digits on the page

			for (var i = 0; i < numberOfDigits; i++) {
				//get the chosen answer for the digit
				chosenAnswers.push(document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value);
			}
		}
		localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

	}

	function saveCardsData() {

		console.log("saving data");
		chosenAnswers = [];
		localStorage.setItem("chosen", JSON.stringify(boneyardArray));

	}

	function saveWordsData() {

		console.log("saving data");
		chosenAnswers = [];
		//save data
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many words on page
			if (j < numberOfPages - 1) {
				numberOfWords = wordsPerPage;
			}
			else {
				numberOfWords = amount - j * wordsPerPage;
			}
			//loop through the words on the page

			for (var i = 0; i < numberOfWords; i++) {
				//get the chosen answer for the word
				chosenAnswers.push(document.getElementById("inpRecall" + ((j * wordsPerPage) + i)).value);
			}
		}
		localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

	}

	function saveDatesData() {

		console.log("saving data");
		chosenAnswers = [];
		//save data
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many dates on page
			if (j < numberOfPages - 1) {
				numberOfDates = datesPerPage;
			}
			else {
				numberOfDates = amount - j * datesPerPage;
			}
			//loop through the dates on the page

			for (var i = 0; i < numberOfDates; i++) {
				//get the chosen answer for the date
				chosenAnswers.push(document.getElementById("inpRecall" + ((j * datesPerPage) + i)).value);
			}
		}
		localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

	}

	function saveImagesData() {

		console.log("saving data");
		chosenAnswers = [];
		//save data
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many dates on page
			if (j < numberOfPages - 1) {
				numberOfImages = imagesPerPage;
			}
			else {
				numberOfImages = amount - j * imagesPerPage;
			}
			//loop through the images on the page

			for (var i = 0; i < numberOfImages; i++) {
				//get the chosen answer for the image
				chosenAnswers.push(document.getElementById("inpRecall" + ((j * imagesPerPage) + i)).value);
			}
		}
		localStorage.setItem("chosen", JSON.stringify(chosenAnswers));

	}

		function saveNamesData() {

			console.log("saving data");
			chosenFirstNames = [];
			chosenSurnames = [];
			var numberOfFaces;	
			//save data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many faces on page
				if (j < numberOfPages - 1) {
					numberOfFaces = namesPerPage;
				}
				else {
					numberOfFaces = facesAmount - j * namesPerPage;
				}
				//loop through the faces on the page

				for (var i = 0; i < numberOfFaces; i++) {
					//get the chosen first name
					chosenFirstNames.push(document.getElementById("inpRecallF" + ((j * namesPerPage) + i)).value);
					//get the chosen surname
					chosenSurnames.push(document.getElementById("inpRecallS" + ((j * namesPerPage) + i)).value);

				}
			}
			localStorage.setItem("chosenFirstNames", JSON.stringify(chosenFirstNames));
			localStorage.setItem("chosenSurnames", JSON.stringify(chosenSurnames));

		}



	function restoreNumbersData() {
		console.log("restoring data");
		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		if (chosenAnswers) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many digits on page
				if (j < numberOfPages - 1) {
					numberOfDigits = numbersPerPage;
				}
				else {
					numberOfDigits = amount - j * numbersPerPage;
				}
				//loop through the digits on the page

				for (var i = 0; i < numberOfDigits; i++) {
					//get the chosen answer for the digit, provided it's a number
					if (!isNaN(chosenAnswers[(j * numbersPerPage) + i])) document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value = chosenAnswers[(j * numbersPerPage) + i];
				}
			}
		}
	}

	function restoreBinaryData() {
		console.log("restoring data");
		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		if (chosenAnswers) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many digits on page
				if (j < numberOfPages - 1) {
					numberOfDigits = binaryPerPage;
				}
				else {
					numberOfDigits = amount - j * binaryPerPage;
				}
				//loop through the digits on the page

				for (var i = 0; i < numberOfDigits; i++) {
					//get the chosen answer for the digit, provided it's a number
					if (!isNaN(chosenAnswers[(j * binaryPerPage) + i])) document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value = chosenAnswers[(j * binaryPerPage) + i];
				}
			}
		}
	}

	function restoreCardsData() {
		console.log("restoring data");
		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		if (chosenAnswers) {
			//get data
			for (var j = 0; j < amount * 52; j++) {
				//loop through boneyard

				for (var i = 0; i < chosenAnswers[j].recallPos.length; i++) {
					curPos = chosenAnswers[j].recallPos[i];
					chooseFromBoneyard(j);
				}
			}
		}
	}


	function restoreWordsData() {
		console.log("restoring data");

		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		console.log(chosenAnswers);
		if (chosenAnswers.length > 0) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many words on page
				if (j < numberOfPages - 1) {
					numberOfWords = wordsPerPage;
				}
				else {
					numberOfWords = amount - j * wordsPerPage;
				}
				//loop through the words on the page

				for (var i = 0; i < numberOfWords; i++) {
					//get the chosen answer for the word
					if (chosenAnswers[(j * wordsPerPage) + i] != "") document.getElementById("inpRecall" + ((j * wordsPerPage) + i)).value = chosenAnswers[(j * wordsPerPage) + i];
				}
			}
		}
	}

	function restoreDatesData() {
		console.log("restoring data");

		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		console.log(chosenAnswers);
		if (chosenAnswers.length > 0) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many words on page
				if (j < numberOfPages - 1) {
					numberOfDates = datesPerPage;
				}
				else {
					numberOfDates = amount - j * datesPerPage;
				}
				//loop through the dates on the page

				for (var i = 0; i < numberOfDates; i++) {
					//get the chosen answer for the word
					if (chosenAnswers[(j * datesPerPage) + i] != "") document.getElementById("inpRecall" + ((j * datesPerPage) + i)).value = chosenAnswers[(j * datesPerPage) + i];
				}
			}
		}
	}

	function restoreImagesData() {
		console.log("restoring data");

		chosenAnswers = JSON.parse(localStorage.getItem("chosen"));
		console.log(chosenAnswers);
		if (chosenAnswers.length > 0) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many images on page
				if (j < numberOfPages - 1) {
					numberOfImages = imagesPerPage;
				}
				else {
					numberOfImages = amount - j * imagesPerPage;
				}
				//loop through the images on the page

				for (var i = 0; i < numberOfImages; i++) {
					//get the chosen answer for the word
					if (chosenAnswers[(j * imagesPerPage) + i] != "") document.getElementById("inpRecall" + ((j * imagesPerPage) + i)).value = chosenAnswers[(j * imagesPerPage) + i];
				}
			}
		}
	}


	function restoreNamesData() {
		console.log("restoring data");

		chosenFirstNames = JSON.parse(localStorage.getItem("chosenFirstNames"));
		chosenSurnames = JSON.parse(localStorage.getItem("chosenSurnames"));
		
		if (chosenFirstNames.length > 0 || chosenSurnames.length > 0) {
			//get data
			for (var j = 0; j < numberOfPages; j++) {
				//calculate how many images on page
				if (j < numberOfPages - 1) {
					var numberOfFaces = namesPerPage;
				}
				else {
					var numberOfFaces = facesAmount - j * namesPerPage;
				}
				//loop through the names on the page

				for (var i = 0; i < numberOfFaces; i++) {
					//get the chosen first name
					if (chosenFirstNames[(j * namesPerPage) + i] != "") document.getElementById("inpRecallF" + ((j * namesPerPage) + i)).value = chosenFirstNames[(j * namesPerPage) + i];
					//get the chosen surname
					if (chosenSurnames[(j * namesPerPage) + i] != "") document.getElementById("inpRecallS" + ((j * namesPerPage) + i)).value = chosenSurnames[(j * namesPerPage) + i];

				}
			}
		}
	}

	function checkMoveLocusNumRecall(newPos) {
		var blnMoving = true;
		if (document.getElementById("inpRecall" + curPos).value === "-") {
			blnMoving = false;
		}

		//check current position's input and ensure only digits
		document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^/\d]/, '');

		if (blnMoving) {
			var newLocus = Math.floor(newPos / locusSize);
			var newFirstOfLocus = locusStarts[newLocus];

			var totalSoFar = 0;
			var newMiniGroup = 0;

			for (i = 0; i < miniGroupings.length; i++) {
				totalSoFar += parseFloat(miniGroupings[i]);
				if (newPos - newFirstOfLocus < totalSoFar) {

					//	newPos = Number(parseFloat(newFirstOfLocus) + parseFloat(totalSoFar) - parseFloat(miniGroupings[i]));
					newMiniGroup = i;
					break;
				}
			}


			moveLocusNumRecall(newLocus, newMiniGroup, newPos);
		}
	}

	function moveFocusImagesRecall(newPos) {
		//get current page
		curPage = Math.floor(newPos / imagesPerPage);



		//show/hide correct pages
		for (var i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
				}
			}
		}

		if (!ended) {

			if (newPos < amount) {
				document.getElementById("imgRecall" + (curPos)).classList.remove(skin + "imagesSelected");

				document.getElementById("imgRecall" + (newPos)).className = skin + "imagesSelected";
				document.getElementById("inpRecall" + newPos).focus();
				document.getElementById("inpRecall" + newPos).select();

				curPos = newPos;
			}
		}
	}


	function checkMoveFocusImagesRecall(pos) {
		var blnMoving = true;

		//check current position's input and ensure only digits
		document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^/\d]/, '');

		if (blnMoving) {
			moveFocusImagesRecall(pos);
		}
	}

	function checkMoveFocusBinRecall(pos) {
		var blnMoving = true;
		if ((document.getElementById("inpRecall" + curPos).value === "-") || (document.getElementById("inpRecall" + curPos).value === "=")) {
			blnMoving = false;
		}

		//check current position's input and ensure only digits
		document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + curPos).value.replace(/[^0-1]/, '');

		if (blnMoving) {
			moveFocusBinRecall(pos);
		}
	}

	function moveLocusNumRecall(newLocus, newMiniGroup, newPos) {
		if (!ended) {
			var firstOfLocus = locusStarts[curLocus];
			var newFirstOfLocus = locusStarts[newLocus];

			//if moving locus, remove all highlights from curLocus and add highlight to newLocus
			if (curLocus != newLocus) {
				//remove highlights
				document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersSelectedRecall");
				document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersInGroup");
				document.getElementById("inpRecall" + firstOfLocus).classList.remove(skin + "numbersInLocus");
				document.getElementById("inpRecall" + firstOfLocus).style.backgroundColor = "";
				for (var i = 1; i < locusSize; i++) {
					if (firstOfLocus < numberList.length - i) {
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersSelectedRecall");
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInGroup");
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInLocus");
						document.getElementById("inpRecall" + (firstOfLocus + i)).style.backgroundColor = "";
					}
				}
			} else { //not moving locus
				//put selected minigroup back to skin+numbersInLocus
				//*** Could also check if moving miniGroup and if not then just change which is selected

				if (curMiniGroup == newMiniGroup) {
					document.getElementById("inpRecall" + curPos).classList.remove(skin + "numbersSelectedRecall");
				} else {

					//** Really just need to deal with current minigroup (not whole locus) but might take longer to calculate the firstOfMiniGroup? maybe store this
					for (var i = 0; i < locusSize; i++) {
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersSelectedRecall");
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.remove(skin + "numbersInGroup");
						document.getElementById("inpRecall" + (firstOfLocus + i)).classList.add(skin + "numbersInLocus");
					}
				}
			}

			//add highlights
			var totalSoFar = 0;
			for (i = 0; i < miniGroupings.length; i++) {

				//go through all digits in this miniGroup
				for (j = 0; j < miniGroupings[i]; j++) {
					var pos = newFirstOfLocus + totalSoFar + j;
					if (i == newMiniGroup) {
						document.getElementById("inpRecall" + pos).classList.add(skin + "numbersInGroup");
					} else {
						document.getElementById("inpRecall" + pos).classList.add(skin + "numbersInLocus");
					}
				}
				totalSoFar += parseFloat(miniGroupings[i]);
			}

			document.getElementById("inpRecall" + newPos).classList.add(skin + "numbersSelectedRecall");

			//get new page if necessary
			var newPage = Math.floor(newPos / numbersPerPage);

			if (newPage != curPage || curPos == 0) {

				//show/hide correct pages
				for (var i = 0; i < numberOfPages; i++) {
					if (i == newPage) {
						document.getElementById("page" + i + "Recall").style.display = "block";

						if (numberOfPages > 1) {
							//highlight this page tab
							document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
						}
					}
					else {
						document.getElementById("page" + i + "Recall").style.display = "none";
						if (numberOfPages > 1) {
							//un-highlight this page tab
							document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
						}
					}
				}
				curPage = newPage;
			}
			curPos = newPos;
			curLocus = newLocus;
			curMiniGroup = newMiniGroup;
			document.getElementById("inpRecall" + newPos).focus();
			document.getElementById("inpRecall" + newPos).select();
		}
	}


	function moveFocusNumRecall(newPos) {

		if (!ended) {
			var newLocus = Math.floor(newPos / locusSize);
			var newFirstOfLocus = locusStarts[newLocus];


			var totalSoFar = 0;
			var newMiniGroup = 0;

			for (i = 0; i < miniGroupings.length; i++) {
				totalSoFar += parseFloat(miniGroupings[i]);
				if (newPos - newFirstOfLocus < totalSoFar) {
					newMiniGroup = i;
					break;
				}
			}


			moveLocusNumRecall(newLocus, newMiniGroup, newPos);

			/*
				//get first of grouping
				var firstOfGroup = curPos - (curPos % grouping);
			
				if (newPos < amount) {
				//un-highlight current group
				document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
				document.getElementById("inpRecall" + firstOfGroup).className = skin + "numbersRecall";
				for (var i = 1; i < grouping; i++) {
				if (firstOfGroup < amount - i) {
					document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
						document.getElementById("inpRecall" + (firstOfGroup + i)).className = skin + "numbersRecall";
					}
				}
			
				//update firstOfGroup
			
				firstOfGroup = newPos - (newPos % grouping);
			
			
				//highlight selected digit and also other digits in group (different colour)
				
				 document.getElementById("inpRecall" + firstOfGroup).style.backgroundColor = "";
				document.getElementById("inpRecall" + (firstOfGroup)).className = skin + "numbersInGroup";
				for (var i = 1; i < grouping; i++) {
				if (firstOfGroup < amount - i) {
					document.getElementById("inpRecall" + (firstOfGroup + i)).style.backgroundColor = "";
						document.getElementById("inpRecall" + (firstOfGroup + i)).className = skin + "numbersInGroup";
					}
				}
			
				document.getElementById("inpRecall" + newPos).className = skin + "numbersSelectedRecall";
			
			
				//get new page
				var newPage = Math.floor(newPos/numbersPerPage);
				if (newPage != curPage || curPos == 0) {
			
			
				//show/hide correct pages
				for (var i = 0; i < numberOfPages; i++) {
					if (i == newPage) {
						document.getElementById("page" + i + "Recall").style.display = "block";
						
					if (numberOfPages>1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
					}
					}
					else {
					document.getElementById("page" + i + "Recall").style.display = "none";
					if (numberOfPages>1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
					}
					}
				}
				curPage = newPage;
			
			}
			
				document.getElementById("inpRecall" + newPos).focus();
				document.getElementById("inpRecall" + newPos).select();
				curPos = newPos;
			
			}*/
		}

	}

	function shiftNumbersForward() {
		for (var i = amount - 1; i >= curPos + 1; i--) {
			document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i - 1)).value;
			if (document.getElementById("inpRecall" + Number(i - 1)).classList.contains("markOther")) {
				document.getElementById("inpRecall" + Number(i - 1)).classList.remove("markOther");
				document.getElementById("inpRecall" + i).classList.add("markOther");
			} else {
				document.getElementById("inpRecall" + i).classList.remove("markOther");
			}
		}


		document.getElementById("inpRecall" + curPos).value = "";
		document.getElementById("inpRecall" + curPos).classList.remove("markOther");
	}

	function shiftNumbersBackward() {
		document.getElementById("inpRecall" + curPos).value = document.getElementById("inpRecall" + Number(curPos + 1)).value;
		if (document.getElementById("inpRecall" + Number(curPos + 1)).classList.contains("markOther")) {
			document.getElementById("inpRecall" + curPos).classList.add("markOther");
			document.getElementById("inpRecall" + Number(curPos + 1)).classList.remove("markOther");
		}

		for (var i = curPos + 1; i < amount - 1; i++) {

			document.getElementById("inpRecall" + i).value = document.getElementById("inpRecall" + (i + 1)).value;
			if (document.getElementById("inpRecall" + Number(i + 1)).classList.contains("markOther")) {
				document.getElementById("inpRecall" + Number(i + 1)).classList.remove("markOther");
				document.getElementById("inpRecall" + i).classList.add("markOther");
			}

		}
		document.getElementById("inpRecall" + (amount - 1)).value = "";
		document.getElementById("inpRecall" + (amount - 1)).classList.remove("markOther");
		//  movePreviousNumMemo();
		//when you do backwards arrow it doesn't highlighted
		//if text is highlighted or cell is blank then it goes too far to right and deletes current, need to do prev again?!
	}

	/*
	function shiftDataForward() {
		if (currentDiscipline.indexOf("B")>-1) {
			shiftBinForward()		
		}
		else if (currentDiscipline.indexOf("C")>-1) {
			shiftCardsForward()
		} else {
			shiftNumbersForward()
		}
	}
	
	function shiftDataBackward() {
		if (currentDiscipline.indexOf("B")>-1) {
			shiftBinBackward()		
		}
		else if (currentDiscipline.indexOf("C")>-1) {
			shiftCardsBackward()
		} else {
			shiftNumbersBackward()
		}
	}
	*/

	//returns the middle (average) font size
	function normalize(fontArray) {
		return Math.floor((fontArray[2] - fontArray[1]) / 2) + fontArray[1];
	}

	//takes in a fontArray in the form ['Font Name', minimumFontSize, maximumFontSize]
	function fontSizeRandomizer(fontArray) {
		var range = fontArray[2] - fontArray[1];
		var randomNumber = Math.random();



		//if the current font size === minimumFontSize, increment font size 75% of the time.
		if (fontSizeNow === fontArray[1]) {
			if (randomNumber < .2) {
				fontSizeNow++;
			} else if (randomNumber < .35) {
				fontSizeNow += 2;
			} else if (randomNumber < .65) {
				fontSizeNow += 3;
			} else if (randomNumber < .75) {
				fontSizeNow += 4;
			} else if (randomNumber < .85) {
				fontSizeNow += 5;
			} else if (randomNumber < .93) {
				fontSizeNow += 6;
			}
			//if the current font size === maximumFontSize, decrement font size 75% of the time.
		} else if (fontSizeNow === fontArray[2]) {
			if (randomNumber < .2) {
				fontSizeNow--;
			} else if (randomNumber < .35) {
				fontSizeNow -= 2;
			} else if (randomNumber < .65) {
				fontSizeNow -= 3;
			} else if (randomNumber < .75) {
				fontSizeNow -= 4;
			} else if (randomNumber < .85) {
				fontSizeNow -= 5;
			} else if (randomNumber < .93) {
				fontSizeNow -= 6;
			}
			//if current font size is neither max nor min, increment 35% of the time, decrement 35% of the time, stay th same 30% of time

		} else if (fontArray[2] - fontSizeNow == -2 || fontArray[1] - fontSizeNow == 2) {
			if (randomNumber > .5) {
				fontSizeNow += 2;
			} else {
				fontSizeNow -= 2;
			}
		} else {
			if (randomNumber > .9) {
				fontSizeNow += 5;
			} else if (randomNumber > .8) {
				fontSizeNow++;
			} else if (randomNumber > .6) {
				fontSizeNow += 3;
			} else if (randomNumber > .4) {
				fontSizeNow -= 3;
			} else if (randomNumber > .2) {
				fontSizeNow -= 5;
			} else if (randomNumber > .1) {
				fontSizeNow--;
			}
		}
		//return [fontName, newFontSize];
		if (fontSizeNow > fontArray[2]) {
			fontSizeNow = fontArray[2];
		} else if (fontSizeNow < fontArray[1]) {
			fontSizeNow = fontArray[1]
		}
		return [fontArray[0], fontSizeNow];
	}

	//Helper function to switch from one font to another while retaining relative font size (somewhat);
	function fontSwitch(fontArray1, fontArray2) {
		if (fontNow === fontArray1) {
			fontNow = fontArray2;

			//if the font is at its minimum for fontA, set it to the minimum for fontB
			if (fontSizeNow === fontArray1[1]) {
				fontSizeNow = fontArray2[1];

				//if the font is at its maximum for fontA, set it to the maximum for fontB
			} else if (fontSizeNow === fontArray1[2]) {
				fontSizeNow = fontArray2[2];

				//if the font is neither max nor min for fontA, set it to the normalized val for fontB
			} else {
				fontSizeNow = normalize(fontArray2);
			}
			return fontSizeRandomizer(fontArray2);
		} else {

			//same stuff going from B to A
			fontNow = fontArray1;

			if (fontSizeNow === fontArray2[1]) {
				fontSizeNow = fontArray1[1];
			} else if (fontSizeNow === fontArray2[2]) {
				fontSizeNow = fontArray1[2];
			} else {
				fontSizeNow = normalize(fontArray1);
			}

			return fontSizeRandomizer(fontArray1);
		}

	}

	function dualFontRandomizer(fontArray1, fontArray2) {
		var fontSizeArray = [];
		//The first digit will always be [fontArray1[0], fontArrayNormalized]
		fontNow = fontArray1;
		fontSizeNow = normalize(fontArray1);
		fontSizeArray.push([fontNow[0], fontSizeNow]);

		//on every even iteration, let there be a chance to switch fonts.  Here that is 67% (changed to 33%)
		for (var r = 1; r < amount; r++) {
			if (r % 2 === 0) {
				if (Math.random() < 0.33) {
					//if fontSwitch activates
					fontSizeArray.push(fontSwitch(fontArray1, fontArray2));

				} else {
					fontSizeArray.push(fontSizeRandomizer(fontNow));
				}
			} else {
				fontSizeArray.push(fontSizeRandomizer(fontNow));
			}
		}
		return fontSizeArray;
	}

	function startBinaryRecall() {

		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			miniGroupings = JSON.parse(localStorage.getItem("miniGroupings"));
			numberOfPages = Math.ceil(amount / binaryPerPage); //added in case went straight to recall

			//work out number of levels
			var longLine = binaryPerRow;
			binLevels = 1;

			while (longLine % groupingW !== 0) {
				longLine += binaryPerRow;
				binLevels++;
			}

			//restore data
			binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
		}

		ended = false;
		curPos = 0;
		var binaryRecallString = "";

		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusBinRecall(" + binaryPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br/><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}


		//add the recall content
		for (i = 0; i < numberOfPages; i++) {
			if (i < numberOfPages - 1) {
				binaryOnThisPage = binaryPerPage;
			}
			else {
				binaryOnThisPage = amount - i * binaryPerPage;
			}

			binaryRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";

			for (j = 0; j < binaryOnThisPage; j++) {
				currentSquare = i * binaryPerPage + j;
				var nextSquare = 0;
				nextSquare = getNextSquare(currentSquare);

				binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input ondblclick='toggleMark(this);' class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + (i * binaryPerPage + j) + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";
				//binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + (i * binaryPerPage + j) + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";

				if ((j + 1) % binaryPerRow == 0) {
					if (j + 1 == binaryOnThisPage) {
						binaryRecallString += "</tr></table></div>";

					}

					else {

						binaryRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor(currentSquare / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";



					}

				}

			}

		}


		//kept finish button for recall
		//binaryRecallString += "</div><br />";
		binaryRecallString += "</div><br /><button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button>";
		document.getElementById("recallContentDiv").innerHTML = binaryRecallString;

		//add intra-group separations
		if (separations.length > 0) {
			for (var i = 0; i < amount; i++) {
				if (separations.indexOf((i + 1) % groupingW) > -1 || (i + 1) % groupingW == 0) {
					document.getElementById("tdRecall" + i).classList.add("separation");
				}

			}
		}



		if (skin.indexOf('analogue') > -1 && !resuming) {
			var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
			for (var i = 0; i < amount; i++) {
				document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
				document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
			}

		}



		//restore data if resuming
		if (resuming) {
			restoreBinaryData();
			restoreMarks();
		}


		//go to first digits 
		setTimeout(function () {
			moveFocusBinRecall(0);
		}, 40);

		//$("#spanShift").show();


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		//set current position
		curPos = 0;

		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;
		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveBinaryData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);


			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {
			//If Enter is pressed
			// 	if (e.key == "Enter" && !ended) {
			if (e.key == "Enter" && !ended) {
				finishRecall();


			}

			//if right arrow pressed, move on
			//    if (e.key == "ArrowRight" && !ended) {
			if (e.key == "ArrowRight" && !ended) {
				e.preventDefault();
				moveNextBinRecall();
			}


			//if left arrow is pressed to go back
			//   if (e.key == "ArrowLeft" && !ended) {
			if (e.key == "ArrowLeft" && !ended) {
				e.preventDefault();
				movePreviousBinRecall();
			}

			//if up arrow pressed, move up
			//  if (e.key == "ArrowUp" && !ended) {
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpBinRecall();
			}

			//if down arrow pressed, move down
			//if (e.key == "ArrowDown" && !ended) {
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownBinRecall();
			}


			//if backspace (8) is pressed, 

			//	if (e.key == "Backspace" && !ended) {
			if (e.key == "Backspace" && !ended) {
				e.preventDefault();
				if (document.getElementById("inpRecall" + curPos).value == "") {
					//if nothing in this box, delete the number in previous box and move back to that space
					movePreviousBinRecall();
					document.getElementById("inpRecall" + curPos).value = "";
				} else {
					//else delete what's in this box
					document.getElementById("inpRecall" + curPos).value = "";
				}
			}


			//If + is pressed
			//  if ((e.key == '+' || e.key == '=') && !ended) {
			if ((e.key == "+" || e.key == "=") && !ended) {
				e.preventDefault();
				shiftBinForward();

			}

			//If - is pressed
			//  if ((e.key == '-' || e.key == '-') && !ended) {
			if ((e.key == "-" || e.key == "_") && !ended) {
				e.preventDefault();

				shiftBinBackward();

			}

			//if [ is pressed, previous page
			//if (e.key == ',') {
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusBinRecall(binaryPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			//	if (e.key == '.') {
			if (e.key == '.' && !ended) {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusBinRecall(binaryPerPage * (curPage + 1));

			}



			//if space is pressed, return to start
			// if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusBinRecall(0);
			}

		};





	}

	function moveFocusBinRecall(newPos) {


		if (!ended) {

			if (newPos < amount) {


				//get grouping
				var positions = getMatrixPositions(curPos);

				//remove highlight from existing grouping

				for (var i = 0; i < positions.length; i++) {
					if (positions[i] < binaryList.length) {
						document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binarySelectedRecall");
						document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binaryInGroup");
						document.getElementById("inpRecall" + (positions[i])).style.backgroundColor = "";
					}

				}


				//get new page
				var newPage = Math.floor(newPos / binaryPerPage);
				if (newPage != curPage || curPos == 0) {


					//show/hide correct pages
					for (var i = 0; i < numberOfPages; i++) {
						if (i == newPage) {
							document.getElementById("page" + i + "Recall").style.display = "block";


							if (numberOfPages > 1) {
								//highlight this page tab
								document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
							}
						}
						else {
							document.getElementById("page" + i + "Recall").style.display = "none";
							if (numberOfPages > 1) {
								//un-highlight this page tab
								document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
							}
						}
					}
					curPage = newPage;
				}


				//get grouping
				var newPositions = getMatrixPositions(newPos);

				//add highlight to new grouping

				for (var i = 0; i < positions.length; i++) {
					if (newPositions[i] < binaryList.length) {
						if (newPositions[i] === newPos) {
							document.getElementById("inpRecall" + (newPositions[i])).classList.add(skin + "binarySelectedRecall");

						}
						else {
							document.getElementById("inpRecall" + (newPositions[i])).classList.add(skin + "binaryInGroup");
						}
					}

				}

				document.getElementById("inpRecall" + newPos).focus();
				document.getElementById("inpRecall" + newPos).select();
				curPos = newPos;
			}
		}


	}

	function moveUpBinRecall() {

		//if we are on first row, don't move

		if (curPos >= binaryPerRow) {


			moveFocusBinRecall(curPos - binaryPerRow);


		}
	}

	function moveDownBinRecall() {

		//if we are on last row, don't move

		if (curPos + binaryPerRow < amount) {


			moveFocusBinRecall(curPos + binaryPerRow);


		}
	}

	function movePreviousBinRecall() {

		//if we are at start of list, don't move

		if (curPos > 0) {

			moveFocusBinRecall(getPreviousSquare(curPos));


		}


	}

	function moveNextBinRecall() {

		if (curPos < amount - 1) {
			moveFocusBinRecall(getNextSquare(curPos));
		}



	}

	/*
	function moveUpBinScore() {
	
	//if we are on first row, don't move
	
	if (curPos >= binaryPerRow) {
	
	
	moveFocusBinScore(curPos-binaryPerRow);
	
	
	}
	}
	
	function moveDownBinScore() {
	
	//if we are on last row, don't move
	
	if (curPos + binaryPerRow < amount) {
	
	
	moveFocusBinScore(curPos+binaryPerRow);
	
	
	}
	}
	
	function movePreviousBinScore() {
	
	//if we are at start of list, don't move
	
	if (curPos > 0) {
	
	moveFocusBinScore(getPreviousSquare(curPos));
	
	
	}       
	
	
	}
	
	function moveNextBinScore() {
	
	if (curPos < amount-1) {
	moveFocusBinScore(getNextSquare(curPos));
	}
	
	}
	
	*/


	function shiftBinForward() {
		//for each matrix from last to current+1, get values from previous matrix and insert

		for (var i = amount - 1; i >= getMatrixPositions(getNextImage(curPos))[0]; i = getMatrixPositions(getPreviousImage(i))[0]) {
			//get positions of current matrix
			var destPositions = getMatrixPositions(i);

			//get positions of previous matrix	  
			var sourcePositions = getMatrixPositions(i)[0] == 0 ? [0, 0, 0, 0, 0, 0, 0, 0, 0] : getMatrixPositions(getPreviousImage(i))

			//loop through all destination positions and fill with source
			for (var p = 0; p < destPositions.length; p++) {
				if (destPositions[p] < amount && sourcePositions[p] < amount) {
					document.getElementById("inpRecall" + destPositions[p]).value = document.getElementById("inpRecall" + sourcePositions[p]).value;

					if (document.getElementById("inpRecall" + sourcePositions[p]).classList.contains("markOther")) {
						document.getElementById("inpRecall" + sourcePositions[p]).classList.remove("markOther");
						document.getElementById("inpRecall" + destPositions[p]).classList.add("markOther");
					} else {
						document.getElementById("inpRecall" + destPositions[p]).classList.remove("markOther");
					}

				}
			}

		}

		//clear current matrix
		var currentPositions = getMatrixPositions(curPos)
		console.log(currentPositions);
		//loop through all positions and make empty
		for (var p = 0; p < currentPositions.length; p++) {
			document.getElementById("inpRecall" + currentPositions[p]).value = "";
			document.getElementById("inpRecall" + currentPositions[p]).classList.remove("markOther");
		}

	}

	function shiftBinBackward() {
		//get values from next matrix into current matrix
		//or is this already done?

		//from current to last but 1 matrix, bring data from next matrix to this matrix
		for (var i = curPos; i < getMatrixPositions(amount - 1)[0]; i = getMatrixPositions(getNextImage(i))[0]) {

			//get positions of current matrix
			var destPositions = getMatrixPositions(i);

			//get positions of next matrix	  
			var sourcePositions = getMatrixPositions(getNextImage(i))

			// if (sourcePositions.length > 0) {
			//loop through all destination positions and fill with source
			for (var p = 0; p < destPositions.length; p++) {
				if (destPositions[p] < amount) {
					document.getElementById("inpRecall" + destPositions[p]).value = document.getElementById("inpRecall" + (sourcePositions[p])).value;
					if (document.getElementById("inpRecall" + sourcePositions[p]).classList.contains("markOther")) {
						document.getElementById("inpRecall" + sourcePositions[p]).classList.remove("markOther");
						document.getElementById("inpRecall" + destPositions[p]).classList.add("markOther");
					}

				}
			}
		}

		//  }

		//clear last matrix     
		var lastPositions = getMatrixPositions(amount - 1)

		//loop through all positions and make empty
		for (var p = 0; p < lastPositions.length; p++) {
			if (lastPositions[p] < amount) {
				document.getElementById("inpRecall" + lastPositions[p]).value = "";
				document.getElementById("inpRecall" + lastPositions[p]).classList.remove("markOther");
			}
		}
	}


	function moveFocusCardRecall(newPos) {

		if (newPos < amount * 52 && newPos > -1) {
			//ended || $("#cardRecall" + curPos).toggleClass('cardRecallSelected');
			ended || document.getElementsByClassName("cardRecall")[curPos].classList.remove("cardRecallSelected")

			//get current page
			curPage = Math.floor(newPos / 52);


			//show/hide correct pages
			for (var i = 0; i < amount; i++) {
				if (i == curPage) {
					document.getElementById("page" + i + "Recall").style.display = "block";
					if (amount > 1) {
						//highlight this page tab
						document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
					}
				}
				else {
					document.getElementById("page" + i + "Recall").style.display = "none";
					if (amount > 1) {
						//un-highlight this page tab
						document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
					}
				}
			}
			if (ended) return;

			//$("#cardRecall" + newPos).toggleClass('cardRecallSelected');
			ended || document.getElementsByClassName("cardRecall")[newPos].classList.add("cardRecallSelected");

			curPos = newPos;
		}


	}


	function startImagesRecall() {

		ended = false;
		//curPos = 0;


		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall
			numberOfPages = Math.ceil(amount / imagesPerPage); //added in case went straight to recall

			//restore data
			imageArray = JSON.parse(localStorage.getItem("imageArray"));
			answerArray = JSON.parse(localStorage.getItem("answerArray"));
		} else {
			//shuffle each set of 5 within itself

			var setOfFive = [1, 2, 3, 4, 5];
			for (let g = 0; g < amount; g += 5) {
				shuffle(setOfFive);
				answerArray.push(...setOfFive);
			}
			//and save it
			localStorage.setItem("answerArray", JSON.stringify(answerArray));
		}


		var imagesRecallString = "";

		//add the page links if >1 page
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusImagesRecall(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";
			}
			menuString += "</ul><br /><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "";
		}




		//add the recall content
		for (i = 0; i < numberOfPages; i++) {
			if (i < numberOfPages - 1) {
				imagesOnThisPage = imagesPerPage;
			}
			else {
				imagesOnThisPage = amount - i * imagesPerPage;
			}

			imagesRecallString += "<div id='page" + i + "Recall'><table class='imageTable' id='recallTable" + i + "'>";


			for (var j = 0; j < imagesOnThisPage; j++) {
				//if we haven't reached the end

				//add row num if needed
				if (j % 5 == 0) {
					imagesRecallString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
				}


				//add the next image and a box below it
				//	imagesRecallString += "<td id='tdRecall" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgRecall" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td id='inpRecall" + Number(i*imagesPerPage+j) + "'><input type='text'  class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i*imagesPerPage+j) + ")' oninput='checkMoveFocusImagesRecall(" + (i*imagesPerPage+j+1) + ")'></td></tr></table></td>";

				//add image with box before it 
				imagesRecallString += "<td class='" + skin + "imagesRecallTD' ondblclick='toggleMark(this)' id='tdRecall" + Number(i * imagesPerPage + j) + "'><input type='text' id='inpRecall" + Number(i * imagesPerPage + j) + "' class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' oninput='checkMoveFocusImagesRecall(" + (i * imagesPerPage + j + 1) + ")'><img class='imageClass' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' id='imgRecall" + Number(i * imagesPerPage + j) + "'  src='IAM Images/" + imageArray[Math.floor((i * imagesPerPage + j) / 5) * 5 + answerArray[i * imagesPerPage + j] - 1] + "' height=80></td>";


				//close the row if needed and spacer row
				if ((j + 1) % 5 == 0) {
					if (j + 1 == imagesOnThisPage) {
						imagesRecallString += "</tr>";
					} else {
						imagesRecallString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
					}
				}

			}
			imagesRecallString += "</table><br /><button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button></div>";
			//	imagesRecallString += "</table><br /></div>";
		}




		imagesRecallString += "</div>";
		/*
		var btn = document.createElement("button");
		var node = document.createTextNode("Finish");
		btn.appendChild(node);
		btn.classList.add("btn");
		btn.classList.add("btn-primary");
		btn.classList.add("finishBtn");*/
		//btn.onclick = finishRecall;
		//"<button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button>"

		document.getElementById("recallContentDiv").innerHTML = imagesRecallString;
		//document.getElementsByClassName("bottom-right-timer")[1].insertBefore(btn,document.getElementById(skin + "RecallTimeOuter"));
		//document.getElementById("buttonGoesHereForImages").appendChild(btn);


		if (skin.indexOf('analogue') > -1 && !resuming) {
			var fontSizeArray = dualFontRandomizer(fontReenieBeanie, fontShadowsIntoLight);
			for (var i = 0; i < amount; i++) {
				document.getElementById("inpRecall" + i).style.fontSize = fontSizeArray[i][1];
				document.getElementById("inpRecall" + i).style.fontFamily = fontSizeArray[i][0];
			}
		}

		//restore data if resuming
		if (resuming) {

			restoreImagesData();
			restoreMarks();
		}

		//go to first digits

		setTimeout(function () {
			moveFocusImagesRecall(0);
		}, 40);


		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		//set current position
		curPos = 0;
		curPage = 0;

		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);
			//ns=(((recallTime*1e3-recallTimeDiff)/1e3)), m=(ns/60)>>0,s=Math.floor(ns-m*60),hs=Math.floor((ns-(Math.floor(ns)))*100);
			//r.textContent = m + ":" + ((""+s).length>1?"":"0")+s + ":" + ((""+hs).length>1?"":"0")+hs;

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveImagesData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);


			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {

			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();

			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				e.preventDefault();
				moveNextImagesRecall();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				e.preventDefault();
				movePreviousImagesRecall();
			}

			//if up arrow pressed, move up
			if (e.key == "ArrowUp" && !ended) {
				e.preventDefault();
				moveUpImagesRecall();
			}

			//if down arrow pressed, move down
			if (e.key == "ArrowDown" && !ended) {
				e.preventDefault();
				moveDownImagesRecall();
			}

			//if backspace (8) is pressed, delete the number in previous box and move back to that space
			if ((e.key == "Backspace") && !ended) {
				e.preventDefault();
				console.log("deleted in images recall");
				movePreviousImagesRecall();
				document.getElementById("inpRecall" + curPos).value = "";
			}

			//if [ is pressed, previous page
			if (e.key == ',') {
				e.preventDefault();
				if (curPage > 0) moveFocusImagesRecall(imagesPerPage * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.') {
				e.preventDefault();
				if (curPage < numberOfPages - 1) moveFocusImagesRecall(imagesPerPage * (curPage + 1));

			}



			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusImagesRecall(0);
			}

		};


	}

	function moveNextImagesRecall() {
		//check if skipping and if this is the final image
		if (curPos + 1 < amount) {

			moveFocusImagesRecall(curPos + 1);

		}
	}

	function movePreviousImagesRecall() {
		//check if skipping and if this is the final image
		if (curPos > 0) {

			moveFocusImagesRecall(curPos - 1);

		}
	}

	function moveUpImagesRecall() {
		if (curPos >= 5) {

			moveFocusImagesRecall(curPos - 5);

		}
	}


	function moveDownImagesRecall() {
		if (curPos + 5 < amount) {

			moveFocusImagesRecall(curPos + 5);

		}
	}

	function finishRecall() {
		recallTimeTaken = Date.now() - recallStart;

		//Clear display
		document.getElementById("recallRow").style.display = "none";

		//set ended to true
		ended = true;
		clearTimeout(myTimer);
		resuming = false;
		localStorage.setItem("phase", "score");

		//Score
		displayScore();
	}


	function displayScore() {
		ended = true;
		document.getElementById("scoreContentDiv").innerHTML = "";
		//Display score section only
		document.getElementById("selectionRow").style = "display:none";	//added in case we are resuming and go straight from selection to score
		document.getElementById("countdownRow").style = "display:none";
		document.getElementById("recallRow").style = "display:none";
		document.getElementById("scoreRow").style = "display:none";
		//   document.getElementById("spanScoreMemoTimeTaken").textContent = timeFormatLong(memoTimeTaken);
		//   document.getElementById("spanScoreRecallTimeTaken").textContent = timeFormatLong(recallTimeTaken);

		document.getElementById("logoRow").style = "display:none";
		document.getElementById("topMargin").style = "display:block";
		document.getElementById("btnBackToSelection2").style = "display:block";

		//Display relevant score screen depending on discipline
		switch (currentDiscipline) {
			case "5N":
			case "15N":
			case "30N":
			case "60N":
				displayNumberScore();
				break;
			case "5B":
			case "30B":
				displayBinaryScore();
				break;
			case "10C":
			case "30C":
			case "60C":
			case "SC":
				displayCardScore();
				break;
			case "D":
				displayDateScore();
				break;
			case "5F":
			case "15F":
				displayNamesScore();
				break;
			case "5W":
			case "15W":
				displayWordsScore();
				break;
			case "S":
				displaySpokenScore();
				break;
			default:
				displayImagesScore();
		}
	}


	function displayNumberScore() {

		if (resuming) {
			numberList = JSON.parse(localStorage.getItem("correctAnswers"));
			amount = localStorage.getItem("amount");
			numberOfPages = Math.ceil(amount / numbersPerPage);
		} else {
			saveNumbersData();
		}
		var score = 0;
		var rowNum = 0;
		var menuString = "";
		var scoreString = "";
		curPage = 0;

		//collect answers into a new array
		chosenAnswers = [];

		if (resuming) {
			chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content
			var numberRecallString = "";

			for (i = 0; i < numberOfPages; i++) {
				if (i < numberOfPages - 1) {
					numbersOnThisPage = numbersPerPage;
				}
				else {
					numbersOnThisPage = amount - i * numbersPerPage;
				}

				numberRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage) / numbersPerRow + 1) + "&nbsp;&nbsp;</td>";

				for (j = 0; j < numbersOnThisPage; j++) {
					numberRecallString += "<td id='tdRecall" + (i * numbersPerPage + j) + "' class='" + skin + "numbersRecallTD'><input class='" + skin + "numbersRecall' id='inpRecall" + (i * numbersPerPage + j) + "' maxlength='1'	  onclick='moveFocusNumRecall(" + (i * numbersPerPage + j) + ")' oninput='checkMoveLocusNumRecall(" + (i * numbersPerPage + j + 1) + ")'></input><span style='height:10px' class='slash'><sup class='digitMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";
					if ((j + 1) % numbersPerRow == 0) {
						if (j + 1 == numbersOnThisPage) {
							numberRecallString += "</tr></table></div>";
						}
						else {
							numberRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * numbersPerPage + j) / numbersPerRow + 2) + "&nbsp;&nbsp;</td>";
						}
					}

				}

			}

			document.getElementById("scoreContentDiv").innerHTML = numberRecallString;

			//add separations
			if (separations.length > 0) {
				for (var i = 0; i < amount; i++) {
					if (separations.indexOf((i + 1) % locusSize) > -1 || (i + 1) % locusSize == 0) {
						document.getElementById("tdRecall" + i).classList.add("separation");
					}

				}
			}
		}

		//add the page links if >1 page
		if (numberOfPages > 1) {

			menuString += "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkScore' class='" + skin + "pagelink' onclick='moveFocusNumScore(" + i * numbersPerPage + ")'>" + (i + 1) + "</a></li>";
			}


			menuString += "</ul><br/>";
			document.getElementById("menuScoreDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}





		//for every page
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many digits on page
			if (j < numberOfPages - 1) {
				numberOfDigits = numbersPerPage;
			}
			else {
				numberOfDigits = amount - j * numbersPerPage;
			}

			//add the start tags for the div (with page number) and table

			//loop through the digits on the page
			for (var i = 0; i < numberOfDigits; i++) {

				//get the chosen answer for the digit
				if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).value);
				var chosenAnswer = chosenAnswers[((j * numbersPerPage) + i)];
				var correctAnswer = numberList[((j * numbersPerPage) + i)];

				//add the correct answer to the correction row string
				//correctionRowString += "<td class='correction shadowyScore' id='scoreCorr" + ((j*numbersPerPage)+i) + "''>" + correctAnswer + "</td>";

				if (chosenAnswer == correctAnswer && chosenAnswer.length > 0) {
					score++;
					document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).classList.add(skin + "correct");

				}
				else {

					if (chosenAnswer.length === 0) {
						//nothing chosen
						if (skin.indexOf('analogue') > -1) {
							//20-07-2018 add marking sup 
							//22-07-2018 marking sup and sub exist already; just add correct answer			
							document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
						}
						else {
							//22-07-2018 add mouseover
							//currently not adding anything if they didn't enter a digit
							//scoreString += "<td class='" + skin + "score' onmouseover='showCorrect(" + ((j*numbersPerPage)+i) + ")' onmouseout='showChosen(" + ((j*numbersPerPage)+i) + ")' id='score" + ((j*numbersPerPage)+i) + "'></td>";
						}
					}
					else {

						if (skin.indexOf('analogue') > -1) {
							//22-07-2018 marking sup and sub exist already; just add correct answer
							//also need an X in the sub
							console.log("adding x to " + ((j * numbersPerPage) + i));
							document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
							document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).parentNode.childNodes[1].childNodes[1].innerHTML = "x";
						}
						else {
							//22-07-2018 add mouseover
							//  scoreString += "<td class='" + skin + "score " + skin + "incorrect' onmouseover='showCorrect(" + ((j*numbersPerPage)+i) + ")' onmouseout='showChosen(" + ((j*numbersPerPage)+i) + ")' id='score" + ((j*numbersPerPage)+i) + "'>" + chosenAnswer + "</td>";
							document.getElementById("inpRecall" + ((j * numbersPerPage) + i)).classList.add(skin + "incorrect");
						}
					}
				}



			}

		}


		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		}



		//deselect current position and group
		document.getElementById("inpRecall" + curPos).classList.add(skin + "numbersRecall");
		document.getElementById("inpRecall" + curPos).classList.remove(skin + "numbersSelectedRecall");
		var firstOfGroup = curPos - (curPos % grouping);
		for (var i = 0; i < grouping; i++) {
			document.getElementById("inpRecall" + (firstOfGroup + i)).classList.remove(skin + "numbersInGroup");
			document.getElementById("inpRecall" + (firstOfGroup + i)).classList.add(skin + "numbersRecall");
		}


		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < amount; m++) {
				if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
					$("#inpRecall" + m).mouseover(function (ev) {
						showCorrect(ev.target.id.match(/\d+/g));
					});
					$("#inpRecall" + m).mouseout(function (ev) {
						showChosen(ev.target.id.match(/\d+/g));
					});
				}
			}
		}


		//add the chosen answers
		for (var i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).value = chosenAnswers[i];
			document.getElementById("inpRecall" + i).setAttribute("readonly", "");



		}



		if (numberOfPages > 1) {
			document.getElementById("page0tablinkScore").className = skin + "pagelinkred";
		}

		for (var i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		totalEval = 0;

		//calculate the number of rows
		if (amount % numbersPerRow == 0) {
			numberOfRows = amount / numbersPerRow;
		}
		else {
			numberOfRows = Math.floor(amount / numbersPerRow) + 1;
		}

		var lastRow = 0;

		//find last non-empty row
		for (var i = numberOfRows - 1; i > -1; i--) {
			for (var j = 0; j < numbersPerRow; j++) {
				//check that we only go as far as the amount; see if there is an answer in each cell
				if (numbersPerRow * i + j < amount && chosenAnswers[numbersPerRow * i + j].length > 0) {
					//if we find a digit, this is the last row
					lastRow = i;
					//change conditions to break out of loop
					j = numbersPerRow;
					i = 0;
				}
			}
		}

		//go through from row 0 to last row
		for (var i = 0; i <= lastRow; i++) {
			var incorrectThisRow = 0;

			//calculate row length
			if (i == lastRow) {
				//go through row and see how many in row
				for (var j = 0; j < numbersPerRow; j++) {
					if (chosenAnswers[numbersPerRow * i + j].length == 0) {
						rowLength = j;
						j = numbersPerRow;
					}
				}
			}
			else {
				rowLength = numbersPerRow;
			}

			//go through row and see how many incorrect
			for (var j = 0; j < rowLength; j++) {
				if (chosenAnswers[numbersPerRow * i + j] != numberList[numbersPerRow * i + j]) {
					incorrectThisRow++;
				}
				if (incorrectThisRow == 2) {
					thisRowEval = 0;
					j = rowLength;
				}
			}


			if (incorrectThisRow == 1) {
				//special case: if only one digit and it's wrong, score 0
				thisRowEval = rowLength == 1 ? 0 : Math.ceil(rowLength / 2);
			}
			if (incorrectThisRow == 0) {
				thisRowEval = rowLength;
			}
			totalEval += thisRowEval;
		}



		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + score + " correct)";

		$(".finishBtn").hide();

		document.getElementById("scoreRow").style.display = "block";


		if (resuming) {
			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusNumberRecall(numbersPerPage * (curPage - 1));
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusNumberRecall(numbersPerPage * (curPage + 1));
				}


			};

		} else {
			document.onkeydown = function (e) {

				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusNumScore(numbersPerPage * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusNumScore(numbersPerPage * (curPage + 1));

				}

			};

		}

	}

	function moveFocusNumScore(newPos) {

		//get current page
		curPage = Math.floor(newPos / numbersPerPage);

		//show/hide correct pages
		for (i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkScore").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkScore").className = skin + "pagelink";
				}
			}
		}

	}

	function moveFocusBinScore(newPos) {

		//get current page
		curPage = Math.floor(newPos / binaryPerPage);

		//show/hide correct pages
		for (i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkScore").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkScore").className = skin + "pagelink";
				}
			}
		}

	}

	function moveFocusCardScore(newPos) {
		console.log("trying to move page");
		//get current page
		curPage = Math.floor(newPos / 52);

		//show/hide correct pages
		for (i = 0; i < amount; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + "Recall").style.display = "block";
				if (amount > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
				if (amount > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablinkRecall").className = skin + "pagelink";
				}
			}
		}
		// $("#cardRecall" + newPos).toggleClass("cardRecallSelected");
	}

	function displayBinaryScore() {

		if (resuming) {
			binaryList = JSON.parse(localStorage.getItem("correctAnswers"));
			amount = localStorage.getItem("amount");
			numberOfPages = Math.ceil(amount / binaryPerPage);
		} else {
			saveBinaryData();
		}


		var score = 0;
		var rowNum = 0;
		var menuString = "";
		curPage = 0;

		//collect answers into a new array
		chosenAnswers = [];

		if (resuming) {
			chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content
			var binaryRecallString = "";

			for (i = 0; i < numberOfPages; i++) {
				if (i < numberOfPages - 1) {
					binaryOnThisPage = binaryPerPage;
				}
				else {
					binaryOnThisPage = amount - i * binaryPerPage;
				}

				binaryRecallString += "<div id='page" + i + "Recall'><table class='" + skin + "recallTable'><tr><td class='" + skin + "rowNumber'>" + Math.floor((i * binaryPerPage) / binaryPerRow + 1) + "&nbsp;&nbsp;</td>";

				for (j = 0; j < binaryOnThisPage; j++) {
					currentSquare = i * binaryPerPage + j;
					var nextSquare = 0;
					nextSquare = getNextSquare(currentSquare);

					binaryRecallString += "<td id='tdRecall" + currentSquare + "' class='" + skin + "binaryRecallTD'><input class='" + skin + "binaryRecall' id='inpRecall" + currentSquare + "' maxlength='1'	  onclick='moveFocusBinRecall(" + (i * binaryPerPage + j) + ")' oninput='checkMoveFocusBinRecall(" + nextSquare + ")'></input><span style='height:10px' class='slash'><sup class='binaryMarkingSup'></sup><sub class='digitMarkingSub'></sub></span></td>";

					if ((j + 1) % binaryPerRow == 0) {
						if (j + 1 == binaryOnThisPage) {
							binaryRecallString += "</tr></table></div>";

						}

						else {

							binaryRecallString += "</tr><tr><td class='" + skin + "rowNumber'>" + Math.floor(currentSquare / binaryPerRow + 2) + "&nbsp;&nbsp;</td>";



						}

					}

				}

			}

			document.getElementById("scoreContentDiv").innerHTML = binaryRecallString;

			//add separations
			//add intra-group separations
			if (separations.length > 0) {
				for (var i = 0; i < amount; i++) {
					if (separations.indexOf((i + 1) % groupingW) > -1 || (i + 1) % groupingW == 0) {
						document.getElementById("tdRecall" + i).classList.add("separation");
					}
				}
			}

		}

		//add the page links if >1 page
		if (numberOfPages > 1) {

			menuString += "<ul class='menu'>";

			for (i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkScore' class='" + skin + "pagelink' onclick='moveFocusBinScore(" + i * binaryPerPage + ")'>" + (i + 1) + "</a></li>";
			}


			menuString += "</ul><br/><br />";
			document.getElementById("menuScoreDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}


		//for every page
		for (var j = 0; j < numberOfPages; j++) {
			//calculate how many digits on page
			if (j < numberOfPages - 1) {
				numberOfDigits = binaryPerPage;
			}
			else {
				numberOfDigits = amount - j * binaryPerPage;
			}

			//loop through the digits on the page
			for (var i = 0; i < numberOfDigits; i++) {

				//get the chosen answer for the digit
				if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).value);
				var chosenAnswer = chosenAnswers[((j * binaryPerPage) + i)];
				var correctAnswer = binaryList[((j * binaryPerPage) + i)];

				//add the correct answer to the correction row string


				if (chosenAnswer == correctAnswer && chosenAnswer.length > 0) {
					score++;
					document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).classList.add(skin + "correct");
				}
				else {

					if (chosenAnswer.length === 0) {
						//nothing chosen
						if (skin.indexOf('analogue') > -1) {
							document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;

						}
						else {
							//23-07-2018 add mouseover
							//do we make it red if nothing entered?
							//		document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).classList.add(skin + "incorrect");
						}
					}
					else {

						if (skin.indexOf('analogue') > -1) {

							console.log("adding x to " + ((j * binaryPerPage) + i));
							document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[0].innerHTML = correctAnswer;
							document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).parentNode.childNodes[1].childNodes[1].innerHTML = "x";
							//document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).parentNode.childNodes[1].childNodes[0].style.display = "block";
							//document.getElementById("inpRecall" + ((j*binaryPerPage)+i)).parentNode.childNodes[1].childNodes[1].style.display = "block";
						}
						else {
							//23-07-2018 add mouseover and green/red
							document.getElementById("inpRecall" + ((j * binaryPerPage) + i)).classList.add(skin + "incorrect");
						}
					}
				}




			}



		}


		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		}



		//deselect current position and group
		//get grouping
		var positions = getMatrixPositions(curPos);
		document.getElementById("inpRecall" + curPos).classList.remove(skin + "binarySelectedRecall");
		document.getElementById("inpRecall" + curPos).classList.add(skin + "binaryRecall");
		//remove highlight from existing grouping

		for (var i = 0; i < positions.length; i++) {
			if (positions[i] < binaryList.length) {
				document.getElementById("inpRecall" + (positions[i])).classList.remove(skin + "binaryInGroup");
				document.getElementById("inpRecall" + (positions[i])).classList.add(skin + "binaryRecall");
			}

		}


		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < amount; m++) {
				if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
					$("#inpRecall" + m).mouseover(function (ev) {
						showCorrect(ev.target.id.match(/\d+/g));
					});
					$("#inpRecall" + m).mouseout(function (ev) {
						showChosen(ev.target.id.match(/\d+/g));
					});
				}
			}
		}


		//add the chosen answers
		for (var i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).value = chosenAnswers[i];
			document.getElementById("inpRecall" + i).setAttribute("readonly", "");



		}



		if (numberOfPages > 1) {
			document.getElementById("page0tablinkScore").className = skin + "pagelinkred";
		}

		for (i = 0; i < numberOfPages; i++) {
			if (i == 0) {
				document.getElementById("page" + i + "Recall").style.display = "block";
			}
			else {
				document.getElementById("page" + i + "Recall").style.display = "none";
			}
		}


		totalEval = 0;

		//calculate the number of rows
		if (amount % binaryPerRow == 0) {
			numberOfRows = amount / binaryPerRow;
		}
		else {
			numberOfRows = Math.floor(amount / binaryPerRow) + 1;
		}

		var lastRow = 0;

		//find last non-empty row
		for (i = numberOfRows - 1; i > -1; i--) {
			for (j = 0; j < binaryPerRow; j++) {
				if (chosenAnswers[binaryPerRow * i + j].length > 0) {
					lastRow = i;
					j = binaryPerRow;
					i = 0;
				}
			}
		}

		//go through from row 0 to last row
		for (i = 0; i <= lastRow; i++) {
			var incorrectThisRow = 0;

			//calculate row length
			if (i == lastRow) {
				//go through row and see how many in row
				for (j = 0; j < binaryPerRow; j++) {
					if (chosenAnswers[binaryPerRow * i + j].length == 0) {
						rowLength = j;
						j = binaryPerRow;
					}
				}
			}
			else {
				rowLength = binaryPerRow;
			}

			//go through row and see how many incorrect
			for (j = 0; j < rowLength; j++) {
				if (chosenAnswers[binaryPerRow * i + j] != binaryList[binaryPerRow * i + j]) {
					incorrectThisRow++;
				}
				if (incorrectThisRow == 2) {
					thisRowEval = 0;
					j = rowLength;
				}
			}


			if (incorrectThisRow == 1) {
				//special case - if only one digit and it's wrong then score 0
				thisRowEval = rowLength == 1 ? 0 : Math.ceil(rowLength / 2);
			}
			if (incorrectThisRow == 0) {
				thisRowEval = rowLength;
			}
			totalEval += thisRowEval;
		}

		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + score + " correct)";

		$(".finishBtn").hide();

		document.getElementById("scoreRow").style.display = "block";

		if (resuming) {
			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusBinScore(binaryPerPage * (curPage - 1));
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusBinScore(binaryPerPage * (curPage + 1));
				}


			};


		} else {
			document.onkeydown = function (e) {

				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusBinScore(binaryPerPage * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusBinScore(binaryPerPage * (curPage + 1));

				}

			};

		}

	}

	function startCardRecall() {
		if (skin.indexOf("analogue") > -1) {
			$("#recallBox").addClass("cardTable");
			$("#scoreBox").addClass("cardTable");
			$(".bottom-right-timer").addClass("textCardTable");
			$(".disciplineTitleMemo").addClass("textCardTable");
			$(".disciplineTitleMemo").removeClass("textNonCards");
			$("#spanOuterScore").addClass("cardTable");
			$("#spanScore").addClass("cardTable");
			$("#spanCorrect").addClass("cardTable");
			$("#cardsMemoTime").css("color", "white");
		} else {
			$("#cardsMemoTime").css("color", "black");
		}

		ended = false;

		if (resuming) {
			amount = Number(localStorage.getItem("amount")); //added in case going straight to recall

			//restore data
			cardList = JSON.parse(localStorage.getItem("correctAnswers"));


			memoTimeTaken = localStorage.getItem("memoTimeTaken");
		}

		if (currentDiscipline.indexOf("SC") > -1) {
			$("#cardsMemoTime").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));
			localStorage.setItem("memoTimeTaken", memoTimeTaken);
		}

		//reset boneyard array
		boneyardArray = [];


		//add the page links if >1 page
		if (amount > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < amount; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusCardRecall(" + 52 * i + ")'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br/><br /><br />";
			//add two more rows if we are doing more than 26 decks, otherwise the page numbers overlap the numbers
			if (amount > 26) menuString += "<br /><br />";
			document.getElementById("menuRecallDiv").innerHTML = menuString;

		} else {
			document.getElementById("menuRecallDiv").innerHTML = "<br /><br /><br />";
		}


		for (var d = 0; d < amount; d++) {

			var cardPage = document.createElement("div");
			cardPage.setAttribute("id", "page" + d + "Recall");
			cardPage.setAttribute("style", "position:relative");
			var cardContainer1 = document.createElement("div");
			var cardContainer2 = document.createElement("div");
			cardContainer1.classList.add("cardContainer");
			cardContainer2.classList.add("cardContainer");


			//ADD RECALL SECTION (cardContainer)
			for (let i = 0; i < 52; i++) {

				var individualCardDiv = document.createElement("div");


				if (i > 25) {

					individualCardDiv.classList.add("secondRow");

				}

				var individualCardNum = document.createElement("div");
				var individualCardImg = document.createElement("img");
				individualCardImg.setAttribute("src", "Card images " + cardSet + "/back.png");
				individualCardDiv.classList.add("cardDiv");
				individualCardImg.classList.add("cardRecall");
				individualCardNum.classList.add("cardRecallNum");
				individualCardNum.innerText = (i + 1).toString();
				individualCardDiv.appendChild(individualCardNum);
				individualCardDiv.appendChild(individualCardImg);
				// ondblclick='restoreBoneyardCard(" + Number(d*52+i) + ")' id='cardRecall" + (d*52+i) + "'
				individualCardImg.thisIndex = d * 52 + i;
				individualCardImg.addEventListener("click", function (e) {
					moveFocusCardRecall(e.target.thisIndex);
				});
				//	individualCardImg.addEventListener("dblclick", function(e){
				//		restoreBoneyardCard(e.target.thisIndex);			
				//	});
				individualCardImg.addEventListener("dblclick", function (e) {
					toggleMark(e.target);
				});
				individualCardImg.setAttribute("id", "cardRecall" + Number(d * 52 + i));

				if (i > 25) {
					cardContainer2.appendChild(individualCardDiv);
				} else {
					cardContainer1.appendChild(individualCardDiv);
				}
			}


			//ADD BONEYARD (cardBoneyardDiv)
			var boneyardDiv = document.createElement("div");
			boneyardDiv.classList.add("cardBoneyardDiv");
			boneyardDiv.classList.add(skin + "cardBoneyardDiv");


			var boneyard = getStandardDeck();
			sortBoneyard(boneyard);
			var count = 0;
			boneyard.forEach(function (card) {
				boneyardArray.push({ cs: card["cs"], cv: card["cv"], recallPos: [] });
				var boneyardCard = document.createElement("img");
				boneyardCard.setAttribute("src", "Card images " + cardSet + "/" + card["cs"] + getValueName(card["cv"]) + ".png");
				boneyardCard.thisIndex = d * 52 + count;
				boneyardCard.setAttribute("id", "cardBoneyard" + Number(d * 52 + count));
				boneyardCard.classList.add("cardBoneyard");
				boneyardCard.classList.add(skin + "cardBoneyard");
				boneyardCard.addEventListener("click", function (e) {
					chooseFromBoneyard(e.target.thisIndex);
				});
				//id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
				//cardRecallString += "<img src='Card images/" + card["cs"] + getValueName(card["cv"]) + ".png' class='cardBoneyard " + skin + "cardBoneyard' id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
				count++;
				boneyardDiv.appendChild(boneyardCard);
			});



			cardPage.appendChild(cardContainer1);
			cardPage.appendChild(cardContainer2);
			cardPage.appendChild(boneyardDiv);
			document.getElementById("recallContentDiv").appendChild(cardPage);
		}
		//end of each page


		//***FINISH BUTTON kEpT fOr ReCall
		var button = document.createElement("button");
		button.setAttribute("class", "btn btn-primary finishBtn");
		button.addEventListener("click", finishRecall);
		button.innerText = "Finish";
		$("#finishBtnDiv").empty();
		document.getElementById("finishBtnDiv").appendChild(button);

		//restore data if resuming
		if (resuming) {
			restoreCardsData();
			restoreMarks();
		}


		//move to first card
		$("#cardRecall0").toggleClass('cardRecallSelected');
		curPos = 0;
		moveFocusCardRecall(1);
		moveFocusCardRecall(26);

		setTimeout(function () {
			moveFocusCardRecall(0);
		}, 40);



		//fan recall cards out
		//**


		for (var deck = 0; deck < amount; deck++) {


			var cardDivs = document.getElementsByClassName("cardDiv");
			var cardsRNum = document.getElementsByClassName("cardRecallNum");
			var cardsSecondRow = document.getElementsByClassName("secondRow");
			var cw = document.getElementsByClassName("cardContainer")[0].clientWidth;
			//var offset = cw/52+20;
			var offset = 40;
			var i;

			for (let j = 0; j < 26; j++) {
				i = deck * 52 + j;
				s = deck * 26 + j;



				cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
				cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";
			}
			for (let j = 0; j < 52; j++) {
				i = deck * 52 + j;
				cardsRNum[i].style.transform = " translateY(-20px)";
			}



			//fan boneyard cards out
			if (skin.indexOf("analogue") > -1) {

				var cardsBF = document.getElementsByClassName("cardBoneyard");


				//	i != 0 && (cardsR[i].style.transform = "translateX(-" + offset * (i%26) + "px);");
				for (let j = 0; j < 52; j++) {
					i = deck * 52 + j;
					cardsBF[i].style.transform = "rotate(0deg)";
				}

				for (let j = 0; j < 52; j++) {
					i = deck * 52 + j;
					cardsBF[i].style.transform = "rotate(" + ((j % 52) * 1) + "deg) translateY(+60px)";
				}
			} else {
				//digital (spread out but no fanning)

				//var cardsB = document.getElementsByClassName("cardBoneyard"),	offset = cw/52+57	;	
				var cardsB = document.getElementsByClassName("cardBoneyard"), offset = 1000 / 52 + 57;

				for (let j = 0; j < 52; j++) {
					i = deck * 52 + j;

					cardsB[i].style.transform = "translateX(-" + (offset * (i % 52)) + "px) translateY(+100px";
				}

			}
		}


		//set the timer
		var timeElapsed = resuming ? localStorage.getItem("timeElapsed") : 0;

		recallStart = Date.now(), r = document.getElementById(skin + 'RecallTimeInner');
		(function f() {
			recallTimeDiff = Date.now() - recallStart + Number(timeElapsed);
			r.textContent = timeFormat(recallTime * 1e3 - recallTimeDiff);

			//every 10 seconds, save
			if ((Math.floor(recallTimeDiff / 100) * 100) % 10000 < 1000) {
				saveCardsData();
			}

			//save the elapsed time every second
			localStorage.setItem("timeElapsed", recallTimeDiff);


			//When timer reaches 0, go to score display
			if (recallTimeDiff / 1e3 >= recallTime) {

				finishRecall();
			}
			//Otherwise repeat this function
			else {
				if (!ended) {
					myTimer = setTimeout(f, 1000);
				}
			}
		})();


		document.onkeydown = function (e) {
			//If Enter is pressed
			if (e.key == "Enter" && !ended) {
				finishRecall();


			}

			//if right arrow pressed, move on
			if (e.key == "ArrowRight" && !ended) {
				e.preventDefault();
				moveNextCardRecall();
			}


			//if left arrow is pressed to go back
			if (e.key == "ArrowLeft" && !ended) {
				e.preventDefault();
				movePreviousCardRecall();
			}



			//if backspace (8) is pressed, delete the card in previous box and move back to that space
			if ((e.key == "Backspace") && !ended) {
				e.preventDefault();
				movePreviousCardRecall();

				restoreBoneyardCard(curPos);
				//boneyardArray[curPos].recallPos = -1;
				//display the sent-back card in the boneyard position
				//document.getElementById("cardBoneyard" + curPos).src = "Card images " + cardSet + "/" + boneyardArray[curPos].cs + getValueName(boneyardArray[curPos].cv) + ".png";

			}

			//if delete is pressed, delete the card in current space
			if ((e.key == "Delete") && !ended) {
				e.preventDefault();

				restoreBoneyardCard(curPos);
				//boneyardArray[curPos].recallPos = -1;
				//display the sent-back card in the boneyard position
				//document.getElementById("cardBoneyard" + curPos).src = "Card images " + cardSet + "/" + boneyardArray[curPos].cs + getValueName(boneyardArray[curPos].cv) + ".png";

			}



			//If + is pressed
			if ((e.key == '+' || e.key == '=') && !ended) {
				e.preventDefault();
				shiftCardsForward();

			}

			//If - is pressed
			if ((e.key == '-' || e.key == '-') && !ended) {

				e.preventDefault();
				shiftCardsBackward();

			}

			//if [ is pressed, previous page
			if (e.key == ',') {

				if (curPage > 0) moveFocusCardRecall(52 * (curPage - 1));
				//if (curPage>0) displayPage(curPage-1);
			}


			//if ] is pressed, next page
			if (e.key == '.' && !ended) {

				if (curPage < amount - 1) moveFocusCardRecall(52 * (curPage + 1));

			}

			//if up arrow is pressed, restart deck
			if (e.key == 'ArrowUp' && !ended) {

				moveFocusCardRecall(52 * (curPage));

			}

			//if space is pressed, return to start
			if ((e.key == ' ' || e.key == 'Spacebar') && !ended) {
				e.preventDefault();
				moveFocusCardRecall(0);

			}

		};


	}

	function getBoneyardPosition(pos) {
		var originalPosition = -1;
		var count = 0;
		for (let i = 0; i < boneyardArray.length; i++) {
			if (boneyardArray[i].recallPos.indexOf(pos) > -1) {
				originalPosition = i;
				break;
			}
		}
		return originalPosition;
	}
	function chooseFromBoneyard(position) {

		var cs = boneyardArray[position].cs;
		var cv = boneyardArray[position].cv;

		//only do something if this card hasn't already been picked up, i.e. recallPos == -1)   
		//OR if we are resuming on the score page, where it will be already in the boneyard array but won't appear on the screen yet
		//if (boneyardArray[position].recallPos == -1 || (resuming && localStorage.getItem("phase") == "score")) {
		//this card has not been picked up

		//only do something if this card hasn't already been placed in this position
		//OR if we are resuming on the score page, where it will be already in the boneyard array but won't appear on the screen yet
		if (boneyardArray[position].recallPos.indexOf(curPos) == -1 && localStorage.getItem("phase") != "score" || (resuming && localStorage.getItem("phase") == "score" && !displayed)) {

			//set it to the "back" image in the boneyard
			//document.getElementById("cardBoneyard" + position).src = "Card images " + cardSet + "/back.png";


			//if the chosen recall position is full, send that card back to boneyard
			var originalPosition = getBoneyardPosition(curPos);

			console.log("originalPosition = " + originalPosition);
			if (originalPosition > -1) {
				restoreBoneyardCard(curPos);
			}

			//invert boneyard card if not been picked up before
			if (boneyardArray[position].recallPos.length == 0) {
				document.getElementById("cardBoneyard" + position).classList.add("inverted");
			}

			//set the corresponding boneyardArray entry if not already in there (e.g. because we are resuming score page)
			if (boneyardArray[position].recallPos.indexOf(curPos) == -1) boneyardArray[position].recallPos.push(curPos);

			//display the card in the recall position
			document.getElementById("cardRecall" + curPos).src = "Card images " + cardSet + "/" + cs + getValueName(cv) + ".png";

			// invert it in the recall section if already picked up
			if (boneyardArray[position].recallPos.length > 1 && localStorage.getItem("phase") != "score") {
				boneyardArray[position].recallPos.forEach(el => document.getElementById("cardRecall" + el).classList.add("inverted"));
			}


			//used to move to next space, now moves to next empty space
			if (!ended) moveNextEmptyCardRecall();
		}
	}

	function moveNextEmptyCardRecall() {
		var nextEmpty = curPos + 1;
		while (getBoneyardPosition(nextEmpty) > -1) {
			nextEmpty++;
			if (curPos == amount * 52 - 1) return;
		}
		moveFocusCardRecall(nextEmpty);

	}

	function moveNextCardRecall() {
		ended || moveFocusCardRecall(curPos + 1);
	}

	function movePreviousCardRecall() {
		ended || moveFocusCardRecall(curPos - 1);
	}

	function shiftCardsBackward() {
		//restore cur pos card to boneyard
		if (getBoneyardPosition(curPos) > -1) {
			restoreBoneyardCard(curPos);
		}

		//only within this deck
		var d = Math.floor(curPos / 52);
		for (var i = curPos; i < d * 52 + 51; i++) {
			if (document.getElementById("cardRecall" + Number(i + 1)).classList.contains("inverted")) {
				document.getElementById("cardRecall" + Number(i + 1)).classList.remove("inverted");
				document.getElementById("cardRecall" + i).classList.add("inverted");
			}

			if (document.getElementById("cardRecall" + Number(i + 1)).classList.contains("markCards")) {
				document.getElementById("cardRecall" + Number(i + 1)).classList.remove("markCards");
				document.getElementById("cardRecall" + i).classList.add("markCards");
			}

			var nextPosition = getBoneyardPosition(i + 1);
			console.log(i + " " + nextPosition);
			if (nextPosition > -1) {
				//we find the boneyard card in next position and then inside its recallPos array we change i+1 to i	
				var index = boneyardArray[nextPosition].recallPos.indexOf(i + 1);
				boneyardArray[nextPosition].recallPos[index]--;
				document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/" + boneyardArray[nextPosition].cs + getValueName(boneyardArray[nextPosition].cv) + ".png";
			} else {
				document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/back.png";
			}
		}
		//whatever image is in curPos+1, we overwrite it with curPos+2, but we need to restore it

		//we are deleting card in last pos so replace with "back" image in recall
		document.getElementById("cardRecall" + (d * 52 + 51)).src = "Card images " + cardSet + "/back.png";

	}

	function shiftCardsForward() {
		//only within this deck
		var d = Math.floor(curPos / 52);

		if (getBoneyardPosition(d * 52 + 51) > -1) {
			console.log("there is a card in last position");
			restoreBoneyardCard(d * 52 + 51);
		}

		for (var i = d * 52 + 51; i >= curPos + 1; i--) {


			if (document.getElementById("cardRecall" + Number(i - 1)).classList.contains("inverted")) {
				document.getElementById("cardRecall" + Number(i - 1)).classList.remove("inverted");
				document.getElementById("cardRecall" + i).classList.add("inverted");
			} else {
				document.getElementById("cardRecall" + i).classList.remove("inverted");
			}
			if (document.getElementById("cardRecall" + Number(i - 1)).classList.contains("markCards")) {
				document.getElementById("cardRecall" + Number(i - 1)).classList.remove("markCards");
				document.getElementById("cardRecall" + i).classList.add("markCards");
			} else {
				document.getElementById("cardRecall" + i).classList.remove("markCards");
			}

			var previousPosition = getBoneyardPosition(i - 1);
			console.log(previousPosition);
			if (previousPosition > -1) {
				//we find the boneyard card in prev position and then inside its recallPos array we change i-1 to i	
				var index = boneyardArray[previousPosition].recallPos.indexOf(i - 1);
				boneyardArray[previousPosition].recallPos[index]++;
				document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/" + boneyardArray[previousPosition].cs + getValueName(boneyardArray[previousPosition].cv) + ".png";
			} else {
				document.getElementById("cardRecall" + i).src = "Card images " + cardSet + "/back.png";
			}
		}

		//we have deleted card in curPos so replace with "back" image in recall
		document.getElementById("cardRecall" + curPos).src = "Card images " + cardSet + "/back.png";

	}

	function restoreBoneyardCard(recallPos) {
		if (ended) return;

		var pos = getBoneyardPosition(recallPos);
		console.log("boneyard pos of last card was " + pos);
		//remove this index from the recallPos array
		var index = boneyardArray[pos].recallPos.indexOf(recallPos);
		boneyardArray[pos].recallPos.splice(index, 1);

		//remove inversion
		document.getElementById("cardRecall" + recallPos).classList.remove("inverted");
		//document.getElementById("cardRecall" + recallPos).classList.remove("lighter");

		//if this boneyard card now has nothing in recallPos array, we can take off the inversion in boneyard
		if (boneyardArray[pos].recallPos.length == 0) {
			document.getElementById("cardBoneyard" + pos).classList.remove("inverted");
		} else if (boneyardArray[pos].recallPos.length == 1) {
			//card now only appears once, so remove inversion in recall section
			document.getElementById("cardRecall" + boneyardArray[pos].recallPos[0]).classList.remove("inverted");
		}
		//display the sent-back card in the boneyard position
		document.getElementById("cardBoneyard" + pos).src = "Card images " + cardSet + "/" + boneyardArray[pos].cs + getValueName(boneyardArray[pos].cv) + ".png";
		document.getElementById("cardRecall" + recallPos).src = "Card images " + cardSet + "/back.png";
	}

	function displayCardScore() {

		displayed = false;
		if (resuming) {
			cardList = JSON.parse(localStorage.getItem("correctAnswers"));
			amount = localStorage.getItem("amount");
			memoTimeTaken = localStorage.getItem("memoTimeTaken");

			if (skin.indexOf("analogue") > -1) {
				$("#recallBox").addClass("cardTable");
				$("#scoreBox").addClass("cardTable");
				$(".bottom-right-timer").addClass("textCardTable");
				$(".disciplineTitleMemo").addClass("textCardTable");
				$(".disciplineTitleMemo").removeClass("textNonCards");

				$("#spanOuterScore").addClass("cardTable");
				$("#spanScore").addClass("cardTable");
				$("#spanCorrect").addClass("cardTable");
				$("#cardsMemoTime").css("color", "white");
			} else {
				$("#cardsMemoTime").css("color", "black");
			}

		} else {
			saveCardsData();
		}

		var totalEval = 0;
		var correct = 0;
		var correctThisDeck = 0;
		var deckScore = [];
		var firstMistake = [];
		var deckLength;
		var lastDeck = -1;


		if (resuming) {

			boneyardArray = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content

			for (var d = 0; d < amount; d++) {

				var cardPage = document.createElement("div");
				cardPage.setAttribute("id", "page" + d + "Recall");
				cardPage.setAttribute("style", "position:relative");
				var cardContainer1 = document.createElement("div");
				var cardContainer2 = document.createElement("div");
				cardContainer1.classList.add("cardContainer");
				cardContainer2.classList.add("cardContainer");


				for (let i = 0; i < 52; i++) {

					var individualCardDiv = document.createElement("div");


					if (i > 25) {

						individualCardDiv.classList.add("secondRow");

					}

					var individualCardNum = document.createElement("div");
					var individualCardImg = document.createElement("img");
					individualCardImg.setAttribute("src", "Card images " + cardSet + "/back.png");
					individualCardDiv.classList.add("cardDiv");
					individualCardImg.classList.add("cardRecall");
					individualCardImg.classList.remove("markCards");
					individualCardImg.classList.remove("inverted");
					individualCardNum.classList.add("cardRecallNum");
					individualCardNum.innerText = (i + 1).toString();
					individualCardDiv.appendChild(individualCardNum);
					individualCardDiv.appendChild(individualCardImg);
					// ondblclick='restoreBoneyardCard(" + Number(d*52+i) + ")' id='cardRecall" + (d*52+i) + "'
					individualCardImg.thisIndex = d * 52 + i;
					individualCardImg.addEventListener("click", function (e) {
						moveFocusCardRecall(e.target.thisIndex);
					});
					individualCardImg.setAttribute("id", "cardRecall" + Number(d * 52 + i));

					if (i > 25) {
						cardContainer2.appendChild(individualCardDiv);
					} else {
						cardContainer1.appendChild(individualCardDiv);
					}
				}


				//ADD BONEYARD (cardBoneyardDiv)
				var boneyardDiv = document.createElement("div");
				boneyardDiv.classList.add("cardBoneyardDiv");
				boneyardDiv.classList.add(skin + "cardBoneyardDiv");


				var boneyard = getStandardDeck();
				sortBoneyard(boneyard);
				var count = 0;
				boneyard.forEach(function (card) {
					//boneyardArray.push({cs:card["cs"],cv:card["cv"],recallPos:[]});

					var boneyardCard = document.createElement("img");
					boneyardCard.setAttribute("src", "Card images " + cardSet + "/" + card["cs"] + getValueName(card["cv"]) + ".png");
					boneyardCard.thisIndex = d * 52 + count;
					boneyardCard.setAttribute("id", "cardBoneyard" + Number(d * 52 + count));
					boneyardCard.classList.add("cardBoneyard");
					boneyardCard.classList.add(skin + "cardBoneyard");
					boneyardCard.addEventListener("click", function (e) {
						chooseFromBoneyard(e.target.thisIndex);
					});
					//id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
					//cardRecallString += "<img src='Card images/" + card["cs"] + getValueName(card["cv"]) + ".png' class='cardBoneyard " + skin + "cardBoneyard' id='cardBoneyard" + (d*52+count) + "' onClick=chooseFromBoneyard(" + (d*52+count)+ ")>";
					count++;
					boneyardDiv.appendChild(boneyardCard);
				});



				cardPage.appendChild(cardContainer1);
				cardPage.appendChild(cardContainer2);
				cardPage.appendChild(boneyardDiv);

				document.getElementById("scoreContentDiv").appendChild(cardPage);


			}

			document.getElementById("recallContentDiv").innerHTML = "";

			//fan cards out

			for (var deck = 0; deck < amount; deck++) {
				var cardDivs = document.getElementsByClassName("cardDiv");


				var cardsRNum = document.getElementsByClassName("cardRecallNum");
				var cardsSecondRow = document.getElementsByClassName("secondRow");
				var cw = document.getElementsByClassName("cardContainer")[0].clientWidth;
				//var offset = cw/52+20;
				var offset = 40;
				var i;

				for (let j = 0; j < 26; j++) {
					i = deck * 52 + j;
					s = deck * 26 + j;

					cardDivs[i].style.transform = "translateX(-" + offset * (i % 26) + "px)";
					cardsSecondRow[s].style.transform = "translateX(-" + offset * (i % 26) + "px) translateY(+40px)";
				}
				for (let j = 0; j < 52; j++) {
					i = deck * 52 + j;
					cardsRNum[i].style.transform = " translateY(-20px)";
				}

				//fan boneyard cards out
				if (skin.indexOf("analogue") > -1) {

					var cardsBF = document.getElementsByClassName("cardBoneyard");


					//	i != 0 && (cardsR[i].style.transform = "translateX(-" + offset * (i%26) + "px);");
					for (let j = 0; j < 52; j++) {
						i = deck * 52 + j;
						cardsBF[i].style.transform = "rotate(0deg)";
					}

					for (let j = 0; j < 52; j++) {
						i = deck * 52 + j;
						cardsBF[i].style.transform = "rotate(" + ((j % 52) * 1) + "deg) translateY(+60px)";
					}
				} else {
					//digital (spread out but no fanning)

					//var cardsB = document.getElementsByClassName("cardBoneyard"),	offset = cw/52+57	;	
					var cardsB = document.getElementsByClassName("cardBoneyard"), offset = 1000 / 52 + 57;

					for (let j = 0; j < 52; j++) {
						i = deck * 52 + j;

						cardsB[i].style.transform = "translateX(-" + (offset * (i % 52)) + "px) translateY(+100px";
					}

				}
			}


		}

		//Go through all decks, storing the number correct, the first mistake, and whether they were attempted
		for (var d = amount - 1; d >= 0; d--) {

			firstMistake[d] = -1;


			for (let i = 0; i < 52; i++) {
				//remove cardRecallSelected class
				document.getElementById("cardRecall" + Number(d * 52 + i)).classList.remove("cardRecallSelected");
				var boneyardPos = getBoneyardPosition(d * 52 + i);
				if (boneyardPos > -1) {
					//If we haven't found the last deck, this is it, and we need to store the deck length for special calculation
					//if we already found that this is the last deck, make sure we keep incrementing deckLength with each card
					if (lastDeck == -1 || lastDeck == d) {
						lastDeck = d;
						deckLength = i + 1;
					}
					if (cardList[d][i].cv == boneyardArray[boneyardPos].cv && cardList[d][i].cs == boneyardArray[boneyardPos].cs) {
						correctThisDeck++;
						document.getElementById("cardRecall" + Number(d * 52 + i)).classList.add("cardRecallCorrect");
					} else {
						//set firstMistake if not already set
						firstMistake[d] = (firstMistake[d] == -1 ? i : firstMistake[d]);
						document.getElementById("cardRecall" + Number(d * 52 + i)).classList.add("cardRecallIncorrect");

					}
				} else {

					//if not even attempted
					//set firstMistake if not already set
					firstMistake[d] = (firstMistake[d] == -1 ? i : firstMistake[d]);
				}
			}

			deckScore[d] = correctThisDeck;
			correctThisDeck = 0;
		}

		//Calculate last deck
		//lastDeck = (isAttempted.lastIndexOf(true)>-1 ? isAttempted.lastIndexOf(true) : 0);
		//console.log(lastDeck);


		//score for last deck - the deck length is taken to be the last card attempted
		//totalEval += (firstMistake[lastDeck] == -1 ? deckScore[lastDeck] : firstMistake[lastDeck]);

		if (currentDiscipline.indexOf("SC") > -1) {
			totalEval = (firstMistake[0] == -1 ? deckScore[0] : firstMistake[0]);
		} else {

			//Go through deckScore array and convert + sum the scores for each deck except last
			for (d = 0; d < lastDeck; d++) {
				if (deckScore[d] == 52) {
					totalEval += 52;
				} else if (deckScore[d] == 51) {
					totalEval += 26;
				}
			}
			if (deckScore[lastDeck] == deckLength) {
				totalEval += deckLength;
			} else if (deckScore[d] == deckLength - 1) {
				totalEval += deckLength == 1 ? 0 : Math.ceil(deckLength / 2);
			}
		}

		//This shouldn't be necessary
		if (isNaN(totalEval)) totalEval = 0;

		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + deckScore.reduce(function (acc, val) { return acc + val; }) + " correct)";

		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		} else {

			restoreCardsData();
			displayed = true;

			document.onkeydown = function (e) {

				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusCardScore(52 * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < amount - 1) moveFocusCardScore(52 * (curPage + 1));

				}

			};



		}

		//mouseover handlers
		for (var d = 0; d < amount; d++) {


			for (let i = 0; i < 52; i++) {
				$("#cardRecall" + Number(d * 52 + i)).mouseover(function (ev) {
					showCorrectCard(ev.target.id.match(/\d+/g));
				});
				$("#cardRecall" + Number(d * 52 + i)).mouseout(function (ev) {
					showChosenCard(ev.target.id.match(/\d+/g));
				});
			}
		}

		//show pages
		if (amount > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < amount; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusCardScore(" + 52 * i + ")'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br/><br /><br />";
			document.getElementById("menuScoreDiv").innerHTML = menuString;
			document.getElementById("menuRecallDiv").innerHTML = "";
		} else {
			document.getElementById("menuScoreDiv").innerHTML = "<br /><br /><br />";
		}

		$(".finishBtn").hide();
		document.getElementById("scoreRow").style.display = "block";

		if (skin.indexOf("analogue") > -1) {
			$("#cardsMemoTimeScore").css("color", "white");
		} else {
			$("#cardsMemoTimeScore").css("color", "black");
		}

		if (amount == 1) $("#cardsMemoTimeScore").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));

		//moveFocusCardScore(0);
		//move to first page
		displayPage(0, true);


	}



	function showCorrectCard(num) {
		var d = Math.floor(num / 52);
		var i = num - d * 52;
		var boneyardPos = getBoneyardPosition(d * 52 + i);
		if (boneyardPos == -1 || (cardList[d][i].cv != boneyardArray[boneyardPos].cv || cardList[d][i].cs != boneyardArray[boneyardPos].cs)) {
			document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/" + cardList[d][i].cs + getValueName(cardList[d][i].cv) + ".png";
		}
	}

	function showChosenCard(num) {
		var d = Math.floor(num / 52);
		var i = num - d * 52;
		var boneyardPos = getBoneyardPosition(d * 52 + i);
		if (boneyardPos == -1 || (cardList[d][i].cv != boneyardArray[boneyardPos].cv || cardList[d][i].cs != boneyardArray[boneyardPos].cs)) {
			if (boneyardPos == -1) {
				document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/back.png";
			} else {
				document.getElementById("cardRecall" + num).src = "Card images " + cardSet + "/" + boneyardArray[boneyardPos].cs + getValueName(boneyardArray[boneyardPos].cv) + ".png";
			}
		}
	}

	function lookupProperty(key, property) {
		for (j = 0; j < events.length; j++) {
			if (events[j].ref === key) {
				if (events[j].hasOwnProperty(property)) {
					return events[j][property];
				}
				else {
					return "";
				}

			}

		}
		return "";

	}

	function showCorrect(pos) {
		if (currentDiscipline.indexOf("N") > -1) {
			//get first of grouping
			var firstOfGroup = pos - (pos % grouping);
			for (var g = 0; g < grouping; g++) {
				var chosenAnswer = chosenAnswers[firstOfGroup + g];

				if (chosenAnswer != numberList[firstOfGroup + g] || chosenAnswer.length == 0) {
					document.getElementById("inpRecall" + (firstOfGroup + g)).classList.add(skin + "corrected");
					document.getElementById("inpRecall" + (firstOfGroup + g)).classList.remove(skin + "incorrect");
					document.getElementById("inpRecall" + (firstOfGroup + g)).value = numberList[firstOfGroup + g];

				}
			}
			/*
					else {
					//  document.getElementById("score" + (firstOfGroup+g)).className = skin + "score " + skin + "correct";
					}
			*/
		} else {
			//binary
			//get positions
			var positions = getMatrixPositions(pos);
			for (var g = 0; g < positions.length; g++) {
				var chosenAnswer = chosenAnswers[positions[g]];

				if (chosenAnswer != binaryList[positions[g]] || chosenAnswer.length == 0) {
					document.getElementById("inpRecall" + (positions[g])).classList.add(skin + "corrected");
					document.getElementById("inpRecall" + (positions[g])).classList.remove(skin + "incorrect");
					document.getElementById("inpRecall" + (positions[g])).value = binaryList[positions[g]];

				}
			}
		}
	}

	function showChosen(pos) {
		if (currentDiscipline.indexOf("N") > -1) {
			//get first of grouping
			var firstOfGroup = pos - (pos % grouping);
			for (var g = 0; g < grouping; g++) {
				var corrClass = "";
				var chosenAnswer = chosenAnswers[firstOfGroup + g];
				if (chosenAnswer == numberList[firstOfGroup + g] && chosenAnswer.length > 0) {
					corrClass = skin + "correct";
				}
				else {
					//nothing chosen
					if (chosenAnswer.length === 0) {
						corrClass = "";
					}
					else {

						corrClass = skin + "incorrect";
					}
				}
				//document.getElementById("inpRecall" + (firstOfGroup+g)).className = skin + "score " + corrClass;
				document.getElementById("inpRecall" + (firstOfGroup + g)).classList.remove(skin + "corrected");
				corrClass && document.getElementById("inpRecall" + (firstOfGroup + g)).classList.add(corrClass);

				document.getElementById("inpRecall" + (firstOfGroup + g)).value = chosenAnswers[firstOfGroup + g];

				/*
						if (skin.indexOf("analogue")>-1 && chosenAnswer != numberList[firstOfGroup+g] && chosenAnswer.length > 0) {
							document.getElementById('score' + (firstOfGroup+g)).innerHTML += "<span class='slash'><sub>x</sub><sup>" + correctAnswer + "</sup></span>";
						}
						*/
			}
		} else {
			//binary
			var positions = getMatrixPositions(pos);

			for (var g = 0; g < positions.length; g++) {
				var chosenAnswer = chosenAnswers[positions[g]];
				console.log(chosenAnswer + " " + positions[g] + " " + g)
				var corrClass = "";

				if (chosenAnswer == binaryList[positions[g]] && chosenAnswer.length > 0) {
					corrClass = skin + "correct";
				}
				else {
					//nothing chosen
					if (chosenAnswer.length === 0) {
						corrClass = "";
					}
					else {

						corrClass = skin + "incorrect";
					}
				}
				corrClass && document.getElementById("inpRecall" + (positions[g])).classList.add(corrClass);
				document.getElementById("inpRecall" + (positions[g])).classList.remove(skin + "corrected");
				document.getElementById("inpRecall" + (positions[g])).value = chosenAnswers[positions[g]];


			}

		}
	}


	function displayWordsScore() {


		if (resuming) {
			wordList = JSON.parse(localStorage.getItem("correctAnswers"));
			amount = localStorage.getItem("amount");
			wordsPerPage = wordsPerColumn * wordColumnsPerPage;
			numberOfPages = Math.ceil(amount / wordsPerPage);
		} else {
			saveWordsData();
		}

		var totalEval = 0;
		var correct = 0;
		var correctThisColumn = 0;
		var lastColumn = Math.floor(amount / wordsPerColumn);
		var lastCellInColumn = wordsPerColumn;
		var sequence = 0;
		curPage = 0;

		//collect (trimmed) answers into a new array
		chosenAnswers = [];

		if (resuming) {
			chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content
			for (i = 0; i < numberOfPages; i++) {


				//create a new page that can be hidden or shown
				var pageDiv = document.createElement("div");
				pageDiv.setAttribute("id", "page" + i + "Recall");

				//add table to hold the words
				var thisPageTable = document.createElement("table");
				thisPageTable.setAttribute("class", "wordsRecallTable");

				//add rows with cells
				for (j = 0; j < wordsPerColumn; j++) {
					var row = document.createElement("tr");
					for (k = 0; k < wordColumnsPerPage; k++) {
						var wordCell = document.createElement("td");
						var wordInput = document.createElement("input");

						var numberCell = document.createElement("td");
						var thisIndex = i * wordsPerPage + k * wordsPerColumn + j;

						if (thisIndex < wordList.length) {
							numberCell.innerHTML = Number(thisIndex + 1) + ".&nbsp;&nbsp;";
							numberCell.setAttribute("class", skin + "wordsNum");
							wordInput.setAttribute("id", "inpRecall" + thisIndex);
							wordInput.setAttribute("class", skin + "wordsRecall");
							wordInput.thisIndex = thisIndex;
							wordInput.addEventListener("click", function (e) {
								moveFocusWordsRecall(e.target.thisIndex);
							});


							wordCell.setAttribute("class", skin + "wordsRecallTD");
							wordCell.setAttribute("id", "tdRecall" + thisIndex);
							wordCell.appendChild(wordInput);
						}

						row.appendChild(numberCell);
						row.appendChild(wordCell);
					}
					thisPageTable.appendChild(row);
				}

				pageDiv.appendChild(thisPageTable);

				document.getElementById("scoreContentDiv").appendChild(pageDiv);

			}

			document.getElementById("recallContentDiv").innerHTML = "";
		} else {
			for (let i = 0; i < amount; i++) {
				chosenAnswers.push(document.getElementById("inpRecall" + i).value.trim().toLowerCase());
			}
		}



		//Find last column and cell within column

		for (var i = amount - 1; i >= 0; i--) {

			if (chosenAnswers[i].length > 0) {
				lastColumn = Math.floor(i / wordsPerColumn);
				lastCellInColumn = i % wordsPerColumn;
				console.log("last column is " + lastColumn);
				console.log("last cell in last column is " + lastCellInColumn);
				break;
			}


		}

		var columnScores = [];

		//Go through all words until last cell
		for (var i = 0; i < amount; i++) {
			console.log(i);
			document.getElementById("inpRecall" + i).classList = [skin + "wordsRecall"];
			document.getElementById("inpRecall" + i).setAttribute("readonly", "");

			var thisIsLastColumn = (i >= lastColumn * wordsPerColumn);

			if (chosenAnswers[i] == wordList[i].toLowerCase()) {
				//correct answer!
				if (thisIsLastColumn) {
					sequence++;
					console.log(chosenAnswers[i]);
				}
				correctThisColumn++;
				if (skin.indexOf('analogue') > -1) {
					//does nothing right now
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
				else {
					//display correct (green) background
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
			} else {

				//nothing entered! So just show correct word
				if (chosenAnswers[i].length == 0) {

					if (thisIsLastColumn) {
						sequence++;
						console.log("blank");
					}
					console.log(i + " - not entered");
					if (skin.indexOf('analogue') > -1) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');

						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('wordMarkingSup');
						var answer = document.createTextNode(wordList[i]);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					}
					else {

						//document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
					}
				}
				else {
					//incorrect answer!
					if (thisIsLastColumn) {
						sequence++;
						console.log(chosenAnswers[i]);
					}

					//add the chosen incorrect answer (with slash if analogue)      
					if (skin.indexOf('analogue') > -1) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');
						var markingSubSpan = document.createElement("sub");
						markingSubSpan.classList.add('wordMarkingSub');
						var x = document.createTextNode("x");
						markingSubSpan.appendChild(x);
						markingSpan.appendChild(markingSubSpan);
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('wordMarkingSup');
						var answer = document.createTextNode(wordList[i]);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					}
					else {
						document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

					}


				}
			}


			//Don't add any more scores after final cell
			if (i <= lastColumn * wordsPerColumn + lastCellInColumn) {
				//after each column, add 20 to total eval if all on row are correct
				if ((i + 1) % 20 == 0 || i == lastColumn * wordsPerColumn + lastCellInColumn) {
					correct += correctThisColumn;

					if (correctThisColumn == 20) {

						columnScores.push(20);
					} else if (!thisIsLastColumn || sequence == wordsPerColumn) {
						if (thisIsLastColumn) console.log("all words were filled in");
						//normal rules apply as this isn't last column (OR it is last column but all words were filled in)
						if (correctThisColumn == 19) {

							columnScores.push(10);
						} else {
							columnScores.push(0);
						}
					} else {
						console.log("special rules - sequence was " + sequence);
						//last column and not all were filled in - special rules
						if (sequence == correctThisColumn) {
							//all filled in are correct
							console.log("all filld in were correct");
							columnScores.push(correctThisColumn);
						} else if (sequence - 1 == correctThisColumn) {
							//just one is wrong: halve it and round up, or 0 if sequence is 1
							console.log("one was wrong");
							columnScores.push(sequence == 1 ? 0 : Math.ceil(correctThisColumn / 2));
						} else {
							//more than one mistake, so 0
							console.log("more than one was wrong");
							columnScores.push(0);
						}

					}
					correctThisColumn = 0;
				}
			}

		}

		totalEval = columnScores.reduce((acc, val) => acc + val);

		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		} else {


			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusWordsRecall(wordsPerPage * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusWordsRecall(wordsPerPage * (curPage + 1));

				}


			};

		}

		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < amount; m++) {
				if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
					$("#inpRecall" + m).mouseover(function (ev) {
						showCorrectWord(ev.target.id.match(/\d+/g));
					});
					$("#inpRecall" + m).mouseout(function (ev) {
						showChosenWord(ev.target.id.match(/\d+/g));
					});
				}
			}
		}


		//add chosen answers
		for (let i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).value = chosenAnswers[i];
		}

		//show pages
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusWordsRecall(" + wordsPerPage * i + ")'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br/><br /><br />";
			document.getElementById("menuScoreDiv").innerHTML = menuString;
			document.getElementById("menuRecallDiv").innerHTML = "";
		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}

		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

		$(".finishBtn").hide();


		document.getElementById("scoreRow").style.display = "block";

		//move to first page
		displayPage(0, true);
	}


	function displayDateScore() {


		if (resuming) {
			dateList = JSON.parse(localStorage.getItem("correctAnswers"));
			shuffledDateList = JSON.parse(localStorage.getItem("shuffledDateList"));
			amount = localStorage.getItem("amount");
			numberOfPages = Math.ceil(amount / datesPerPage);
		} else {
			saveDatesData();
		}

		var totalEval = 0;
		var correct = 0;
		curPage = 0;

		if (!isAnalogue()) {
			document.getElementById("scoreBox").classList.remove(skin + "memoHeight");
			document.getElementById("scoreBox").classList.add(skin + "memoHeightDates");
		}

		//collect answers into a new array
		chosenAnswers = [];

		if (resuming) {
			chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content
			for (i = 0; i < numberOfPages; i++) {
				//create a new page that can be hidden or shown
				var pageDiv = document.createElement("div");
				pageDiv.setAttribute("id", "page" + i + "Recall");
				//add table to hold the words
				var thisPageTable = document.createElement("table");
				thisPageTable.setAttribute("class", "datesRecallTable");
				//add rows with cells
				for (j = 0; j < datesPerPage; j++) {
					var row = document.createElement("tr");
					var thisIndex = i * datesPerPage + j;
					if (thisIndex < dateList.length) {
						var yearCell = document.createElement("td");
						var yearInput = document.createElement("input");
						var eventCell = document.createElement("td");
						yearInput.setAttribute("id", "inpRecall" + thisIndex);
						yearInput.setAttribute("size", 4);
						yearInput.setAttribute("maxlength", 4);
						eventCell.innerHTML = shuffledDateList[thisIndex].event;
						row.setAttribute("id", "trRecall" + thisIndex);
						yearInput.setAttribute("class", skin + "datesYearRecall");
						yearCell.setAttribute("class", skin + "datesRecallTD");
						eventCell.setAttribute("class", skin + "datesEventRecall");
						yearInput.thisIndex = thisIndex;
						yearInput.addEventListener("click", function (e) {
							moveFocusDatesRecall(e.target.thisIndex);
						});


						yearCell.appendChild(yearInput);
						row.appendChild(yearCell);
						row.appendChild(eventCell);
					}
					thisPageTable.appendChild(row);
				}
				pageDiv.appendChild(thisPageTable);
				document.getElementById("scoreContentDiv").appendChild(pageDiv);
			}
			document.getElementById("recallContentDiv").innerHTML = "";
		}

		for (let i = 0; i < amount; i++) {
			if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + i).value);
			document.getElementById("inpRecall" + i).setAttribute("readonly", "");
		}


		//Go through all dates

		for (var i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).classList = [skin + "datesYearRecall"];
			if (chosenAnswers[i] == shuffledDateList[i].year) {
				console.log(i + " - correct");
				correct++;
				totalEval++;
				if (skin.indexOf('analogue') > -1) {
					//does nothing right now
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
				else {
					//display correct (green) background
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
			} else {

				//nothing entered, just show correct word
				if (chosenAnswers[i].length == 0) {
					console.log(i + " - not entered");
					if (isAnalogue()) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');

						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('dateMarkingSup');
						var answer = document.createTextNode(dateList[i].year);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("inpRecall" + i).parentNode.appendChild(markingSpan);
					}
					else {
						//document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
					}
				}
				else {
					console.log(i + " - incorrect");
					totalEval -= 0.5;
					//add the chosen incorrect answer (with slash if analogue)      
					if (isAnalogue()) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');
						var markingSubSpan = document.createElement("sub");
						markingSubSpan.classList.add('dateMarkingSub');
						var x = document.createTextNode("x");
						markingSubSpan.appendChild(x);
						markingSpan.appendChild(markingSubSpan);
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('dateMarkingSup');
						var answer = document.createTextNode(dateList[i].year);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("inpRecall" + i).parentNode.appendChild(markingSpan);
					}
					else {
						document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

					}


				}
			}

		}

		totalEval = totalEval > 0 ? totalEval : 0;

		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		} else {

			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusDatesRecall(datesPerPage * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusDatesRecall(datesPerPage * (curPage + 1));

				}


			};

		}

		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < amount; m++) {
				if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
					$("#inpRecall" + m).mouseover(function (ev) {
						showCorrectDate(ev.target.id.match(/\d+/g));
					});
					$("#inpRecall" + m).mouseout(function (ev) {
						showChosenDate(ev.target.id.match(/\d+/g));
					});
				}
			}
		}


		//add chosen answers
		for (let i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).value = chosenAnswers[i];
		}

		//show pages
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusDatesRecall(" + datesPerPage * i + ")'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br />";
			document.getElementById("menuScoreDiv").innerHTML = menuString;
			document.getElementById("menuRecallDiv").innerHTML = "";
		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}

		document.getElementById("spanScore").innerHTML = Math.ceil(totalEval);
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

		$(".finishBtn").hide();
		document.getElementById("scoreRow").style.display = "block";

		//display memo time
		if (skin.indexOf('analogue') > -1) {
			$("#cardsMemoTimeScore").css("color", "white");
		} else {
			$("#cardsMemoTimeScore").css("color", "black");
		}
		$("#cardsMemoTime").text("Memorisation time: " + (memoTimeTaken / 1000).toFixed(2));

		//move to first page
		displayPage(0, true);
	}

	function displayNamesScore() {				
		if (resuming) {
			nameList = JSON.parse(localStorage.getItem("nameList"));
			shuffledNameList = JSON.parse(localStorage.getItem("shuffledNameList"));
			amount = localStorage.getItem("amount");
			facesAmount = Math.ceil(amount / 2);
			namesPerPage = namesPerRow * nameRowsPerPage;
			numberOfPages = Math.ceil(facesAmount / namesPerPage);
		} else {
			saveNamesData();
		}

		var totalEval = 0;
		var correct = 0;
		curPage = 0;

		chosenFirstNames = [];
		chosenSurnames = [];

		if (resuming) {
			//get chosen answers into array from storage
			chosenFirstNames = JSON.parse(localStorage.getItem("chosenFirstNames"));
			chosenSurnames = JSON.parse(localStorage.getItem("chosenSurnames"));
		
			//add the recall content
			for (i = 0; i < numberOfPages; i++) {

			//create a new page that can be hidden or shown
			var pageDiv = document.createElement("div");
			pageDiv.setAttribute("id", "page" + i + "Recall");
			//add table to hold the names
			var thisPageTable = document.createElement("table");
			thisPageTable.setAttribute("class", "nameTable");

			//add rows with cells
			for (j = 0; j < nameRowsPerPage; j++) {
				var faceRow = document.createElement("tr");
				var nameRow = document.createElement("tr");

				for (k = 0; k < namesPerRow; k++) {
					var thisIndex = i * namesPerPage + j * nameRowsPerPage + k;
					if (thisIndex < nameList.length) {
						var faceCell = document.createElement("td");
						faceCell.classList.add("faceMemo");
						var faceImg = document.createElement("img");

						faceImg.setAttribute("src", shuffledNameList[thisIndex].imageURL);
					
						if (competitionMode) {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "128");
						} else {
							faceImg.setAttribute("height", "128");
							faceImg.setAttribute("width", "101.5");
						}

						var nameCell = document.createElement("td");

						// nameCell.classList.add("nameRecallTD");
						// nameCell.classList.add(skin + "nameRecallTD");

						var nameInputFCell = document.createElement("input");
						nameInputFCell.classList.add("nameRecall");
						nameInputFCell.classList.add(skin + "nameRecall");
						nameInputFCell.setAttribute("id", "inpRecallF" + thisIndex);
						nameInputFCell.thisIndex = thisIndex;
						nameInputFCell.addEventListener("click", function (e) {
							moveFocusNamesRecall(e.target.thisIndex, true);
						});
						nameInputFCell.addEventListener("dblclick", function (e) {
							toggleMark(e.target);
						});

						var nameInputSCell = document.createElement("input");
						nameInputSCell.classList.add("nameRecall");
						nameInputSCell.classList.add(skin + "nameRecall");
						nameInputSCell.setAttribute("id", "inpRecallS" + thisIndex);
						nameInputSCell.thisIndex = thisIndex;
						nameInputSCell.addEventListener("click", function (e) {
							moveFocusNamesRecall(e.target.thisIndex, false);
						});
						nameInputSCell.addEventListener("dblclick", function (e) {
							toggleMark(e.target);
						});
						faceCell.appendChild(faceImg);
						faceCell.setAttribute("id", "tdFace" + thisIndex);

						
						nameCell.setAttribute("id", "tdRecall" + thisIndex);

					}
					nameCell.appendChild(nameInputFCell);
					nameCell.appendChild(nameInputSCell);
					nameRow.appendChild(nameCell);
					faceRow.appendChild(faceCell);
				}
				thisPageTable.appendChild(faceRow);
				thisPageTable.appendChild(nameRow);
			}

			pageDiv.appendChild(thisPageTable);

			document.getElementById("scoreContentDiv").appendChild(pageDiv);
			}

		} else {
			//get chosen answers into array from recall boxes
			for (let i = 0; i < facesAmount; i++) {
				chosenFirstNames.push(document.getElementById("inpRecallF" + i).value);
				chosenSurnames.push(document.getElementById("inpRecallS" + i).value);
			}
		}

	

		//Go through all names

		for (var i = 0; i < facesAmount; i++) {
			document.getElementById("inpRecallF" + i).classList = [skin + "nameRecall"];
			document.getElementById("inpRecallS" + i).classList = [skin + "nameRecall"];
			if (chosenFirstNames[i].toLowerCase() == accent_fold(shuffledNameList[i].firstname.toLowerCase())) {
				correct++;
				if (skin.indexOf('analogue') > -1) {
					//nothing	
					document.getElementById("inpRecallF" + i).classList.add(skin + "correct");
				}
				else {
					//display correct (green) background
					document.getElementById("inpRecallF" + i).classList.add(skin + "correct");
				}
			} else {
				//nothing entered, just show correct name
				if (chosenFirstNames[i].length == 0) {
					console.log(i + " - first name not entered");
					if (skin.indexOf('analogue') > -1) {
						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slashNames');
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('nameFMarkingSup');
						var answer = document.createTextNode(shuffledNameList[i].firstname);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					}
					else {
						//	document.getElementById("inpRecallF" + i).classList.add(skin + "incorrect");		
					}
				} else {
					console.log(i + " - first name incorrect");
					//add the chosen incorrect answer (with slash if analogue)      
					if (skin.indexOf('analogue') > -1) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slashNames');
						var markingSubSpan = document.createElement("sub");
						markingSubSpan.classList.add('nameFMarkingSub');
						var x = document.createTextNode("x");
						markingSubSpan.appendChild(x);
						markingSpan.appendChild(markingSubSpan);
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('nameFMarkingSup');
						var answer = document.createTextNode(shuffledNameList[i].firstname);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					} else {
						document.getElementById("inpRecallF" + i).classList.add(skin + "incorrect");
					}
				}
			}

			if (chosenSurnames[i].toLowerCase() == accent_fold(shuffledNameList[i].surname.toLowerCase())) {
				console.log(i + " - correct");
				correct++;
				if (skin.indexOf('analogue') > -1) {
					//does nothing right now
					document.getElementById("inpRecallS" + i).classList.add(skin + "correct");
				}
				else {
					//display correct (green) background
					document.getElementById("inpRecallS" + i).classList.add(skin + "correct");
				}
			} else {
				//nothing entered, just show correct name
				if (chosenSurnames[i].length == 0) {
					console.log(i + " - surname not entered");
					if (skin.indexOf('analogue') > -1) {
						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slashNames');
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('nameSMarkingSup');
						var answer = document.createTextNode(shuffledNameList[i].surname);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					} else {
						//	document.getElementById("inpRecallS" + i).classList.add(skin + "incorrect");		
					}
				} else {
					console.log(i + " - surname incorrect");
					//add the chosen incorrect answer (with slash if analogue)      
					if (skin.indexOf('analogue') > -1) {
						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slashNames');
						var markingSubSpan = document.createElement("sub");
						markingSubSpan.classList.add('nameSMarkingSub');
						var x = document.createTextNode("x");
						markingSubSpan.appendChild(x);
						markingSpan.appendChild(markingSubSpan);
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('nameSMarkingSup');
						var answer = document.createTextNode(shuffledNameList[i].surname);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					} else {
						document.getElementById("inpRecallS" + i).classList.add(skin + "incorrect");
					}
				}
			}
		}

		totalEval = correct;

		//** adjust total eval here according to anti-guessing rules
	var allNames = (chosenSurnames.concat(chosenFirstNames)).filter(v => v !== "");

		while (allNames.length > 0) {
			
			var curLength = allNames.length;
			allNames = allNames.filter(function(v){ return v !== allNames[0]; });
			var occurrences = curLength - allNames.length;
			if (occurrences > 2) {				
				totalEval -= 0.5*(occurrences-2);
			}
			
		}

		if (totalEval < 0) totalEval = 0;	
		

		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		} else {

			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusNamesRecall(namesPerPage * (curPage - 1));					
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusNamesRecall(namesPerPage * (curPage + 1));
				}
			};
		}

			//for all recall boxes, remove selection highlight and set to read only
			for (let i = 0; i < facesAmount; i++) {
			document.getElementById("inpRecallF" + i).classList.remove(skin + "namesSelectedRecall");
			document.getElementById("inpRecallS" + i).classList.remove(skin + "namesSelectedRecall");
			document.getElementById("inpRecallF" + i).setAttribute("readonly", "");
			document.getElementById("inpRecallS" + i).setAttribute("readonly", "");
			
		}


		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < facesAmount; m++) {
				if (!(document.getElementById("inpRecallF" + m).classList.contains(skin + "correct"))) {
					$("#inpRecallF" + m).mouseover(function (ev) {
						showCorrectName(ev.target.id.match(/\d+/g), true);
					});
					$("#inpRecallF" + m).mouseout(function (ev) {
						showChosenName(ev.target.id.match(/\d+/g), true);
					});
				}
				if (!(document.getElementById("inpRecallS" + m).classList.contains(skin + "correct"))) {
					$("#inpRecallS" + m).mouseover(function (ev) {
						showCorrectName(ev.target.id.match(/\d+/g), false);
					});
					$("#inpRecallS" + m).mouseout(function (ev) {
						showChosenName(ev.target.id.match(/\d+/g), false);
					});
				}
			}
		}

		//add chosen answers
		for (let i = 0; i < facesAmount; i++) {
			document.getElementById("inpRecallF" + i).value = chosenFirstNames[i];
			document.getElementById("inpRecallS" + i).value = chosenSurnames[i];
		}

		//show pages
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusNamesRecall(" + namesPerPage * i + ", true)'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br/>";
			document.getElementById("menuScoreDiv").innerHTML = menuString;
			document.getElementById("menuRecallDiv").innerHTML = "";
		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}

		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

		$(".finishBtn").hide();
		document.getElementById("scoreRow").style.display = "block";

		//move to first page
		displayPage(0, true);
	}


	function displayImagesScore() {

		if (resuming) {
			imageArray = JSON.parse(localStorage.getItem("imageArray"));
			answerArray = JSON.parse(localStorage.getItem("answerArray"));
			amount = localStorage.getItem("amount");
			numberOfPages = Math.ceil(amount / imagesPerPage);
		} else {
			saveImagesData();
		}

		var totalEval = 0;
		var correct = 0;
		var correctThisRow = 0;
		var rowFailed = false;
		curPage = 0;

		//collect answers into a new array
		chosenAnswers = [];

		if (resuming) {
			chosenAnswers = JSON.parse(localStorage.getItem("chosen"));

			//add the recall content

			var imagesRecallString = "";

			for (i = 0; i < numberOfPages; i++) {
				if (i < numberOfPages - 1) {
					imagesOnThisPage = imagesPerPage;
				}
				else {
					imagesOnThisPage = amount - i * imagesPerPage;
				}

				imagesRecallString += "<div id='page" + i + "Recall'><table class='imageTable' id='recallTable" + i + "'>";


				for (var j = 0; j < imagesOnThisPage; j++) {
					//if we haven't reached the end

					//add row num if needed
					if (j % 5 == 0) {
						imagesRecallString += "<tr><td class='imageRowNumCell'>" + (Math.floor((i * imagesPerPage / 5) + j / 5) + 1) + "</td>";
					}


					//add the next image and a box below it
					//	imagesRecallString += "<td id='tdRecall" + Number(i*imagesPerPage+j) + "'><table><tr><td><img class='imageClass' id='imgRecall" + Number(i*imagesPerPage+j) + "'  src='IAM Images/" + imageArray[i*imagesPerPage+j] + "' height=80></td></tr><tr><td id='inpRecall" + Number(i*imagesPerPage+j) + "'><input type='text'  class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i*imagesPerPage+j) + ")' oninput='checkMoveFocusImagesRecall(" + (i*imagesPerPage+j+1) + ")'></td></tr></table></td>";

					//add image with box before it 
					imagesRecallString += "<td class='" + skin + "imagesRecallTD' id='tdRecall" + Number(i * imagesPerPage + j) + "'><input type='text' id='inpRecall" + Number(i * imagesPerPage + j) + "' class='" + skin + "imagesRecall' maxlength='1' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' oninput='checkMoveFocusImagesRecall(" + (i * imagesPerPage + j + 1) + ")'><img class='imageClass' onclick='moveFocusImagesRecall(" + (i * imagesPerPage + j) + ")' id='imgRecall" + Number(i * imagesPerPage + j) + "'  src='IAM Images/" + imageArray[Math.floor((i * imagesPerPage + j) / 5) * 5 + answerArray[i * imagesPerPage + j] - 1] + "' height=80></td>";


					//close the row if needed and spacer row
					if ((j + 1) % 5 == 0) {
						if (j + 1 == imagesOnThisPage) {
							imagesRecallString += "</tr>";
						} else {
							imagesRecallString += "</tr><tr><td colspan='6' height='20px'></td></tr>";
						}
					}

				}
				imagesRecallString += "</table><br /><button class='btn btn-primary finishBtn' onclick='finishRecall();'>Finish</button></div>";
				//	imagesRecallString += "</table><br /></div>";
			}

			imagesRecallString += "</div>";
			document.getElementById("scoreContentDiv").innerHTML = imagesRecallString;

			document.getElementById("recallContentDiv").innerHTML = "";
		}

		//display answers in the boxes
		for (let i = 0; i < amount; i++) {
			if (!resuming) chosenAnswers.push(document.getElementById("inpRecall" + i).value);
			document.getElementById("inpRecall" + i).setAttribute("readonly", "");
			document.getElementById("inpRecall" + i).classList.remove(skin + "imagesSelected");
		}


		//Go through all images

		for (var i = 0; i < amount; i++) {
			if (chosenAnswers[i] == answerArray[i]) {
				console.log(i + " - correct");
				correctThisRow++;
				if (skin.indexOf('analogue') > -1) {
					//does nothing right now
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
				else {
					//display correct (green) background
					document.getElementById("inpRecall" + i).classList.add(skin + "correct");
				}
			} else {

				//nothing entered, just show correct number
				if (chosenAnswers[i].length == 0) {
					console.log(i + " - not entered");
					if (skin.indexOf('analogue') > -1) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');

						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('imageMarkingSup');
						var answer = document.createTextNode(answerArray[i]);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					}
					else {
						//	document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");		
					}
				}
				else {
					console.log(i + " - incorrect");
					rowFailed = true;
					//add the chosen incorrect answer to the score row string (with slash if analogue)      
					if (skin.indexOf('analogue') > -1) {

						var markingSpan = document.createElement("span");
						markingSpan.classList.add('slash');
						var markingSubSpan = document.createElement("sub");
						markingSubSpan.classList.add('imageMarkingSub');
						var x = document.createTextNode("x");
						markingSubSpan.appendChild(x);
						markingSpan.appendChild(markingSubSpan);
						var markingSupSpan = document.createElement("sup");
						markingSupSpan.classList.add('imageMarkingSup');
						var answer = document.createTextNode(answerArray[i]);
						markingSupSpan.appendChild(answer);
						markingSpan.appendChild(markingSupSpan);
						document.getElementById("tdRecall" + i).appendChild(markingSpan);
					}
					else {
						document.getElementById("inpRecall" + i).classList.add(skin + "incorrect");

					}


				}
			}
			//after each row, add 5 to total eval if all on row are correct
			if ((i + 1) % 5 == 0) {
				correct += correctThisRow;

				if (correctThisRow == 5) {
					totalEval += 5;
				} else {
					//deduct 1 if row failed
					if (rowFailed) totalEval--;
				}
				correctThisRow = 0;
				rowFailed = false;
			}


		}

		//Score cannot be negative
		totalEval = totalEval < 0 ? 0 : totalEval;

		if (!resuming) {
			document.getElementById("scoreContentDiv").innerHTML = document.getElementById("recallContentDiv").innerHTML;
			document.getElementById("recallContentDiv").innerHTML = "";
		} else {

			document.onkeydown = function (e) {
				//if [ is pressed, previous page
				if (e.key == ',') {
					e.preventDefault();
					if (curPage > 0) moveFocusImagesRecall(imagesPerPage * (curPage - 1));
					//if (curPage>0) displayPage(curPage-1);
				}


				//if ] is pressed, next page
				if (e.key == '.') {
					e.preventDefault();
					if (curPage < numberOfPages - 1) moveFocusImagesRecall(imagesPerPage * (curPage + 1));

				}


			};

		}


		//mouseover handlers here for digital only
		if (skin.indexOf('digital') > -1) {
			for (var m = 0; m < amount; m++) {
				if (!(document.getElementById("inpRecall" + m).classList.contains(skin + "correct"))) {
					$("#inpRecall" + m).mouseover(function (ev) {
						showCorrectImage(ev.target.id.match(/\d+/g));
					});
					$("#inpRecall" + m).mouseout(function (ev) {
						showChosenImage(ev.target.id.match(/\d+/g));
					});
				}
			}
		}


		//add chosen answers to score page
		for (let i = 0; i < amount; i++) {
			document.getElementById("inpRecall" + i).value = chosenAnswers[i];
		}

		//show pages
		if (numberOfPages > 1) {

			var menuString = "<ul class='menu'>";

			for (var i = 0; i < numberOfPages; i++) {
				menuString += "<li><a href='#' id='page" + i + "tablinkRecall' class='" + skin + "pagelink' onclick='moveFocusImagesRecall(" + imagesPerPage * i + ")'>" + (i + 1) + "</a></li>";

			}
			menuString += "</ul><br/>";
			document.getElementById("menuScoreDiv").innerHTML = menuString;
			document.getElementById("menuRecallDiv").innerHTML = "";
		} else {
			document.getElementById("menuScoreDiv").innerHTML = "";
		}

		document.getElementById("spanScore").innerHTML = totalEval;
		document.getElementById("spanCorrect").innerHTML = "&nbsp;&nbsp;(" + correct + " correct)";

		$(".finishBtn").hide();
		document.getElementById("scoreRow").style.display = "block";

		moveFocusImagesRecall(0);
	}

	function showChosenImage(num) {
		$("#inpRecall" + num).val(chosenAnswers[num]);
		if (document.getElementById("inpRecall" + num).value.length > 0) {
			document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
		}
		document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");
	}

	function showCorrectImage(num) {
		$("#inpRecall" + num).val(answerArray[num]);
		document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
		document.getElementById("inpRecall" + num).classList.add(skin + "corrected");
	}

	function showChosenWord(num) {
		$("#inpRecall" + num).val(chosenAnswers[num]);
		if (document.getElementById("inpRecall" + num).value.length > 0) {
			document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
		}
		document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");
	}

	function showCorrectWord(num) {
		$("#inpRecall" + num).val(wordList[num]);
		document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
		document.getElementById("inpRecall" + num).classList.add(skin + "corrected");
	}



	function showChosenDate(num) {

		$("#inpRecall" + num).val(chosenAnswers[num]);
		if (document.getElementById("inpRecall" + num).value.length > 0) {
			document.getElementById("inpRecall" + num).classList.add(skin + "incorrect");
		}
		document.getElementById("inpRecall" + num).classList.remove(skin + "corrected");

	}


	function showCorrectDate(num) {
		$("#inpRecall" + num).val(shuffledDateList[num].year);

		document.getElementById("inpRecall" + num).classList.remove(skin + "incorrect");
		document.getElementById("inpRecall" + num).classList.add(skin + "corrected");



	}

	function showChosenName(num, isFirstname) {
		if (isFirstname) {
			$("#inpRecallF" + num).val(chosenFirstNames[num]);
			if (document.getElementById("inpRecallF" + num).value.length > 0) {
				document.getElementById("inpRecallF" + num).classList.add(skin + "incorrect");
			}
			document.getElementById("inpRecallF" + num).classList.remove(skin + "corrected");
		} else {
			$("#inpRecallS" + num).val(chosenSurnames[num]);
			if (document.getElementById("inpRecallS" + num).value.length > 0) {
				document.getElementById("inpRecallS" + num).classList.add(skin + "incorrect");
			}
			document.getElementById("inpRecallS" + num).classList.remove(skin + "corrected");
		}
	}

	function showCorrectName(num, isFirstname) {
		if (isFirstname) {
			$("#inpRecallF" + num).val(shuffledNameList[num].firstname);

			document.getElementById("inpRecallF" + num).classList.remove(skin + "incorrect");
			document.getElementById("inpRecallF" + num).classList.add(skin + "corrected");
		}
		else {
			$("#inpRecallS" + num).val(shuffledNameList[num].surname);
			document.getElementById("inpRecallS" + num).classList.remove(skin + "incorrect");
			document.getElementById("inpRecallS" + num).classList.add(skin + "corrected");
		}

	}



	function timeFormat(t) {
		//only showing minutes and seconds
		ns = (((t) / 1e3)), m = (ns / 60) >> 0, s = Math.floor(ns - m * 60);
		//return m + ":" + ((""+s).length>1?"":"0")+s;
		return (("" + m).length > 1 ? "" : "0") + m + ":" + (("" + s).length > 1 ? "" : "0") + s;
	}

	function timeFormatLong(t) {
		ns = (((t) / 1e3)), m = (ns / 60) >> 0, s = Math.floor(ns - m * 60), hs = Math.floor((ns - (Math.floor(ns))) * 100);
		return m + ":" + (("" + s).length > 1 ? "" : "0") + s + ":" + (("" + hs).length > 1 ? "" : "0") + hs;
	}


	function changeSelHColour() {
		hiColour = document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;
		localStorage.setItem("hiColour", hiColour);
		//document.getElementById("selHColour").style.backgroundColor = document.getElementById("selHColour").options[document.getElementById("selHColour").selectedIndex].value;
		document.getElementById("selHColour").style.backgroundColor = this[hiColour];

		//change css variable
		document.body.style.setProperty("--highlightColor", this[hiColour]);
		updatePreview();


	}

	function isAnalogue() {
		return skin.indexOf('analogue') > -1;
	}

	function changeSkin() {
		//skin = document.getElementById("selSkin").options[document.getElementById("selSkin").selectedIndex].value;
		document.body.className = skin;
		document.getElementById("memoBox").className = "col-md-10 jumbotron " + skin + "boxA " + skin + "memoHeight";
		document.getElementById("recallBox").className = "col-md-10 " + skin + "boxB " + skin + "memoHeight";
		document.getElementById("scoreBox").className = "col-md-10 " + skin + "boxB " + skin + "memoHeight";
		//  document.getElementById("preview").className = "centred " + skin + "box";
		document.getElementById("settingsBox").className = "col-md-10 jumbotron settings text-center " + skin + "boxA " + skin + "memoHeight";
		document.getElementById("countdownBox").className = "col-md-10 jumbotron countdown text-center " + skin + "boxB " + skin + "memoHeight";
		//document.getElementById("wrapper").className = skin + "memoHeight";
		//  document.getElementById("memoRow").className = "row " + skin + "container";
		if (skin.indexOf('analogue') > -1) {
			document.getElementById('digital1MemoTimeOuter').style.display = 'none';
			//	document.getElementById('digital1MemoTimeOuter').innerHTML = "";
			document.getElementById('analogue1MemoTimeOuter').style.display = 'block';
			document.getElementById('digital1RecallTimeOuter').style.display = 'none';
			document.getElementById('analogue1RecallTimeOuter').style.display = 'block';
		} else {
			document.getElementById('digital1MemoTimeOuter').style.display = 'inline';
			//	document.getElementById('digital1MemoTimeOuter').innerHTML = "Memorisation time remaining:";
			document.getElementById('analogue1MemoTimeOuter').style.display = 'none';
			document.getElementById('digital1RecallTimeOuter').style.display = 'inline';
			document.getElementById('analogue1RecallTimeOuter').style.display = 'none';
		}
		/*
	
	
		} else {
	
		}
		if (skin.indexOf('analogue')>-1) {
				document.getElementById('digital1ScoreTimeOuter').style.display = 'none';
				document.getElementById('analogue1ScoreTimeOuter').style.display = 'block';
			} else {
				document.getElementById('digital1ScoreTimeOuter').style.display = 'inline';
				document.getElementById('analogue1ScoreTimeOuter').style.display = 'none';
			}
			*/
		updatePreview();

	}


	function displayPage(curPage, isRecall) {
		if (currentDiscipline.indexOf("C") > -1) numberOfPages = amount;

		for (var i = 0; i < numberOfPages; i++) {
			if (i == curPage) {
				document.getElementById("page" + i + (isRecall ? "Recall" : "")).style.display = "block";

				if (numberOfPages > 1) {
					//highlight this page tab
					document.getElementById("page" + i + "tablink" + (isRecall ? "Recall" : "")).className = skin + "pagelinkred";
				}
			}
			else {
				document.getElementById("page" + i + (isRecall ? "Recall" : "")).style.display = "none";
				if (numberOfPages > 1) {
					//un-highlight this page tab
					document.getElementById("page" + i + "tablink" + (isRecall ? "Recall" : "")).className = skin + "pagelink";
				}
			}
		}
	}

	function resumeAttempt() {
		resuming = true;

		//get skin
		skin = getSkin();

		//remove logo row if skin is analogue
		
		if (skin.indexOf("analogue") > -1) {
			document.getElementById("logoRow").style = "display:none";
			document.getElementById("topMargin").style = "display:block";
			document.getElementById("btnBackToSelection2").style = "display:block";
		}

		//get discipline back
		currentDiscipline = localStorage.getItem("discipline");

		var titleElements = document.getElementsByClassName("disciplineTitle");
		var title = lookupProperty(currentDiscipline, "label");
		for (var i = 0; i < titleElements.length; i++) {
			titleElements[i].innerHTML = title;
		}

		titleElements = document.getElementsByClassName("disciplineTitleMemo");
		title = lookupProperty(currentDiscipline, "label");
		for (var i = 0; i < titleElements.length; i++) {
			titleElements[i].innerHTML = title;
		}

		//get phase
		var phase = localStorage.getItem("phase");

		// get mark array
		if (JSON.parse(localStorage.getItem("markArray"))) {
			markArray = JSON.parse(localStorage.getItem("markArray"));
		} else {
			markArray = [];
		}

		//change skin
		changeSkin();

		//get grouping
		grouping = Number(localStorage.getItem("grouping"));
		groupingH = Number(localStorage.getItem("groupingH"));
		groupingW = Number(localStorage.getItem("groupingW"));
		cardSet = localStorage.getItem("cardSet");
		blnImageSkip = localStorage.getItem("blnImageSkip");

		//get colour back
		hiColour = localStorage.getItem("hiColour");
		document.body.style.setProperty("--highlightColor", this[hiColour]);

		//go to relevant phase
		if (phase == "memo") {
			startMemoCountdown();
		} else if (phase == "recall") {
			startRecallCountdown()
		} else {
			displayScore();
		}
	}

	function resetPreload() {
		if (competitionMode) {
			document.getElementById('btnPreload').removeAttribute('disabled'); 
            document.getElementById('btnStartMemoCountdown').setAttribute('disabled', '');
            document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
		}
	}

	function handleStartClick() {

		if (competitionMode) {
			startMemoCountdown();
		}
		else {
			document.getElementById('btnStartMemoCountdown').setAttribute('disabled', '');
			document.getElementById("btnStartMemoCountdown").innerText = "Loading images... Please wait";
            document.getElementById("btnStartMemoCountdown").classList.remove("glowButton");
			preloadData();
		}
	}

	function applyMiniGroupings() {

		if (currentDiscipline.indexOf("B") > -1) {
			if (!document.getElementById("inpMiniGroupingsBin").value) {
				miniGroupings = [];
				localStorage.setItem("miniGroupings	", JSON.stringify(miniGroupings));
			} else {
				miniGroupings = document.getElementById("inpMiniGroupingsBin").value.split("-");
				localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));

			}
		} else {
			if (!document.getElementById("inpMiniGroupings").value) {
				miniGroupings = [];
				localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
			} else {
				miniGroupings = document.getElementById("inpMiniGroupings").value.split("-");
				localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));
			}
		}
		//	document.getElementById("inpImgsPerLocus").value = "";	

		updatePreview();
	}

	function applySeparation() {
		var sepString = document.getElementById("inpSeparation").value;
		if (sepString) {
			separations = sepString.split("-").map(Number).reduce(function (r, a) {
				r.push((r.length && r[r.length - 1] || 0) + a);
				return r;
			}, []);
			//recurring
			if (separations.length ==1) {
				cur = separations[0];
				while (cur + separations[0] < grouping) {
					separations.push(cur+separations[0]);
					cur += separations[0];
				}
			}
		} else {
			separations = [];
		}
		localStorage.setItem("separations", JSON.stringify(separations));
		updatePreview();
	}

	function applySeparationBin() {
		if (!groupingW) groupingW = Number(document.getElementById("selBinGroupingW").options[document.getElementById("selBinGroupingW").selectedIndex].value);
		var sepString = document.getElementById("inpSeparationBin").value;
		if (sepString) {
			separations = document.getElementById("inpSeparationBin").value.split("-").map(Number).reduce(function (r, a) {
				r.push((r.length && r[r.length - 1] || 0) + a);
				return r;
			}, []);
			//recurring
				if (separations.length ==1) {
				cur = separations[0];
				while (cur + separations[0] < groupingW) {
					separations.push(cur+separations[0]);
					cur += separations[0];
				}
			}
		} else {
			separations = [];
		}
		localStorage.setItem("separationsBin", JSON.stringify(separations));
		updatePreview();
	}



	function applyImgsPerLocus() {

		imgsPerLocus = Number(document.getElementById("inpImgsPerLocus").value);
		grouping = Number(document.getElementById("selGrouping").options[document.getElementById("selGrouping").selectedIndex].value);
		miniGroupings = [];
		for (var i = 0; i < imgsPerLocus; i++) {
			miniGroupings.push(grouping);

		}

		localStorage.setItem("miniGroupings", JSON.stringify(miniGroupings));

		if (currentDiscipline.indexOf("B") > -1) {
			document.getElementById("inpMiniGroupingsBin").value = "";
		} else {
			document.getElementById("inpMiniGroupings").value = "";
		}



		updatePreview();
	}

	function restoreMarks() {

		if (currentDiscipline.indexOf("C") > -1) {
			for (var i = 0; i < amount; i++) {
				//remove mark by default
				document.getElementById("cardRecall" + i).classList.remove('markCards');

				//add mark if it should be there
				if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("cardRecall" + i));
			}

		} else if (currentDiscipline.indexOf("F") > -1) {
			for (var i = 0; i < amount; i++) {

				//remove mark by default
				if (i % 2 == 0) {
					document.getElementById("inpRecallF" + Math.floor(i/2)).classList.remove('markOther');
				} else {
					document.getElementById("inpRecallS" + Math.floor(i/2)).classList.remove('markOther');
				}
				//add mark if it should be there
				if (i % 2 == 0) {
					if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecallF" + Math.floor(i/2)));
				} else {
					if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecallS" + Math.floor(i/2)));
				}
			
			}

		} else {
			for (var i = 0; i < amount; i++) {

				//remove mark by default
				document.getElementById("inpRecall" + i).classList.remove('markOther');

				//add mark if it should be there
				if (markArray.indexOf(i) > -1) toggleMark(document.getElementById("inpRecall" + i));
			}
		}
	}

	/*
	function shiftMarksForward() {
		markArray = markArray.map(el => if el+1);
		restoreMarks();
	}
	
	function shiftMarksBackward() {
		markArray = markArray.map(el => el-1);
		restoreMarks();
	}
	*/

function getCaretPosition (oField) {

// Initialize
var iCaretPos = 0;

// IE Support
if (document.selection) {

  // Set focus on the element
  oField.focus();

  // To get cursor position, get empty selection range
  var oSel = document.selection.createRange();

  // Move selection start to 0 position
  oSel.moveStart('character', -oField.value.length);

  // The caret position is selection length
  iCaretPos = oSel.text.length;
}

// Firefox support
else if (oField.selectionStart || oField.selectionStart == '0')
  iCaretPos = oField.selectionStart;

// Return results
return iCaretPos;
}

	function toggleMark(el) {
		
		if (currentDiscipline.indexOf("C") > -1) {
			if (el.classList.contains('markCards')) {
				el.classList.remove('markCards');
				var index = markArray.indexOf(Number(el.id.match(/\d+/g)[0]));
				markArray.splice(index, 1);
			} else {
				el.classList.add('markCards');
				markArray.push(Number(el.id.match(/\d+/g)[0]));
			}

		} else if (currentDiscipline.indexOf("F") > -1) {
			if (el.classList.contains('markOther')) {
				el.classList.remove('markOther');
				var index = markArray.indexOf(Number(el.id.match(/\d+/g)[0]) * 2 + ((el.id.indexOf("F")>-1) ? 0 : 1));
				
				markArray.splice(index, 1);
			} else {
				el.classList.add('markOther');
				markArray.push(Number(el.id.match(/\d+/g)[0]) * 2 + ((el.id.indexOf("F")>-1) ? 0 : 1));
			}
		} else {
			if (el.classList.contains('markOther')) {
				el.classList.remove('markOther');
				var index = markArray.indexOf(Number(el.id.match(/\d+/g))[0]);
				markArray.splice(index, 1);
			} else {
				el.classList.add('markOther');
				markArray.push(Number(el.id.match(/\d+/g)[0]));
			}
		}

		//save marks
		localStorage.setItem("markArray", JSON.stringify(markArray));

		
	}
</script>

<title>IAM Competition Software</title>
</head>
<body onLoad="goToSelection()" oncontextmenu="return false" onselectstart="return false" onkeydown="if ((arguments[0] || window.event).ctrlKey && (arguments[0] || window.event).keyCode == 86) return false">
<!--<body onLoad="goToSelection()">-->
<div class="container-fluid full-height">

<!--Logo row-->
<div class="row" id="logoRow" style="display:block">
<div class="col-md-3"><br /><button id="btnBackToSelection" style="display:none" class="btn btn-primary" onclick="goToSelection();">Back to discipline selection</button></div>
<div class="col-md-6 text-center"><br /><img src="IAM-main-Logo-transparent-bg-for-web.png" height=50><br /><br /><br /></div>
<div class="col-md-3"></div>
</div>

<div class="row" id="topMargin" style="display:none"><div class="col-md-3"><br /><button id="btnBackToSelection2" class="btn btn-primary" onclick="goToSelection();">Back to discipline selection</button></div>
<div class="col-md-6 text-center"></div>
<div class="col-md-3"></div>
</div>

<!--Selection container row-->
<div class="row" id="selectionRow" style="display:block">
<div class="col-md-2"></div>
<div class="col-md-8 jumbotron selection text-center">
<h4>Select a competition format from the list below.</h4>
  <select id="selFormat" onChange="changeDisciplines();">
<option value="N">National standard</option>
<option value="I">International standard</option>
<option value="W">World championship standard</option>
</select>
<br /><br />
<h4>Select a discipline from the list below.</h4>
  <select id="selDiscipline">
<option value="5N">5-minute Numbers</option>
<option value="15N">15-minute Numbers</option>
<option value="5F">5-minute Names & Faces</option>
<option value="5W">5-minute Words</option>
<option value="D">5-minute Dates</option>
<option value="SC">Speed cards</option>
<option value="10C">10-minute Cards</option>
<option value="5I">5-minute Images</option>
<!--<option value="S">Spoken Numbers</option> -->
<option value="5B">5-minute Binary</option>
</select>

<br /><br />
<!--
Skin:     <select id="selSkin"><option value="analogue1" style="background-image: url('hugeWood4.jpg');color:white">Analogue 1</option>
<option value="digital1" style="background-color:#000000;color:white" selected>Digital 1</option></select>-->
<div class="row">
<div class="col-md-2"></div>
<div class="col-md-4">
<img src="analogueOption.png" class="skinOptionImg" />
<br /><input type='radio' name='selSkin' value='analogue1' checked>
<br />Analogue
</div>
<div class="col-md-4">
  <img src="digitalOption.png" class="skinOptionImg" />
<br /><input type='radio' name='selSkin' value='digital1'>
<br />Digital
</div>
</div>

<br /><button id="btnGo" class="btn btn-primary" disabled onclick="goToSettings();">Loading images... Please wait</button>
<br /><br /><button id="btnResume" class="btn btn-primary" style="visibility:hidden" onclick="resumeAttempt();">Resume previous attempt</button>

</div>


<div class="col-md-2"></div>
</div>

<!--Settings container row-->
<div class="row" id="settingsRow0" style="display:none">
<div class="col-md-1"></div>
<div id="settingsBox" class="col-md-10 jumbotron settings text-center">
<h3 class="disciplineTitle"></h3>
<br />
<span style="border:1px dotted;padding:4px;"><b>Important:</b> <span style="font-weight:normal">please press <span class="keybutton">F11</span> (Windows) or <span class="keycombo">&Hat; + &#8984; + F (Control+Cmd+F)</span> (Mac) for full screen</span></span>
<div id="divGrouping">
<br />Grouping:     <select id="selGrouping" onchange="resetMiniGroupings();resetSeparations();updatePreview();">
<option value="1">1</option>
<option value="2">2</option>
<option value="3" selected>3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
</select>
<div id="divComplexGrouping">
<br />
<!--Images per locus: <input size=1 value="1" id="inpImgsPerLocus" type="text">&nbsp;<button class="btn btn-primary" onclick="applyImgsPerLocus();">Apply</button>
<br /><br />-->
Or specify a more complex grouping, e.g. 3-2 or 3-2-3: <input size=8 id="inpMiniGroupings" type="text">&nbsp;<button class="btn btn-primary" onclick="applyMiniGroupings();">Apply</button>
<br /><br />
Specify line separation, e.g. 3 for a line every 3 digits, or 3-2-3: <input id="inpSeparation" type="text">&nbsp;<button class="btn btn-primary" onclick="applySeparation();">Apply</button>
</div>
</div>
<div id="divBinGrouping">
	<br />
<span>
Width:     <select id="selBinGroupingW" onchange="resetSeparations();updatePreview();">
<option value="1">1</option>
<option value="2">2</option>
<option value="3" selected>3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
<option value="9">9</option>
<option value="10">10</option>
</select>
</span><span>
Height:     <select id="selBinGroupingH" onchange="resetSeparations();updatePreview();">
<option value="1">1</option>
<option value="2">2</option>
<option value="3" selected>3</option>
<option value="4">4</option>
<option value="5">5</option>
<option value="6">6</option>
<option value="7">7</option>
<option value="8">8</option>
<option value="9">9</option>
<option value="10">10</option>
</select>
 (select 1 if not using matrices)

 <br /><br />
Specify line separation, e.g. 4-3-3: <input id="inpSeparationBin" type="text">&nbsp;<button class="btn btn-primary" onclick="applySeparationBin();">Apply</button>
</span></div>

<div id="divHighlightColour">
	<br />
Highlight colour:     <select id="selHColour"  onchange="changeSelHColour()" > <!--style="background-color:#b3ff66"-->
<option value="red" style="background-color:#ff8080">red</option>
<option value="orange" style="background-color:#ffa366">orange</option>
<option value="yellow" style="background-color:#ffff80">yellow</option>
<option value="green" style="background-color:#b3ff66">green</option>
<option value="sky"  style="background-color:#80bfff" selected>blue</option>
<option value="purple"  style="background-color:#df9fbf">purple</option>
<!--<option value="rgba(238,170,238,0.5)"  style="background-color:#eeaaee">&nbsp;&nbsp;</option>-->
</select>
</div>

<div id="divDatesLanguages">
	<br />
	Language:     <select id="selDatesLanguage" onchange="resetPreload();">
	</select>
	</div>
	
	<div id="divWordsLanguages">
		<br />
		Language:     <select id="selWordsLanguage"  onchange="resetPreload();">
		</select>
		</div>
		
	<div id="divNamesCharsets">
		<br />
		Character set:     <select id="selNamesCharset"  onchange="resetPreload();">
		</select>
		</div>
		

<div id="divSkip">
	<br />
<label for="chkSkipFinalImage">Skip final image in row?</label><input type="checkbox" id="chkSkipFinalImage">
</div>

<div id="divCardSet">
		<div id="divDecks" style="flex:1">
				Decks:     <input id="inpDecks" type="text" size=3>	

			</div>

			<div style="flex:1">
		Card set:     <select id="selCardSet"  onchange="resetPreload();updatePreview();">
			<option value="1">Standard</option>
			<option value="2">French (VDR)</option>
			<option value="3">French (BDK)</option>		
			<option value="4">Worn</option>			
		</select>
		</div>
		<div id="divDirection" style="flex:1">
			<label for="chkLeftToRight">Cards from left to right:</label>     <input type="checkbox" id="chkLeftToRight" checked>
		</div>

</div>

<div id="divPreview">
	<br />
<h4>Preview</h4>
<div id="preview" class="centred text-center" style="width:100%;">

<img src='Card images 1/c13.png'>

</div>
</div>

<div id="divInstructions" class="centred text-center">
	</div>
<div class="flexParent">
    <div class="flexChild"><button class="btn btn-primary" id="btnPreload" onclick="preloadData();this.setAttribute('disabled','')">Preload data</button></div>    
    <div class="flexChild"><button class="btn btn-primary glowButton" id="btnStartMemoCountdown" onclick="handleStartClick()">Start</button></div>
    <div class="flexChild"><button class="btn btn-primary" id="btnTest" onclick="testPage();">Test page</button></div>
</div>
</div>
<div class="col-md-1"></div>
</div>

<!--Countdown container row-->
<div class="row" id="countdownRow">
<div class="col-md-1"></div>
<div id="countdownBox" class="col-md-10 jumbotron countdown text-center">
<h3 class="countdownDisciplineTitle"></h3>
<!--<table class="countdownTable"><tr><td style="margin:0 auto"><span id="countdownText"></span><span style="width:40px" id="countdownTime"></span></td></tr></table>-->
<table id="countdownTable">
   <tr><td id="countdownText"></td></tr>
   <tr><td id="countdownTime"></td></tr>
</table>
<table id="countdownRecallTable">
  <tr><td><span id="countdownRecallText"></span></td></tr>
  <tr><td><span id="countdownRecallTime"></span></td></tr>
</table>
<!--
  <div class="row">
  <div class="col-md-3"></div>
  <div class="col-md-6 text-center">
  <table class="countdownTable"><tr><td><span id="countdownText"></span><span id="countdownTime"></span></td></tr></table>
   </div>
   <div class="col-md-3"></div>
   </div>
-->
</div>
<div class="col-md-1"></div>
</div>

<!--Memo container row-->
<div class="row" id="memoRow">
<!--<div class="row topMargin"></div>-->
<div class="col-md-1"></div>
<div id="memoBox" class="col-md-10 jumbotron">

  <table class="disciplineHeadingTable"><tr><td class="disciplineTitleMemo textNonCards"></td><!--<td><span id="digital1RecallTimeOuter" style="display:none"><span>Recall time remaining: </span></td>--><td id='digital1MemoTimeOuterTd'><span id='digital1MemoTimeOuter'><span>Memorisation time remaining: </span><span id="digital1MemoTimeInner"></span></span></td><td></td><td></td></tr></table>
  
<div id="menuDiv"></div>
<br />

<div id="wrapper">
<div id="memoContentDiv" class="memoContent"></div>

<div id="overlayDiv" class="overlay"></div>

</div>

<div class="bottom-right-timer row">
  <div class='col-md-10'></div>
<div class='col-md-2' id='analogue1MemoTimeOuter'><span id="analogue1MemoTimeInner"></span></div>
</div>

<div class="col-md-1"></div>
</div>
</div>
<!--Recall container row-->

<div class="row" id="recallRow">
<!--  <div class="row topMargin"></div>-->
<div class="col-md-1"></div>
<div id="recallBox" class="col-md-10">
  <table class="disciplineHeadingTable"><tr><td class="disciplineTitleMemo textNonCards"></td><td><span id="cardsMemoTime"></span></td><td id="digital1RecallTimeOuterTd"><span id="digital1RecallTimeOuter" style="display:none"><span>Recall time remaining: </span><span id="digital1RecallTimeInner"></span></span></td></tr></table>
  <div id="menuRecallDiv"></div>


<div id="recallContentDiv" class="recallContent"></div>
</div>

<div class="bottom-right-timer row">
<br />
	<div class='col-md-8'></div>
	<div class='col-md-2' id="finishBtnDiv"></div>
<div class='col-md-2' id='analogue1RecallTimeOuter'><span id="analogue1RecallTimeInner"></span></div>
</div>

<div class="col-md-1"></div>
</div>

<!--Score container row-->
<div class="row full-height" id="scoreRow">
<!--<div class="row topMargin"></div>-->
<div class="col-md-1"></div>
<div id="scoreBox" class="col-md-10">
  <!--<table class="disciplineHeadingTable"><tr><td class="disciplineTitleMemo"></td><td><span>Memorisation time: </span><span id="spanScoreMemoTimeTaken"></span></td><td><span>Recall time: </span><span id="spanScoreRecallTimeTaken"></span></td><td colspan=3><span id="spanOuterScore">Score: </span><span id="spanScore"></span><span id="spanCorrect"></span></td></tr></table>-->
  <table class="disciplineHeadingTable"><tr><td class="disciplineTitleMemo textNonCards"></td><td><span id="spanOuterScore">Score: </span><span id="spanScore"></span><span id="spanCorrect"></span></td><td><span id="cardsMemoTimeScore"></span></td></tr></table>
  <div id="menuScoreDiv"></div>
  
<div id="scoreContentDiv" class="scoreContent"></div>
</div>

<div class="bottom-right-timer row">
  <div class='col-md-10'></div>
<div class='col-md-2' id='analogue1ScoreTimeOuter'><span id="analogue1ScoreTimeInner"></span></div>
</div>

<div class="col-md-1"></div>
</div>

</div>
<div id="hiddenDiv" style="visibility:hidden"></div>
</body>
</html>
